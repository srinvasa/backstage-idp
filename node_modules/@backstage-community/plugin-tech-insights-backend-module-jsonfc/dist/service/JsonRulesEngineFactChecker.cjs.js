'use strict';

var errors = require('@backstage/errors');
var Ajv = require('ajv');
var jsonRulesEngine = require('json-rules-engine');
var lodash = require('lodash');
var constants = require('../constants.cjs.js');
var CheckRegistry = require('./CheckRegistry.cjs.js');
var config = require('./config.cjs.js');
var validationSchema = require('./validation-schema.json.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var Ajv__default = /*#__PURE__*/_interopDefaultCompat(Ajv);

const noopEvent = {
  type: "noop"
};
class JsonRulesEngineFactChecker {
  checkRegistry;
  repository;
  logger;
  validationSchema;
  operators;
  constructor(options) {
    const { checks, repository, logger, checkRegistry, operators } = options;
    this.repository = repository;
    this.logger = logger;
    this.operators = operators || [];
    this.validationSchema = JSON.parse(JSON.stringify(validationSchema));
    this.operators.forEach((op) => {
      this.validationSchema.definitions.condition.properties.operator.anyOf.push(
        { const: op.name }
      );
    });
    checks.forEach((check) => this.validate(check));
    this.checkRegistry = checkRegistry ?? new CheckRegistry.DefaultCheckRegistry(checks);
  }
  async runChecks(entity, checks) {
    const engine = new jsonRulesEngine.Engine();
    this.operators.forEach((op) => {
      engine.addOperator(op);
    });
    const techInsightChecks = checks ? await this.checkRegistry.getAll(checks) : await this.checkRegistry.list();
    const factRetrieversIds = techInsightChecks.flatMap((it) => it.factIds);
    const facts = await this.repository.getLatestFactsByIds(
      factRetrieversIds,
      entity
    );
    const schemas = await this.repository.getLatestSchemas(factRetrieversIds);
    const factNames = lodash.flatten(schemas.map((schema) => Object.keys(schema)));
    const factValues = Object.values(facts).reduce(
      (acc, it) => ({ ...acc, ...it.facts }),
      {}
    );
    techInsightChecks.forEach((techInsightCheck) => {
      const rule = techInsightCheck.rule;
      rule.name = techInsightCheck.id;
      const usedFacts = this.retrieveIndividualFactReferences(
        techInsightCheck.rule.conditions
      );
      const allFactsNamesArePresent = usedFacts.every(
        (factId) => factNames.includes(factId)
      );
      if (!allFactsNamesArePresent) {
        throw new Error(
          `Not all facts are defined: ${usedFacts.filter(
            (usedFact) => !factNames.includes(usedFact)
          )}`
        );
      }
      const hasFacts = usedFacts.every(
        (factId) => factValues.hasOwnProperty(factId)
      );
      if (hasFacts) {
        engine.addRule({ ...techInsightCheck.rule, event: noopEvent });
      } else {
        this.logger.debug(
          `Skipping ${rule.name} due to missing facts: ${techInsightCheck.factIds.filter((factId) => !facts[factId]).join(", ")}`
        );
      }
    });
    try {
      const results = await engine.run(factValues);
      return await this.ruleEngineResultsToCheckResponse(
        results,
        techInsightChecks,
        Object.values(facts)
      );
    } catch (e) {
      if (errors.isError(e)) {
        throw new Error(`Failed to run rules engine, ${e.message}`, {
          cause: e
        });
      }
      throw e;
    }
  }
  async validate(check) {
    const ajv = new Ajv__default.default({ verbose: true });
    const validator = ajv.compile(this.validationSchema);
    const isValidToSchema = validator(check.rule);
    if (check.type !== constants.JSON_RULE_ENGINE_CHECK_TYPE) {
      const msg = `Only ${constants.JSON_RULE_ENGINE_CHECK_TYPE} checks can be registered to this fact checker`;
      this.logger.warn(msg);
      return {
        valid: false,
        message: msg
      };
    }
    if (!isValidToSchema) {
      const msg = "Failed to to validate conditions against JSON schema";
      this.logger.warn(
        "Failed to to validate conditions against JSON schema",
        new Error(JSON.stringify(validator.errors))
      );
      return {
        valid: false,
        message: msg,
        errors: validator.errors ? validator.errors : void 0
      };
    }
    const existingSchemas = await this.repository.getLatestSchemas(
      check.factIds
    );
    const references = this.retrieveIndividualFactReferences(
      check.rule.conditions
    );
    const results = references.map((ref) => ({
      ref,
      result: existingSchemas.some((schema) => schema.hasOwnProperty(ref))
    }));
    const failedReferences = results.filter((it) => !it.result);
    failedReferences.forEach((it) => {
      this.logger.warn(
        `Validation failed for check ${check.name}. Reference to value ${it.ref} does not exists in referred fact schemas: ${check.factIds.join(",")}`
      );
    });
    const valid = failedReferences.length === 0;
    return {
      valid,
      ...!valid ? {
        message: `Check is referencing missing values from fact schemas: ${failedReferences.map((it) => it.ref).join(",")}`
      } : {}
    };
  }
  getChecks() {
    return this.checkRegistry.list();
  }
  retrieveIndividualFactReferences(condition) {
    let results = [];
    if ("all" in condition) {
      results = results.concat(
        condition.all.flatMap(
          (con) => this.retrieveIndividualFactReferences(con)
        )
      );
    } else if ("any" in condition) {
      results = results.concat(
        condition.any.flatMap(
          (con) => this.retrieveIndividualFactReferences(con)
        )
      );
    } else if ("not" in condition) {
      results = results.concat(
        this.retrieveIndividualFactReferences(condition.not)
      );
    } else if ("condition" in condition) ; else {
      results.push(condition.fact);
    }
    return results;
  }
  async ruleEngineResultsToCheckResponse(results, techInsightChecks, facts) {
    return await Promise.all(
      [
        ...results.results && results.results,
        ...results.failureResults && results.failureResults
      ].map(async (result) => {
        const techInsightCheck = techInsightChecks.find(
          (check) => check.id === result.name
        );
        if (!techInsightCheck) {
          throw new Error(
            `Failed to determine tech insight check with id ${result.name}. Discrepancy between ran rule engine and configured checks.`
          );
        }
        const factResponse = await this.constructFactInformationResponse(
          facts,
          techInsightCheck
        );
        return {
          facts: factResponse,
          result: result.result,
          check: JsonRulesEngineFactChecker.constructCheckResponse(
            techInsightCheck,
            result
          )
        };
      })
    );
  }
  static constructCheckResponse(techInsightCheck, result) {
    const returnable = {
      id: techInsightCheck.id,
      type: techInsightCheck.type,
      name: techInsightCheck.name,
      description: techInsightCheck.description,
      factIds: techInsightCheck.factIds,
      metadata: result.result ? { ...techInsightCheck.metadata, ...techInsightCheck.successMetadata } : { ...techInsightCheck.metadata, ...techInsightCheck.failureMetadata },
      rule: { conditions: {} },
      links: techInsightCheck.links
    };
    if ("toJSON" in result) {
      const rule = JSON.parse(result.toJSON());
      return { ...returnable, rule: lodash.pick(rule, ["conditions"]) };
    }
    return returnable;
  }
  async constructFactInformationResponse(facts, techInsightCheck) {
    const factSchemas = await this.repository.getLatestSchemas(
      techInsightCheck.factIds
    );
    const schemas = factSchemas.reduce(
      (acc, schema) => ({ ...acc, ...schema }),
      {}
    );
    const individualFacts = this.retrieveIndividualFactReferences(
      techInsightCheck.rule.conditions
    );
    const factValues = facts.filter(
      (factContainer) => techInsightCheck.factIds.includes(factContainer.id)
    ).reduce(
      (acc, factContainer) => ({
        ...acc,
        ...lodash.pick(factContainer.facts, individualFacts)
      }),
      {}
    );
    return Object.entries(factValues).reduce((acc, [key, value]) => {
      return {
        ...acc,
        [key]: {
          value,
          ...schemas[key]
        }
      };
    }, {});
  }
}
class JsonRulesEngineFactCheckerFactory {
  checks;
  logger;
  checkRegistry;
  operators;
  static fromConfig(config$1, options) {
    const checks = config.readChecksFromConfig(config$1, { logger: options.logger });
    return new JsonRulesEngineFactCheckerFactory({
      ...options,
      checks
    });
  }
  constructor(options) {
    this.logger = options.logger;
    this.checks = options.checks;
    this.checkRegistry = options.checkRegistry;
    this.operators = options.operators;
  }
  /**
   * @param repository - Implementation of TechInsightsStore. Used by the returned JsonRulesEngineFactChecker
   *                     to retrieve fact and fact schema data
   * @returns JsonRulesEngineFactChecker implementation
   */
  construct(repository) {
    return new JsonRulesEngineFactChecker({
      checks: this.checks,
      logger: this.logger,
      checkRegistry: this.checkRegistry,
      repository,
      operators: this.operators
    });
  }
}

exports.JsonRulesEngineFactChecker = JsonRulesEngineFactChecker;
exports.JsonRulesEngineFactCheckerFactory = JsonRulesEngineFactCheckerFactory;
//# sourceMappingURL=JsonRulesEngineFactChecker.cjs.js.map
