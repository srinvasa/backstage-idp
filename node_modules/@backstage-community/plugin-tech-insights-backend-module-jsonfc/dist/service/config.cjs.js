'use strict';

function readRuleConditionProperties(config) {
  const fact = config.getString("fact");
  const name = config.getOptionalString("name");
  const operator = config.getString("operator");
  const params = config.getOptionalConfig("params")?.get();
  const path = config.getOptionalString("path");
  const priority = config.getOptionalNumber("priority");
  const value = config.get("value");
  return {
    fact,
    name,
    operator,
    params,
    path,
    priority,
    value
  };
}
function readRuleNestedCondition(config) {
  if (config.has("fact")) {
    return readRuleConditionProperties(config);
  }
  return readRuleTopLevelCondition(config);
}
function readRuleTopLevelCondition(config) {
  const base = {
    name: config.getOptionalString("name"),
    priority: config.getOptionalNumber("priority")
  };
  if (config.has("all")) {
    const all = config.getConfigArray("all").map((conditionConfig) => readRuleNestedCondition(conditionConfig));
    return {
      ...base,
      all
    };
  }
  if (config.has("any")) {
    const any = config.getConfigArray("any").map((conditionConfig) => readRuleNestedCondition(conditionConfig));
    return {
      ...base,
      any
    };
  }
  if (config.has("not")) {
    const not = readRuleNestedCondition(config.getConfig("not"));
    return {
      ...base,
      not
    };
  }
  const condition = config.getString("condition");
  return {
    ...base,
    condition
  };
}
function readRuleFromRuleConfig(config) {
  const conditions = readRuleTopLevelCondition(config.getConfig("conditions"));
  const name = config.getOptionalString("name");
  const priority = config.getOptionalNumber("priority");
  return {
    conditions,
    name,
    priority
  };
}
function readLinksForCheck(linkConfig, opts) {
  const checkLinks = [];
  linkConfig?.map((link) => {
    try {
      checkLinks.push({
        title: link.getString("title"),
        url: link.getString("url")
      });
    } catch (e) {
      opts.logger.error("Missing required fields for link in check config", e);
    }
  });
  if (checkLinks.length === 0) {
    return void 0;
  }
  return checkLinks;
}
function readCheckFromCheckConfig(id, config, opts) {
  const type = config.getString("type");
  const name = config.getString("name");
  const description = config.getString("description");
  const factIds = config.getStringArray("factIds");
  const metadata = config.getOptionalConfig("metadata")?.get();
  const successMetadata = config.getOptionalConfig("successMetadata")?.get();
  const failureMetadata = config.getOptionalConfig("failureMetadata")?.get();
  const rule = readRuleFromRuleConfig(config.getConfig("rule"));
  const links = readLinksForCheck(config.getOptionalConfigArray("links"), opts);
  return {
    description,
    factIds,
    failureMetadata,
    id,
    metadata,
    name,
    rule,
    successMetadata,
    type,
    links
  };
}
function readChecksFromConfig(config, opts) {
  const key = "techInsights.factChecker.checks";
  if (!config.has(key)) {
    return [];
  }
  const checksConfig = config.getConfig(key);
  const checks = [];
  checksConfig.keys().forEach((checkId) => {
    const checkConfig = checksConfig.getConfig(checkId);
    checks.push(readCheckFromCheckConfig(checkId, checkConfig, opts));
  });
  return checks;
}

exports.readChecksFromConfig = readChecksFromConfig;
//# sourceMappingURL=config.cjs.js.map
