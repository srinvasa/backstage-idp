import * as _backstage_core_plugin_api from '@backstage/core-plugin-api';
import { Entity } from '@backstage/catalog-model';

/** @public */
type MetricKey = 'alert_status' | 'bugs' | 'reliability_rating' | 'vulnerabilities' | 'security_rating' | 'code_smells' | 'sqale_rating' | 'security_hotspots_reviewed' | 'security_review_rating' | 'coverage' | 'duplicated_lines_density';
/** @public */
type SonarUrlProcessorFunc = (identifier: string) => string;
/**
 * @public
 *
 * Define a type to make sure that all metrics are used
 */
type Metrics = {
    [key in MetricKey]: string | undefined;
};
/** @public */
interface FindingSummary {
    lastAnalysis: string;
    metrics: Metrics;
    projectUrl: string;
    getIssuesUrl: SonarUrlProcessorFunc;
    getComponentMeasuresUrl: SonarUrlProcessorFunc;
    getSecurityHotspotsUrl: () => string;
}
/** @public */
declare const sonarQubeApiRef: _backstage_core_plugin_api.ApiRef<SonarQubeApi>;
/** @public */
type SonarQubeApi = {
    getFindingSummary(options: {
        componentKey?: string;
        projectInstance?: string;
    }): Promise<FindingSummary | undefined>;
};

/** @public */
declare const SONARQUBE_PROJECT_KEY_ANNOTATION = "sonarqube.org/project-key";
/** @public */
declare const isSonarQubeAvailable: (entity: Entity) => boolean;

/**
 *
 * Try to parse sonarqube information from an entity.
 *
 * If part or all info are not found, they will default to undefined
 *
 * @public
 * @param entity - entity to find the sonarqube information from.
 * @returns a ProjectInfo properly populated.
 */
declare const useProjectInfo: (entity: Entity) => {
    projectInstance: string | undefined;
    projectKey: string | undefined;
};

export { type FindingSummary, type MetricKey, type Metrics, SONARQUBE_PROJECT_KEY_ANNOTATION, type SonarQubeApi, type SonarUrlProcessorFunc, isSonarQubeAvailable, sonarQubeApiRef, useProjectInfo };
