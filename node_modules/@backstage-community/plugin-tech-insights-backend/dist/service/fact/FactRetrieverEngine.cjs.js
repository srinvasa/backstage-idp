'use strict';

var luxon = require('luxon');

function randomDailyCron() {
  const rand = (min, max) => Math.floor(Math.random() * (max - min + 1) + min);
  return `${rand(0, 59)} ${rand(0, 23)} * * *`;
}
function duration(startTimestamp) {
  const delta = process.hrtime(startTimestamp);
  const seconds = delta[0] + delta[1] / 1e9;
  return `${seconds.toFixed(1)}s`;
}
class DefaultFactRetrieverEngine {
  constructor(repository, factRetrieverRegistry, factRetrieverContext, logger, scheduler, defaultCadence, defaultTimeout, defaultInitialDelay) {
    this.repository = repository;
    this.factRetrieverRegistry = factRetrieverRegistry;
    this.factRetrieverContext = factRetrieverContext;
    this.logger = logger;
    this.scheduler = scheduler;
    this.defaultCadence = defaultCadence;
    this.defaultTimeout = defaultTimeout;
    this.defaultInitialDelay = defaultInitialDelay;
  }
  static async create(options) {
    const {
      repository,
      factRetrieverRegistry,
      factRetrieverContext,
      scheduler,
      defaultCadence,
      defaultTimeout,
      defaultInitialDelay
    } = options;
    const retrievers = await factRetrieverRegistry.listRetrievers();
    await Promise.all(retrievers.map((it) => repository.insertFactSchema(it)));
    return new DefaultFactRetrieverEngine(
      repository,
      factRetrieverRegistry,
      factRetrieverContext,
      factRetrieverContext.logger,
      scheduler,
      defaultCadence,
      defaultTimeout,
      defaultInitialDelay
    );
  }
  async scheduleRegistration(registration) {
    const { factRetriever, cadence, lifecycle, timeout, initialDelay } = registration;
    const cronExpression = cadence || this.defaultCadence || randomDailyCron();
    const timeLimit = timeout || this.defaultTimeout || luxon.Duration.fromObject({ minutes: 5 });
    const initialDelaySetting = initialDelay || this.defaultInitialDelay || luxon.Duration.fromObject({ seconds: 5 });
    await this.scheduler.scheduleTask({
      id: factRetriever.id,
      frequency: { cron: cronExpression },
      fn: this.createFactRetrieverHandler(factRetriever, lifecycle),
      timeout: timeLimit,
      // We add a delay in order to prevent errors due to the
      // fact that the backend is not yet online in a cold-start scenario
      initialDelay: initialDelaySetting
    });
  }
  async scheduleJob(ref) {
    const registration = await this.factRetrieverRegistry.get(ref);
    return this.scheduleRegistration(registration);
  }
  async schedule() {
    const registrations = await this.factRetrieverRegistry.listRegistrations();
    const newRegs = [];
    await Promise.all(
      registrations.map(async (registration) => {
        try {
          await this.scheduleRegistration(registration);
          newRegs.push(registration.factRetriever.id);
        } catch (e) {
          this.logger.warn(
            `Failed to schedule fact retriever ${registration.factRetriever.id}, ${e}`
          );
        }
      })
    );
    this.logger.info(
      `Scheduled ${newRegs.length}/${registrations.length} fact retrievers into the tech-insights engine`
    );
  }
  getJobRegistration(ref) {
    return this.factRetrieverRegistry.get(ref);
  }
  async triggerJob(ref) {
    await this.scheduler.triggerTask(ref);
  }
  createFactRetrieverHandler(factRetriever, lifecycle) {
    return async () => {
      const startTimestamp = process.hrtime();
      this.logger.info(
        `Retrieving facts for fact retriever ${factRetriever.id}`
      );
      let facts = [];
      try {
        facts = await factRetriever.handler({
          ...this.factRetrieverContext,
          logger: this.logger.child({ factRetrieverId: factRetriever.id }),
          entityFilter: factRetriever.entityFilter
        });
        this.logger.debug(
          `Retrieved ${facts.length} facts for fact retriever ${factRetriever.id} in ${duration(startTimestamp)}`
        );
      } catch (e) {
        this.logger.error(
          `Failed to retrieve facts for retriever ${factRetriever.id}`,
          e
        );
      }
      try {
        await this.repository.insertFacts({
          id: factRetriever.id,
          facts,
          lifecycle
        });
        this.logger.info(
          `Stored ${facts.length} facts for fact retriever ${factRetriever.id} in ${duration(startTimestamp)}`
        );
      } catch (e) {
        this.logger.warn(
          `Failed to insert facts for fact retriever ${factRetriever.id}`,
          e
        );
      }
    };
  }
}

exports.DefaultFactRetrieverEngine = DefaultFactRetrieverEngine;
//# sourceMappingURL=FactRetrieverEngine.cjs.js.map
