'use strict';

var catalogClient = require('@backstage/catalog-client');
var isEmpty = require('lodash/isEmpty');
var luxon = require('luxon');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var isEmpty__default = /*#__PURE__*/_interopDefaultCompat(isEmpty);

const entityMetadataFactRetriever = {
  id: "entityMetadataFactRetriever",
  version: "0.0.1",
  title: "Entity Metadata",
  description: "Generates facts which indicate the completeness of entity metadata",
  schema: {
    hasTitle: {
      type: "boolean",
      description: "The entity has a title in metadata"
    },
    hasDescription: {
      type: "boolean",
      description: "The entity has a description in metadata"
    },
    hasTags: {
      type: "boolean",
      description: "The entity has tags in metadata"
    }
  },
  handler: async ({ discovery, entityFilter, auth }) => {
    const { token } = await auth.getPluginRequestToken({
      onBehalfOf: await auth.getOwnServiceCredentials(),
      targetPluginId: "catalog"
    });
    const catalogClient$1 = new catalogClient.CatalogClient({
      discoveryApi: discovery
    });
    const entities = await catalogClient$1.getEntities(
      { filter: entityFilter },
      { token }
    );
    return entities.items.map((entity) => {
      return {
        entity: {
          namespace: entity.metadata.namespace,
          kind: entity.kind,
          name: entity.metadata.name
        },
        facts: {
          hasTitle: Boolean(entity.metadata?.title),
          hasDescription: Boolean(entity.metadata?.description),
          hasTags: !isEmpty__default.default(entity.metadata?.tags)
        },
        timestamp: luxon.DateTime.now()
      };
    });
  }
};

exports.entityMetadataFactRetriever = entityMetadataFactRetriever;
//# sourceMappingURL=entityMetadataFactRetriever.cjs.js.map
