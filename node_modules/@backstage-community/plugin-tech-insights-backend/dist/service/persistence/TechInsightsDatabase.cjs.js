'use strict';

var semver = require('semver');
var lodash = require('lodash');
var luxon = require('luxon');
var catalogModel = require('@backstage/catalog-model');
var utils = require('../fact/factRetrievers/utils.cjs.js');

class TechInsightsDatabase {
  constructor(db, logger) {
    this.db = db;
    this.logger = logger;
  }
  CHUNK_SIZE = 50;
  async getLatestSchemas(ids) {
    const queryBuilder = this.db("fact_schemas");
    if (ids) {
      queryBuilder.whereIn("id", ids);
    }
    const existingSchemas = await queryBuilder.orderBy("id", "desc").select();
    const groupedSchemas = lodash.groupBy(existingSchemas, "id");
    return Object.values(groupedSchemas).map((schemas) => {
      const sorted = semver.rsort(schemas.map((it) => it.version));
      return schemas.find((it) => it.version === sorted[0]);
    }).map((it) => ({
      ...lodash.omit(it, "schema"),
      ...JSON.parse(it.schema),
      entityFilter: it.entityFilter ? JSON.parse(it.entityFilter) : null
    }));
  }
  async insertFactSchema(schemaDefinition) {
    const { id, version, schema, entityFilter } = schemaDefinition;
    const existingSchemas = await this.db("fact_schemas").where({ id }).and.where({ version }).select();
    if (!existingSchemas || existingSchemas.length === 0) {
      await this.db("fact_schemas").insert({
        id,
        version,
        entityFilter: entityFilter ? JSON.stringify(entityFilter) : void 0,
        schema: JSON.stringify(schema)
      });
    }
  }
  async insertFacts({
    id,
    facts,
    lifecycle
  }) {
    if (facts.length === 0) return;
    const currentSchema = await this.getLatestSchema(id);
    const factRows = facts.map((it) => {
      const ts = it.timestamp?.toISO();
      return {
        id,
        version: currentSchema.version,
        entity: catalogModel.stringifyEntityRef(it.entity),
        facts: JSON.stringify(it.facts),
        ...ts && { timestamp: ts }
      };
    });
    await this.db.transaction(async (tx) => {
      await tx.batchInsert("facts", factRows, this.CHUNK_SIZE);
      if (lifecycle && utils.isTtl(lifecycle)) {
        const expiration = luxon.DateTime.now().minus(lifecycle.timeToLive);
        await this.deleteExpiredFactsByDate(tx, id, expiration);
      }
      if (lifecycle && utils.isMaxItems(lifecycle)) {
        await this.deleteExpiredFactsByNumber(tx, id, lifecycle.maxItems);
      }
    });
  }
  async getLatestFactsByIds(ids, entityTriplet) {
    const results = await this.db("facts").where({ entity: entityTriplet }).and.whereIn("id", ids).join(
      this.db("facts").max("timestamp as maxTimestamp").column("id as subId").where({ entity: entityTriplet }).and.whereIn("id", ids).groupBy("id").as("subQ"),
      {
        "facts.id": "subQ.subId",
        "facts.timestamp": "subQ.maxTimestamp"
      }
    );
    return this.dbFactRowsToTechInsightFacts(results);
  }
  async getEntities() {
    const results = await this.db("facts").distinct("entity");
    return results.map((row) => catalogModel.parseEntityRef(row.entity));
  }
  async getFactsBetweenTimestampsByIds(ids, entityTriplet, startDateTime, endDateTime) {
    const results = await this.db("facts").where({ entity: entityTriplet }).and.whereIn("id", ids).and.whereBetween("timestamp", [
      startDateTime.toISO(),
      endDateTime.toISO()
    ]);
    return lodash.groupBy(
      results.map((it) => {
        const { namespace, kind, name } = catalogModel.parseEntityRef(it.entity);
        const timestamp = typeof it.timestamp === "string" ? luxon.DateTime.fromISO(it.timestamp) : luxon.DateTime.fromJSDate(it.timestamp);
        return {
          id: it.id,
          entity: { namespace, kind, name },
          timestamp,
          version: it.version,
          facts: JSON.parse(it.facts)
        };
      }),
      "id"
    );
  }
  async getLatestSchema(id) {
    const existingSchemas = await this.db("fact_schemas").where({ id }).orderBy("id", "desc").select();
    if (existingSchemas.length < 1) {
      this.logger.warn(`No schema found for ${id}. `);
      throw new Error(`No schema found for ${id}. `);
    }
    const sorted = semver.rsort(existingSchemas.map((it) => it.version));
    return existingSchemas.find((it) => it.version === sorted[0]);
  }
  async deleteExpiredFactsByDate(tx, factRetrieverId, timestamp) {
    await tx("facts").where({ id: factRetrieverId }).and.where("timestamp", "<", timestamp.toISO()).delete();
  }
  async deleteExpiredFactsByNumber(tx, factRetrieverId, maxItems) {
    const deletionFilterQuery = (subTx) => subTx.select(["id", "entity", "timestamp"]).from("facts").where({ id: factRetrieverId }).and.whereIn(
      "entity",
      (db) => db.distinct("entity").where({ id: factRetrieverId })
    ).and.leftJoin(
      (joinTable) => joinTable.select("*").from(
        this.db("facts").column(
          { fid: "id" },
          { fentity: "entity" },
          { ftimestamp: "timestamp" }
        ).column(
          this.db.raw(
            "row_number() over (partition by id, entity order by timestamp desc) as fact_rank"
          )
        ).as("ranks")
      ).where("fact_rank", "<=", maxItems).as("filterjoin"),
      (joinClause) => {
        joinClause.on("filterjoin.fid", "facts.id").on("filterjoin.fentity", "facts.entity").on("filterjoin.ftimestamp", "facts.timestamp");
      }
    ).whereNull("filterjoin.fid");
    await tx("facts").whereIn(
      ["id", "entity", "timestamp"],
      (database) => deletionFilterQuery(database)
    ).delete();
  }
  dbFactRowsToTechInsightFacts(rows) {
    return rows.reduce((acc, it) => {
      const { namespace, kind, name } = catalogModel.parseEntityRef(it.entity);
      const timestamp = typeof it.timestamp === "string" ? luxon.DateTime.fromISO(it.timestamp) : luxon.DateTime.fromJSDate(it.timestamp);
      return {
        ...acc,
        [it.id]: {
          id: it.id,
          entity: { namespace, kind, name },
          timestamp,
          version: it.version,
          facts: JSON.parse(it.facts)
        }
      };
    }, {});
  }
}

exports.TechInsightsDatabase = TechInsightsDatabase;
//# sourceMappingURL=TechInsightsDatabase.cjs.js.map
