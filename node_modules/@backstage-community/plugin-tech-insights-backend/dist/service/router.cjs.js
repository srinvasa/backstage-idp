'use strict';

var express = require('express');
var Router = require('express-promise-router');
var pluginTechInsightsCommon = require('@backstage-community/plugin-tech-insights-common');
var luxon = require('luxon');
var catalogModel = require('@backstage/catalog-model');
var errors = require('@backstage/errors');
var rootHttpRouter = require('@backstage/backend-defaults/rootHttpRouter');
var pluginPermissionCommon = require('@backstage/plugin-permission-common');
var pLimit = require('p-limit');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var express__default = /*#__PURE__*/_interopDefaultCompat(express);
var Router__default = /*#__PURE__*/_interopDefaultCompat(Router);
var pLimit__default = /*#__PURE__*/_interopDefaultCompat(pLimit);

async function createRouter(options) {
  const router = Router__default.default();
  router.use(express__default.default.json());
  const {
    persistenceContext,
    factChecker,
    logger,
    config,
    permissions,
    httpAuth
  } = options;
  const { techInsightsStore } = persistenceContext;
  const factory = rootHttpRouter.MiddlewareFactory.create({ logger, config });
  const authorize = async (request, permission) => {
    const decision = (await permissions.authorize([{ permission }], {
      credentials: await httpAuth.credentials(request)
    }))[0];
    return decision;
  };
  if (factChecker) {
    logger.info("Fact checker configured. Enabling fact checking endpoints.");
    router.get("/checks", async (req, res) => {
      const decision = await authorize(req, pluginTechInsightsCommon.techInsightsCheckReadPermission);
      if (decision.result === pluginPermissionCommon.AuthorizeResult.DENY) {
        throw new errors.NotAllowedError("Unauthorized");
      }
      return res.json(await factChecker.getChecks());
    });
    router.post("/checks/run/:namespace/:kind/:name", async (req, res) => {
      const decision = await authorize(req, pluginTechInsightsCommon.techInsightsCheckUpdatePermission);
      if (decision.result === pluginPermissionCommon.AuthorizeResult.DENY) {
        throw new errors.NotAllowedError("Unauthorized");
      }
      const { namespace, kind, name } = req.params;
      const { checks } = req.body;
      const entityTriplet = catalogModel.stringifyEntityRef({ namespace, kind, name });
      const checkResult = await factChecker.runChecks(entityTriplet, checks);
      return res.json(checkResult);
    });
    const checksRunConcurrency = config.getOptionalNumber("techInsights.checksRunConcurrency") || 100;
    router.post("/checks/run", async (req, res) => {
      const decision = await authorize(req, pluginTechInsightsCommon.techInsightsCheckUpdatePermission);
      if (decision.result === pluginPermissionCommon.AuthorizeResult.DENY) {
        throw new errors.NotAllowedError("Unauthorized");
      }
      const checks = req.body.checks;
      let entities = req.body.entities;
      if (entities.length === 0) {
        entities = await techInsightsStore.getEntities();
      }
      const limit = pLimit__default.default(checksRunConcurrency);
      const tasks = entities.map(
        async (entity) => limit(async () => {
          const entityTriplet = typeof entity === "string" ? entity : catalogModel.stringifyEntityRef(entity);
          try {
            const results2 = await factChecker.runChecks(entityTriplet, checks);
            return {
              entity: entityTriplet,
              results: results2
            };
          } catch (e) {
            const error = errors.serializeError(e);
            logger.error(`${error.name}: ${error.message}`);
            return {
              entity: entityTriplet,
              error,
              results: []
            };
          }
        })
      );
      const results = await Promise.all(tasks);
      return res.json(results);
    });
  } else {
    logger.info(
      "Starting tech insights module without fact checking endpoints."
    );
  }
  router.get("/fact-schemas", async (req, res) => {
    const decision = await authorize(
      req,
      pluginTechInsightsCommon.techInsightsFactRetrieverReadPermission
    );
    if (decision.result === pluginPermissionCommon.AuthorizeResult.DENY) {
      throw new errors.NotAllowedError("Unauthorized");
    }
    const ids = req.query.ids;
    return res.json(await techInsightsStore.getLatestSchemas(ids));
  });
  router.get("/facts/latest", async (req, res) => {
    const decision = await authorize(
      req,
      pluginTechInsightsCommon.techInsightsFactRetrieverReadPermission
    );
    if (decision.result === pluginPermissionCommon.AuthorizeResult.DENY) {
      throw new errors.NotAllowedError("Unauthorized");
    }
    const { entity } = req.query;
    const { namespace, kind, name } = catalogModel.parseEntityRef(entity);
    if (!req.query.ids) {
      return res.status(422).json({ error: "Failed to parse ids from request" });
    }
    const ids = [req.query.ids].flat();
    return res.json(
      await techInsightsStore.getLatestFactsByIds(
        ids,
        catalogModel.stringifyEntityRef({ namespace, kind, name })
      )
    );
  });
  router.get("/facts/range", async (req, res) => {
    const decision = await authorize(
      req,
      pluginTechInsightsCommon.techInsightsFactRetrieverReadPermission
    );
    if (decision.result === pluginPermissionCommon.AuthorizeResult.DENY) {
      throw new errors.NotAllowedError("Unauthorized");
    }
    const { entity } = req.query;
    const { namespace, kind, name } = catalogModel.parseEntityRef(entity);
    if (!req.query.ids) {
      return res.status(422).json({ error: "Failed to parse ids from request" });
    }
    const ids = [req.query.ids].flat();
    const startDatetime = luxon.DateTime.fromISO(req.query.startDatetime);
    const endDatetime = luxon.DateTime.fromISO(req.query.endDatetime);
    if (!startDatetime.isValid || !endDatetime.isValid) {
      return res.status(422).json({
        message: "Failed to parse datetime from request",
        field: !startDatetime.isValid ? "startDateTime" : "endDateTime",
        value: !startDatetime.isValid ? startDatetime : endDatetime
      });
    }
    const entityTriplet = catalogModel.stringifyEntityRef({ namespace, kind, name });
    return res.json(
      await techInsightsStore.getFactsBetweenTimestampsByIds(
        ids,
        entityTriplet,
        startDatetime,
        endDatetime
      )
    );
  });
  router.use(factory.error());
  return router;
}

exports.createRouter = createRouter;
//# sourceMappingURL=router.cjs.js.map
