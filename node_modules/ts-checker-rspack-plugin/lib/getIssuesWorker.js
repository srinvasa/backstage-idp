"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.n = (module)=>{
        var getter = module && module.__esModule ? ()=>module['default'] : ()=>module;
        __webpack_require__.d(getter, {
            a: getter
        });
        return getter;
    };
})();
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
var __webpack_exports__ = {};
const external_process_namespaceObject = require("process");
var external_process_default = /*#__PURE__*/ __webpack_require__.n(external_process_namespaceObject);
function exposeRpc(fn) {
    const sendMessage = (message)=>new Promise((resolve, reject)=>{
            if (external_process_default().send) if (external_process_default().connected) external_process_default().send(message, void 0, void 0, (error)=>{
                if (error) reject(error);
                else resolve(void 0);
            });
            else reject(new Error(`Process ${external_process_default().pid} doesn't have open IPC channels`));
            else reject(new Error(`Process ${external_process_default().pid} doesn't have IPC channels`));
        });
    const handleMessage = async (message)=>{
        if ('call' === message.type) {
            if (!external_process_default().send) return;
            let value;
            let error;
            try {
                value = await fn(...message.args);
            } catch (fnError) {
                error = fnError;
            }
            try {
                if (error) await sendMessage({
                    type: 'reject',
                    id: message.id,
                    error
                });
                else await sendMessage({
                    type: 'resolve',
                    id: message.id,
                    value
                });
            } catch (sendError) {
                if (error) console.error(error);
                console.error(sendError);
            }
        }
    };
    external_process_default().on('message', handleMessage);
}
require("child_process");
const WORKER_DATA_ENV_KEY = 'WORKER_DATA';
function getRpcWorkerData() {
    return JSON.parse(external_process_namespaceObject.env[WORKER_DATA_ENV_KEY] || '{}');
}
const external_path_namespaceObject = require("path");
var external_path_default = /*#__PURE__*/ __webpack_require__.n(external_path_namespaceObject);
function forwardSlash(input) {
    return external_path_default().normalize(input).replace(/\\+/g, '/');
}
const external_os_namespaceObject = require("os");
function compareIssuePositions(positionA, positionB) {
    if (positionA === positionB) return 0;
    if (!positionA) return -1;
    if (!positionB) return 1;
    return Math.sign(positionA.line - positionB.line) || Math.sign(positionA.column - positionB.column);
}
function compareIssueLocations(locationA, locationB) {
    if (locationA === locationB) return 0;
    if (!locationA) return -1;
    if (!locationB) return 1;
    return compareIssuePositions(locationA.start, locationB.start) || compareIssuePositions(locationA.end, locationB.end);
}
function isIssueSeverity(value) {
    return [
        'error',
        'warning'
    ].includes(value);
}
function compareIssueSeverities(severityA, severityB) {
    const [priorityA, priorityB] = [
        severityA,
        severityB
    ].map((severity)=>[
            'warning',
            'error'
        ].indexOf(severity));
    return Math.sign(priorityB - priorityA);
}
function isIssue(value) {
    return !!value && 'object' == typeof value && isIssueSeverity(value.severity) && !!value.code && !!value.message;
}
function compareStrings(stringA, stringB) {
    if (stringA === stringB) return 0;
    if (null == stringA) return -1;
    if (null == stringB) return 1;
    return stringA.toString().localeCompare(stringB.toString());
}
function compareIssues(issueA, issueB) {
    return compareIssueSeverities(issueA.severity, issueB.severity) || compareStrings(issueA.file, issueB.file) || compareIssueLocations(issueA.location, issueB.location) || compareStrings(issueA.code, issueB.code) || compareStrings(issueA.message, issueB.message) || 0;
}
function equalsIssues(issueA, issueB) {
    return 0 === compareIssues(issueA, issueB);
}
function deduplicateAndSortIssues(issues) {
    const sortedIssues = issues.filter(isIssue).sort(compareIssues);
    return sortedIssues.filter((issue, index)=>0 === index || !equalsIssues(issue, sortedIssues[index - 1]));
}
const worker_config_config = getRpcWorkerData();
const typescript = require(worker_config_config.typescriptPath);
const diagnosticsPerConfigFile = new Map();
function updateDiagnostics(configFile, diagnostics) {
    diagnosticsPerConfigFile.set(configFile, diagnostics);
}
function getIssues() {
    const allDiagnostics = [];
    diagnosticsPerConfigFile.forEach((diagnostics)=>{
        allDiagnostics.push(...diagnostics);
    });
    return createIssuesFromDiagnostics(allDiagnostics);
}
function invalidateDiagnostics() {
    diagnosticsPerConfigFile.clear();
}
function getDiagnosticsOfProgram(program) {
    const programDiagnostics = [];
    try {
        if (worker_config_config.diagnosticOptions.syntactic) programDiagnostics.push(...program.getSyntacticDiagnostics());
        if (worker_config_config.diagnosticOptions.global) programDiagnostics.push(...program.getGlobalDiagnostics());
        if (worker_config_config.diagnosticOptions.semantic) programDiagnostics.push(...program.getSemanticDiagnostics());
        if (worker_config_config.diagnosticOptions.declaration) programDiagnostics.push(...program.getDeclarationDiagnostics());
    } catch (e) {
        if (e instanceof Error) programDiagnostics.push({
            code: 1,
            category: 1,
            messageText: `TSC compiler crashed: ${e.message}
${e.stack}`,
            file: void 0,
            start: void 0,
            length: void 0
        });
    }
    return programDiagnostics;
}
function createIssueFromDiagnostic(diagnostic) {
    let file;
    let location;
    if (diagnostic.file) {
        file = diagnostic.file.fileName;
        if (diagnostic.start && diagnostic.length) {
            const { line: startLine, character: startCharacter } = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start);
            const { line: endLine, character: endCharacter } = diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start + diagnostic.length);
            location = {
                start: {
                    line: startLine + 1,
                    column: startCharacter + 1
                },
                end: {
                    line: endLine + 1,
                    column: endCharacter + 1
                }
            };
        }
    }
    return {
        code: 'TS' + String(diagnostic.code),
        severity: 0 === diagnostic.category ? 'warning' : 'error',
        message: typescript.flattenDiagnosticMessageText(diagnostic.messageText, external_os_namespaceObject.EOL),
        file,
        location
    };
}
function createIssuesFromDiagnostics(diagnostics) {
    return deduplicateAndSortIssues(diagnostics.map((diagnostic)=>createIssueFromDiagnostic(diagnostic)));
}
const external_memfs_namespaceObject = require("memfs");
const external_node_fs_namespaceObject = require("node:fs");
var external_node_fs_default = /*#__PURE__*/ __webpack_require__.n(external_node_fs_namespaceObject);
const existsCache = new Map();
const readStatsCache = new Map();
const readFileCache = new Map();
const readDirCache = new Map();
const realPathCache = new Map();
const realFileSystem = {
    exists (path) {
        return exists(getRealPath(path));
    },
    readFile (path, encoding) {
        return readFile(getRealPath(path), encoding);
    },
    readDir (path) {
        return readDir(getRealPath(path));
    },
    readStats (path) {
        return readStats(getRealPath(path));
    },
    realPath (path) {
        return getRealPath(path);
    },
    normalizePath (path) {
        return (0, external_path_namespaceObject.normalize)(path);
    },
    writeFile (path, data) {
        writeFile(getRealPath(path), data);
    },
    deleteFile (path) {
        deleteFile(getRealPath(path));
    },
    createDir (path) {
        createDir(getRealPath(path));
    },
    updateTimes (path, atime, mtime) {
        updateTimes(getRealPath(path), atime, mtime);
    },
    clearCache () {
        existsCache.clear();
        readStatsCache.clear();
        readFileCache.clear();
        readDirCache.clear();
        realPathCache.clear();
    }
};
function exists(path) {
    const normalizedPath = (0, external_path_namespaceObject.normalize)(path);
    if (!existsCache.has(normalizedPath)) existsCache.set(normalizedPath, external_node_fs_default().existsSync(normalizedPath));
    return !!existsCache.get(normalizedPath);
}
function readStats(path) {
    const normalizedPath = (0, external_path_namespaceObject.normalize)(path);
    if (!readStatsCache.has(normalizedPath)) {
        if (exists(normalizedPath)) readStatsCache.set(normalizedPath, external_node_fs_default().statSync(normalizedPath));
    }
    return readStatsCache.get(normalizedPath);
}
function readFile(path, encoding) {
    const normalizedPath = (0, external_path_namespaceObject.normalize)(path);
    if (!readFileCache.has(normalizedPath)) {
        const stats = readStats(normalizedPath);
        if (stats && stats.isFile()) readFileCache.set(normalizedPath, external_node_fs_default().readFileSync(normalizedPath, {
            encoding: encoding
        }).toString());
        else readFileCache.set(normalizedPath, void 0);
    }
    return readFileCache.get(normalizedPath);
}
function readDir(path) {
    const normalizedPath = (0, external_path_namespaceObject.normalize)(path);
    if (!readDirCache.has(normalizedPath)) {
        const stats = readStats(normalizedPath);
        if (stats && stats.isDirectory()) readDirCache.set(normalizedPath, external_node_fs_default().readdirSync(normalizedPath, {
            withFileTypes: true
        }));
        else readDirCache.set(normalizedPath, []);
    }
    return readDirCache.get(normalizedPath) || [];
}
function getRealPath(path) {
    const normalizedPath = (0, external_path_namespaceObject.normalize)(path);
    if (!realPathCache.has(normalizedPath)) {
        let base = normalizedPath;
        let nested = '';
        while(base !== (0, external_path_namespaceObject.dirname)(base)){
            if (exists(base)) {
                realPathCache.set(normalizedPath, (0, external_path_namespaceObject.normalize)((0, external_path_namespaceObject.join)(external_node_fs_default().realpathSync(base), nested)));
                break;
            }
            nested = (0, external_path_namespaceObject.join)((0, external_path_namespaceObject.basename)(base), nested);
            base = (0, external_path_namespaceObject.dirname)(base);
        }
    }
    return realPathCache.get(normalizedPath) || normalizedPath;
}
function createDir(path) {
    const normalizedPath = (0, external_path_namespaceObject.normalize)(path);
    external_node_fs_default().mkdirSync(normalizedPath, {
        recursive: true
    });
    existsCache.set(normalizedPath, true);
    if (readDirCache.has((0, external_path_namespaceObject.dirname)(normalizedPath))) readDirCache.delete((0, external_path_namespaceObject.dirname)(normalizedPath));
    if (readStatsCache.has(normalizedPath)) readStatsCache.delete(normalizedPath);
}
function writeFile(path, data) {
    const normalizedPath = (0, external_path_namespaceObject.normalize)(path);
    if (!exists((0, external_path_namespaceObject.dirname)(normalizedPath))) createDir((0, external_path_namespaceObject.dirname)(normalizedPath));
    external_node_fs_default().writeFileSync(normalizedPath, data);
    existsCache.set(normalizedPath, true);
    if (readDirCache.has((0, external_path_namespaceObject.dirname)(normalizedPath))) readDirCache.delete((0, external_path_namespaceObject.dirname)(normalizedPath));
    if (readStatsCache.has(normalizedPath)) readStatsCache.delete(normalizedPath);
    if (readFileCache.has(normalizedPath)) readFileCache.delete(normalizedPath);
}
function deleteFile(path) {
    if (exists(path)) {
        const normalizedPath = (0, external_path_namespaceObject.normalize)(path);
        external_node_fs_default().unlinkSync(normalizedPath);
        existsCache.set(normalizedPath, false);
        if (readDirCache.has((0, external_path_namespaceObject.dirname)(normalizedPath))) readDirCache.delete((0, external_path_namespaceObject.dirname)(normalizedPath));
        if (readStatsCache.has(normalizedPath)) readStatsCache.delete(normalizedPath);
        if (readFileCache.has(normalizedPath)) readFileCache.delete(normalizedPath);
    }
}
function updateTimes(path, atime, mtime) {
    if (exists(path)) {
        const normalizedPath = (0, external_path_namespaceObject.normalize)(path);
        external_node_fs_default().utimesSync((0, external_path_namespaceObject.normalize)(path), atime, mtime);
        if (readStatsCache.has(normalizedPath)) readStatsCache.delete(normalizedPath);
    }
}
const memFileSystem = {
    ...realFileSystem,
    exists (path) {
        return mem_file_system_exists(realFileSystem.realPath(path));
    },
    readFile (path, encoding) {
        return mem_file_system_readFile(realFileSystem.realPath(path), encoding);
    },
    readDir (path) {
        return mem_file_system_readDir(realFileSystem.realPath(path));
    },
    readStats (path) {
        return mem_file_system_readStats(realFileSystem.realPath(path));
    },
    writeFile (path, data) {
        mem_file_system_writeFile(realFileSystem.realPath(path), data);
    },
    deleteFile (path) {
        mem_file_system_deleteFile(realFileSystem.realPath(path));
    },
    createDir (path) {
        mem_file_system_createDir(realFileSystem.realPath(path));
    },
    updateTimes (path, atime, mtime) {
        mem_file_system_updateTimes(realFileSystem.realPath(path), atime, mtime);
    },
    clearCache () {
        realFileSystem.clearCache();
    }
};
function mem_file_system_exists(path) {
    return external_memfs_namespaceObject.fs.existsSync(realFileSystem.normalizePath(path));
}
function mem_file_system_readStats(path) {
    return mem_file_system_exists(path) ? external_memfs_namespaceObject.fs.statSync(realFileSystem.normalizePath(path)) : void 0;
}
function mem_file_system_readFile(path, encoding) {
    const stats = mem_file_system_readStats(path);
    if (stats && stats.isFile()) return external_memfs_namespaceObject.fs.readFileSync(realFileSystem.normalizePath(path), {
        encoding: encoding
    }).toString();
}
function mem_file_system_readDir(path) {
    const stats = mem_file_system_readStats(path);
    if (stats && stats.isDirectory()) return external_memfs_namespaceObject.fs.readdirSync(realFileSystem.normalizePath(path), {
        withFileTypes: true
    });
    return [];
}
function mem_file_system_createDir(path) {
    external_memfs_namespaceObject.fs.mkdirSync(realFileSystem.normalizePath(path), {
        recursive: true
    });
}
function mem_file_system_writeFile(path, data) {
    if (!mem_file_system_exists((0, external_path_namespaceObject.dirname)(path))) mem_file_system_createDir((0, external_path_namespaceObject.dirname)(path));
    external_memfs_namespaceObject.fs.writeFileSync(realFileSystem.normalizePath(path), data);
}
function mem_file_system_deleteFile(path) {
    if (mem_file_system_exists(path)) external_memfs_namespaceObject.fs.unlinkSync(realFileSystem.normalizePath(path));
}
function mem_file_system_updateTimes(path, atime, mtime) {
    if (mem_file_system_exists(path)) external_memfs_namespaceObject.fs.utimesSync(realFileSystem.normalizePath(path), atime, mtime);
}
const passiveFileSystem = {
    ...memFileSystem,
    exists (path) {
        return passive_file_system_exists(realFileSystem.realPath(path));
    },
    readFile (path, encoding) {
        return passive_file_system_readFile(realFileSystem.realPath(path), encoding);
    },
    readDir (path) {
        return passive_file_system_readDir(realFileSystem.realPath(path));
    },
    readStats (path) {
        return passive_file_system_readStats(realFileSystem.realPath(path));
    },
    realPath (path) {
        return realFileSystem.realPath(path);
    },
    clearCache () {
        realFileSystem.clearCache();
    }
};
function passive_file_system_exists(path) {
    return realFileSystem.exists(path) || memFileSystem.exists(path);
}
function passive_file_system_readFile(path, encoding) {
    const fsStats = realFileSystem.readStats(path);
    const memStats = memFileSystem.readStats(path);
    if (fsStats && memStats) return fsStats.mtimeMs > memStats.mtimeMs ? realFileSystem.readFile(path, encoding) : memFileSystem.readFile(path, encoding);
    if (fsStats) return realFileSystem.readFile(path, encoding);
    if (memStats) return memFileSystem.readFile(path, encoding);
}
function passive_file_system_readDir(path) {
    const fsDirents = realFileSystem.readDir(path);
    const memDirents = memFileSystem.readDir(path);
    return fsDirents.filter((fsDirent)=>!memDirents.some((memDirent)=>memDirent.name === fsDirent.name)).concat(memDirents);
}
function passive_file_system_readStats(path) {
    const fsStats = realFileSystem.readStats(path);
    const memStats = memFileSystem.readStats(path);
    if (fsStats && memStats) return fsStats.mtimeMs > memStats.mtimeMs ? fsStats : memStats;
    if (fsStats) return fsStats;
    if (memStats) return memStats;
}
const mode = worker_config_config.mode;
let artifacts = {
    files: [],
    dirs: [],
    excluded: [],
    extensions: []
};
let isInitialRun = true;
const fileWatcherCallbacksMap = new Map();
const directoryWatcherCallbacksMap = new Map();
const recursiveDirectoryWatcherCallbacksMap = new Map();
const system_deletedFiles = new Map();
const timeoutCallbacks = new Set();
const ignoredPaths = [
    '/node_modules/.',
    '/.git',
    '/.#'
];
const system = {
    ...typescript.sys,
    useCaseSensitiveFileNames: true,
    realpath (path) {
        return getReadFileSystem(path).realPath(path);
    },
    fileExists (path) {
        const stats = getReadFileSystem(path).readStats(path);
        return !!stats && stats.isFile();
    },
    readFile (path, encoding) {
        return getReadFileSystem(path).readFile(path, encoding);
    },
    getFileSize (path) {
        const stats = getReadFileSystem(path).readStats(path);
        return stats ? stats.size : 0;
    },
    writeFile (path, data) {
        getWriteFileSystem(path).writeFile(path, data);
        system.invokeFileChanged(path);
    },
    deleteFile (path) {
        getWriteFileSystem(path).deleteFile(path);
        system.invokeFileDeleted(path);
    },
    directoryExists (path) {
        return Boolean(getReadFileSystem(path).readStats(path)?.isDirectory());
    },
    createDirectory (path) {
        getWriteFileSystem(path).createDir(path);
        invokeDirectoryWatchers(path);
    },
    getDirectories (path) {
        const dirents = getReadFileSystem(path).readDir(path);
        return dirents.filter((dirent)=>dirent.isDirectory() || dirent.isSymbolicLink() && system.directoryExists((0, external_path_namespaceObject.join)(path, dirent.name))).map((dirent)=>dirent.name);
    },
    getModifiedTime (path) {
        if (void 0 === path) return;
        const stats = getReadFileSystem(path).readStats(path);
        if (stats) return stats.mtime;
    },
    setModifiedTime (path, date) {
        getWriteFileSystem(path).updateTimes(path, date, date);
        invokeDirectoryWatchers(path);
        invokeFileWatchers(path, typescript.FileWatcherEventKind.Changed);
    },
    watchFile (path, callback) {
        return createWatcher(fileWatcherCallbacksMap, path, callback);
    },
    watchDirectory (path, callback, recursive = false) {
        return createWatcher(recursive ? recursiveDirectoryWatcherCallbacksMap : directoryWatcherCallbacksMap, path, callback);
    },
    setTimeout: (callback, timeout, ...args)=>{
        const timeoutId = setImmediate(()=>{
            callback(...args);
            timeoutCallbacks.delete(timeoutId);
        });
        timeoutCallbacks.add(timeoutId);
        return timeoutId;
    },
    clearTimeout: (timeoutId)=>{
        clearImmediate(timeoutId);
        timeoutCallbacks.delete(timeoutId);
    },
    async waitForQueued () {
        while(timeoutCallbacks.size > 0)await new Promise((resolve)=>setImmediate(resolve));
        isInitialRun = false;
    },
    invokeFileCreated (path) {
        const normalizedPath = normalizeAndResolvePath(path);
        invokeFileWatchers(path, typescript.FileWatcherEventKind.Created);
        invokeDirectoryWatchers(normalizedPath);
        system_deletedFiles.set(normalizedPath, false);
    },
    invokeFileChanged (path) {
        const normalizedPath = normalizeAndResolvePath(path);
        if (system_deletedFiles.get(normalizedPath) || !fileWatcherCallbacksMap.has(normalizedPath)) {
            invokeFileWatchers(path, typescript.FileWatcherEventKind.Created);
            invokeDirectoryWatchers(normalizedPath);
            system_deletedFiles.set(normalizedPath, false);
        } else invokeFileWatchers(path, typescript.FileWatcherEventKind.Changed);
    },
    invokeFileDeleted (path) {
        const normalizedPath = normalizeAndResolvePath(path);
        if (!system_deletedFiles.get(normalizedPath)) {
            invokeFileWatchers(path, typescript.FileWatcherEventKind.Deleted);
            invokeDirectoryWatchers(path);
            system_deletedFiles.set(normalizedPath, true);
        }
    },
    invalidateCache () {
        realFileSystem.clearCache();
        memFileSystem.clearCache();
        passiveFileSystem.clearCache();
    },
    setArtifacts (nextArtifacts) {
        artifacts = nextArtifacts;
    }
};
function createWatcher(watchersMap, path, callback) {
    const normalizedPath = normalizeAndResolvePath(path);
    const watchers = watchersMap.get(normalizedPath) || [];
    const nextWatchers = [
        ...watchers,
        callback
    ];
    watchersMap.set(normalizedPath, nextWatchers);
    return {
        close: ()=>{
            const watchers = watchersMap.get(normalizedPath) || [];
            const nextWatchers = watchers.filter((watcher)=>watcher !== callback);
            if (nextWatchers.length > 0) watchersMap.set(normalizedPath, nextWatchers);
            else watchersMap.delete(normalizedPath);
        }
    };
}
function invokeFileWatchers(path, event) {
    const normalizedPath = normalizeAndResolvePath(path);
    if (normalizedPath.endsWith('.js')) invokeFileWatchers(normalizedPath.slice(0, -3) + '.d.ts', event);
    const fileWatcherCallbacks = fileWatcherCallbacksMap.get(normalizedPath);
    if (fileWatcherCallbacks) fileWatcherCallbacks.forEach((fileWatcherCallback)=>fileWatcherCallback(forwardSlash(normalizedPath), event));
}
function invokeDirectoryWatchers(path) {
    const normalizedPath = normalizeAndResolvePath(path);
    const directory = (0, external_path_namespaceObject.dirname)(normalizedPath);
    if (ignoredPaths.some((ignoredPath)=>forwardSlash(normalizedPath).includes(ignoredPath))) return;
    const directoryWatcherCallbacks = directoryWatcherCallbacksMap.get(directory);
    if (directoryWatcherCallbacks) directoryWatcherCallbacks.forEach((directoryWatcherCallback)=>directoryWatcherCallback(forwardSlash(normalizedPath)));
    recursiveDirectoryWatcherCallbacksMap.forEach((recursiveDirectoryWatcherCallbacks, watchedDirectory)=>{
        if (watchedDirectory === directory || directory.startsWith(watchedDirectory) && '/' === forwardSlash(directory)[watchedDirectory.length]) recursiveDirectoryWatcherCallbacks.forEach((recursiveDirectoryWatcherCallback)=>recursiveDirectoryWatcherCallback(forwardSlash(normalizedPath)));
    });
}
function normalizeAndResolvePath(path) {
    let normalizedPath = realFileSystem.normalizePath(path);
    try {
        normalizedPath = realFileSystem.realPath(normalizedPath);
    } catch (error) {}
    return normalizedPath;
}
function isArtifact(path) {
    return (artifacts.dirs.some((dir)=>path.includes(dir)) || artifacts.files.some((file)=>path === file)) && artifacts.extensions.some((extension)=>path.endsWith(extension));
}
function getReadFileSystem(path) {
    if (('readonly' === mode || 'write-tsbuildinfo' === mode) && isArtifact(path)) {
        if (isInitialRun && !memFileSystem.exists(path) && passiveFileSystem.exists(path)) {
            const stats = passiveFileSystem.readStats(path);
            if (stats?.isFile()) {
                const content = passiveFileSystem.readFile(path);
                if (content) {
                    memFileSystem.writeFile(path, content);
                    memFileSystem.updateTimes(path, stats.atime, stats.mtime);
                }
            }
            return memFileSystem;
        }
    }
    return passiveFileSystem;
}
function getWriteFileSystem(path) {
    if ('write-references' === mode || 'write-tsbuildinfo' === mode && path.endsWith('.tsbuildinfo') || 'write-dts' === mode && [
        '.tsbuildinfo',
        '.d.ts',
        '.d.ts.map'
    ].some((suffix)=>path.endsWith(suffix))) return realFileSystem;
    return passiveFileSystem;
}
let config_parsedConfig;
let parseConfigDiagnostics = [];
const parseConfigFileHost = {
    ...system,
    onUnRecoverableConfigFileDiagnostic: (diagnostic)=>{
        parseConfigDiagnostics.push(diagnostic);
    }
};
function getUserProvidedConfigOverwrite() {
    return worker_config_config.configOverwrite || {};
}
function getImplicitConfigOverwrite() {
    const baseCompilerOptionsOverwrite = {
        skipLibCheck: true,
        sourceMap: false,
        inlineSourceMap: false
    };
    switch(worker_config_config.mode){
        case 'write-dts':
            return {
                compilerOptions: {
                    ...baseCompilerOptionsOverwrite,
                    declaration: true,
                    emitDeclarationOnly: true,
                    noEmit: false
                }
            };
        case 'write-tsbuildinfo':
        case 'write-references':
            return {
                compilerOptions: {
                    ...baseCompilerOptionsOverwrite,
                    declaration: true,
                    emitDeclarationOnly: false,
                    noEmit: false
                }
            };
    }
    return {
        compilerOptions: baseCompilerOptionsOverwrite
    };
}
function applyConfigOverwrite(baseConfig, ...overwriteConfigs) {
    let config = baseConfig;
    for (const overwriteConfig of overwriteConfigs)config = {
        ...config || {},
        ...overwriteConfig || {},
        compilerOptions: {
            ...config?.compilerOptions || {},
            ...overwriteConfig?.compilerOptions || {}
        }
    };
    return config;
}
function parseConfig(configFileName, configFileContext) {
    const configFilePath = forwardSlash(configFileName);
    const { config: baseConfig, error: readConfigError } = typescript.readConfigFile(configFilePath, parseConfigFileHost.readFile);
    const overwrittenConfig = applyConfigOverwrite(baseConfig || {}, getImplicitConfigOverwrite(), getUserProvidedConfigOverwrite());
    const parsedConfigFile = typescript.parseJsonConfigFileContent(overwrittenConfig, parseConfigFileHost, configFileContext);
    return {
        ...parsedConfigFile,
        options: {
            ...parsedConfigFile.options,
            configFilePath: configFilePath
        },
        errors: readConfigError ? [
            readConfigError
        ] : parsedConfigFile.errors
    };
}
function getParseConfigIssues() {
    const issues = createIssuesFromDiagnostics(parseConfigDiagnostics);
    issues.forEach((issue)=>{
        if (!issue.file) issue.file = worker_config_config.configFile;
    });
    return issues;
}
function getParsedConfig(force = false) {
    if (!config_parsedConfig || force) {
        config_parsedConfig = parseConfig(worker_config_config.configFile, worker_config_config.context);
        parseConfigDiagnostics = config_parsedConfig.errors || [];
    }
    return config_parsedConfig;
}
function parseNextConfig() {
    const prevParsedConfig = config_parsedConfig;
    const nextParsedConfig = getParsedConfig(true);
    return [
        prevParsedConfig,
        nextParsedConfig
    ];
}
function invalidateConfig() {
    config_parsedConfig = void 0;
    parseConfigDiagnostics = [];
}
function getConfigFilePathFromCompilerOptions(compilerOptions) {
    return compilerOptions.configFilePath;
}
function getConfigFilePathFromProgram(program) {
    return getConfigFilePathFromCompilerOptions(program.getCompilerOptions());
}
function getConfigFilePathFromBuilderProgram(builderProgram) {
    return getConfigFilePathFromCompilerOptions(builderProgram.getProgram().getCompilerOptions());
}
function didConfigFileChanged({ changedFiles = [], deletedFiles = [] }) {
    return [
        ...changedFiles,
        ...deletedFiles
    ].map((file)=>external_path_namespaceObject.normalize(file)).includes(external_path_namespaceObject.normalize(worker_config_config.configFile));
}
function didDependenciesProbablyChanged(dependencies, { changedFiles = [], deletedFiles = [] }) {
    const didSomeDependencyHasBeenAdded = changedFiles.some((changeFile)=>!dependencies.files.includes(changeFile));
    const didSomeDependencyHasBeenDeleted = deletedFiles.some((deletedFile)=>dependencies.files.includes(deletedFile));
    return didSomeDependencyHasBeenAdded || didSomeDependencyHasBeenDeleted;
}
function didRootFilesChanged() {
    const [prevConfig, nextConfig] = parseNextConfig();
    return prevConfig && JSON.stringify(prevConfig.fileNames) !== JSON.stringify(nextConfig.fileNames);
}
function invalidateTsBuildInfo() {
    const parsedConfig = getParsedConfig();
    if ('function' == typeof typescript.getTsBuildInfoEmitOutputFilePath && 'readonly' !== worker_config_config.mode && parsedConfig.options.incremental) {
        const tsBuildInfoPath = typescript.getTsBuildInfoEmitOutputFilePath(parsedConfig.options);
        if (tsBuildInfoPath) try {
            system.deleteFile(tsBuildInfoPath);
        } catch (error) {}
    }
}
function emitTsBuildInfoIfNeeded(builderProgram) {
    const parsedConfig = getParsedConfig();
    if ('readonly' !== worker_config_config.mode && parsedConfig && isIncrementalEnabled(parsedConfig.options)) {
        const program = builderProgram.getProgram();
        if ('function' == typeof program.emitBuildInfo) program.emitBuildInfo();
    }
}
function getTsBuildInfoEmitPath(compilerOptions) {
    if ('function' == typeof typescript.getTsBuildInfoEmitOutputFilePath) return typescript.getTsBuildInfoEmitOutputFilePath(compilerOptions);
    const removeJsonExtension = (filePath)=>filePath.endsWith('.json') ? filePath.slice(0, -5) : filePath;
    const configFile = compilerOptions.configFilePath;
    if (!isIncrementalEnabled(compilerOptions)) return;
    if (compilerOptions.tsBuildInfoFile) return compilerOptions.tsBuildInfoFile;
    const outPath = compilerOptions.outFile || compilerOptions.out;
    let buildInfoExtensionLess;
    if (outPath) buildInfoExtensionLess = removeJsonExtension(outPath);
    else {
        if (!configFile) return;
        const configFileExtensionLess = removeJsonExtension(configFile);
        buildInfoExtensionLess = compilerOptions.outDir ? compilerOptions.rootDir ? external_path_namespaceObject.resolve(compilerOptions.outDir, external_path_namespaceObject.relative(compilerOptions.rootDir, configFileExtensionLess)) : external_path_namespaceObject.resolve(compilerOptions.outDir, external_path_namespaceObject.basename(configFileExtensionLess)) : configFileExtensionLess;
    }
    return buildInfoExtensionLess + '.tsbuildinfo';
}
function isIncrementalEnabled(compilerOptions) {
    return Boolean((compilerOptions.incremental || compilerOptions.composite) && !compilerOptions.outFile);
}
let artifacts_artifacts;
function getArtifacts(force = false) {
    if (!artifacts_artifacts || force) {
        const parsedConfig = getParsedConfig();
        artifacts_artifacts = getArtifactsWorker(parsedConfig, worker_config_config.context);
    }
    return artifacts_artifacts;
}
function invalidateArtifacts() {
    artifacts_artifacts = void 0;
}
function registerArtifacts() {
    system.setArtifacts(getArtifacts());
}
function getArtifactsWorker(parsedConfig, configFileContext, processedConfigFiles = []) {
    const files = new Set();
    const dirs = new Set();
    if (parsedConfig.fileNames.length > 0) {
        if (parsedConfig.options.outFile) files.add(external_path_namespaceObject.resolve(configFileContext, parsedConfig.options.outFile));
        const tsBuildInfoPath = getTsBuildInfoEmitPath(parsedConfig.options);
        if (tsBuildInfoPath) files.add(external_path_namespaceObject.resolve(configFileContext, tsBuildInfoPath));
        if (parsedConfig.options.outDir) dirs.add(external_path_namespaceObject.resolve(configFileContext, parsedConfig.options.outDir));
    }
    for (const projectReference of parsedConfig.projectReferences || []){
        const configFile = typescript.resolveProjectReferencePath(projectReference);
        if (processedConfigFiles.includes(configFile)) continue;
        const parsedConfig = parseConfig(configFile, external_path_namespaceObject.dirname(configFile));
        const childArtifacts = getArtifactsWorker(parsedConfig, configFileContext, [
            ...processedConfigFiles,
            configFile
        ]);
        childArtifacts.files.forEach((file)=>{
            files.add(file);
        });
        childArtifacts.dirs.forEach((dir)=>{
            dirs.add(dir);
        });
    }
    const extensions = [
        typescript.Extension.Dts,
        typescript.Extension.Js,
        typescript.Extension.TsBuildInfo
    ];
    return {
        files: Array.from(files).map((file)=>external_path_namespaceObject.normalize(file)),
        dirs: Array.from(dirs).map((dir)=>external_path_namespaceObject.normalize(dir)),
        excluded: [],
        extensions
    };
}
let dependencies_dependencies;
function getDependencies(force = false) {
    if (!dependencies_dependencies || force) {
        const parsedConfig = getParsedConfig();
        dependencies_dependencies = getDependenciesWorker(parsedConfig, worker_config_config.context);
    }
    return dependencies_dependencies;
}
function invalidateDependencies() {
    dependencies_dependencies = void 0;
}
function getDependenciesWorker(parsedConfig, configFileContext, processedConfigFiles = []) {
    const files = new Set(parsedConfig.fileNames);
    const configFilePath = parsedConfig.options.configFilePath;
    if ('string' == typeof configFilePath) files.add(configFilePath);
    const dirs = new Set(Object.keys(parsedConfig.wildcardDirectories || {}));
    const excluded = new Set((parsedConfig.raw?.exclude || []).map((filePath)=>external_path_namespaceObject.resolve(configFileContext, filePath)));
    for (const projectReference of parsedConfig.projectReferences || []){
        const childConfigFilePath = typescript.resolveProjectReferencePath(projectReference);
        const childConfigContext = external_path_namespaceObject.dirname(childConfigFilePath);
        if (processedConfigFiles.includes(childConfigFilePath)) continue;
        const childParsedConfig = parseConfig(childConfigFilePath, childConfigContext);
        const childDependencies = getDependenciesWorker(childParsedConfig, childConfigContext, [
            ...processedConfigFiles,
            childConfigFilePath
        ]);
        childDependencies.files.forEach((file)=>{
            files.add(file);
        });
        childDependencies.dirs.forEach((dir)=>{
            dirs.add(dir);
        });
    }
    const extensions = [
        typescript.Extension.Ts,
        typescript.Extension.Tsx,
        typescript.Extension.Js,
        typescript.Extension.Jsx,
        typescript.Extension.TsBuildInfo
    ];
    return {
        files: Array.from(files).map((file)=>external_path_namespaceObject.normalize(file)),
        dirs: Array.from(dirs).map((dir)=>external_path_namespaceObject.normalize(dir)),
        excluded: Array.from(excluded).map((aPath)=>external_path_namespaceObject.normalize(aPath)),
        extensions: extensions
    };
}
const performance = typescript.performance;
function enablePerformanceIfNeeded() {
    if (worker_config_config.profile) performance?.enable?.();
}
function disablePerformanceIfNeeded() {
    if (worker_config_config.profile) performance?.disable?.();
}
function printPerformanceMeasuresIfNeeded() {
    if (worker_config_config.profile) {
        const measures = {};
        performance?.forEachMeasure?.((measureName, duration)=>{
            measures[measureName] = duration;
        });
        console.table(measures);
    }
}
function emitDtsIfNeeded(program) {
    const parsedConfig = getParsedConfig();
    if ('write-dts' === worker_config_config.mode && parsedConfig.options.declaration) program.emit(void 0, void 0, void 0, true);
}
function createCompilerHost(parsedConfig) {
    const baseCompilerHost = typescript.createCompilerHost(parsedConfig.options);
    return {
        ...baseCompilerHost,
        fileExists: system.fileExists,
        readFile: system.readFile,
        directoryExists: system.directoryExists,
        getDirectories: system.getDirectories,
        realpath: system.realpath
    };
}
const traceableTypescript = typescript;
function startTracingIfNeeded(compilerOptions) {
    if ('string' == typeof compilerOptions.generateTrace && 'function' == typeof traceableTypescript.startTracing) traceableTypescript.startTracing(worker_config_config.build ? 'build' : 'project', compilerOptions.generateTrace, getConfigFilePathFromCompilerOptions(compilerOptions));
}
function stopTracingIfNeeded(program) {
    const compilerOptions = program.getCompilerOptions();
    if ('string' == typeof compilerOptions.generateTrace && 'function' == typeof traceableTypescript.tracing?.stopTracing) traceableTypescript.tracing.stopTracing();
}
function dumpTracingLegendIfNeeded() {
    traceableTypescript.tracing?.dumpLegend();
}
let program_compilerHost;
let program_program;
function useProgram() {
    const parsedConfig = getParsedConfig();
    if (!program_compilerHost) program_compilerHost = createCompilerHost(parsedConfig);
    if (!program_program) {
        startTracingIfNeeded(parsedConfig.options);
        program_program = typescript.createProgram({
            rootNames: parsedConfig.fileNames,
            options: parsedConfig.options,
            projectReferences: parsedConfig.projectReferences,
            host: program_compilerHost
        });
    }
    updateDiagnostics(getConfigFilePathFromProgram(program_program), getDiagnosticsOfProgram(program_program));
    emitDtsIfNeeded(program_program);
    stopTracingIfNeeded(program_program);
}
function invalidateProgram(withHost = false) {
    if (withHost) program_compilerHost = void 0;
    program_program = void 0;
}
function createWatchCompilerHost(parsedConfig, createProgram, reportDiagnostic, reportWatchStatus, afterProgramCreate) {
    const baseWatchCompilerHost = typescript.createWatchCompilerHost(parsedConfig.fileNames, parsedConfig.options, system, createProgram, reportDiagnostic, reportWatchStatus, parsedConfig.projectReferences);
    return {
        ...baseWatchCompilerHost,
        createProgram (rootNames, options, compilerHost, oldProgram, configFileParsingDiagnostics, projectReferences) {
            return baseWatchCompilerHost.createProgram(rootNames, options, compilerHost, oldProgram, configFileParsingDiagnostics, projectReferences);
        },
        afterProgramCreate (program) {
            if (afterProgramCreate) afterProgramCreate(program);
        },
        onWatchStatusChange () {},
        watchFile: system.watchFile,
        watchDirectory: system.watchDirectory,
        setTimeout: system.setTimeout,
        clearTimeout: system.clearTimeout,
        fileExists: system.fileExists,
        readFile: system.readFile,
        directoryExists: system.directoryExists,
        getDirectories: system.getDirectories,
        realpath: system.realpath
    };
}
function createWatchSolutionBuilderHost(parsedConfig, createProgram, reportDiagnostic, reportWatchStatus, reportSolutionBuilderStatus, afterProgramCreate, afterProgramEmitAndDiagnostics) {
    const controlledWatchCompilerHost = createWatchCompilerHost(parsedConfig, createProgram, reportDiagnostic, reportWatchStatus, afterProgramCreate);
    return {
        ...controlledWatchCompilerHost,
        reportDiagnostic (diagnostic) {
            if (reportDiagnostic) reportDiagnostic(diagnostic);
        },
        reportSolutionBuilderStatus (diagnostic) {
            if (reportSolutionBuilderStatus) reportSolutionBuilderStatus(diagnostic);
        },
        afterProgramEmitAndDiagnostics (program) {
            if (afterProgramEmitAndDiagnostics) afterProgramEmitAndDiagnostics(program);
        },
        createDirectory (path) {
            system.createDirectory(path);
        },
        writeFile (path, data) {
            system.writeFile(path, data);
        },
        getModifiedTime (fileName) {
            return system.getModifiedTime(fileName);
        },
        setModifiedTime (fileName, date) {
            system.setModifiedTime(fileName, date);
        },
        deleteFile (fileName) {
            system.deleteFile(fileName);
        },
        getParsedCommandLine (fileName) {
            return typescript.getParsedCommandLineOfConfigFile(fileName, {
                skipLibCheck: true
            }, {
                ...system,
                onUnRecoverableConfigFileDiagnostic: (diagnostic)=>{
                    if (reportDiagnostic) reportDiagnostic(diagnostic);
                }
            });
        }
    };
}
let solutionBuilderHost;
let solutionBuilder;
function useSolutionBuilder() {
    if (!solutionBuilderHost) {
        const parsedConfig = getParsedConfig();
        solutionBuilderHost = createWatchSolutionBuilderHost(parsedConfig, (rootNames, compilerOptions, host, oldProgram, configFileParsingDiagnostics, projectReferences)=>{
            if (compilerOptions) startTracingIfNeeded(compilerOptions);
            return typescript.createSemanticDiagnosticsBuilderProgram(rootNames, compilerOptions, host, oldProgram, configFileParsingDiagnostics, projectReferences);
        }, void 0, void 0, void 0, void 0, (builderProgram)=>{
            updateDiagnostics(getConfigFilePathFromBuilderProgram(builderProgram), getDiagnosticsOfProgram(builderProgram));
            emitTsBuildInfoIfNeeded(builderProgram);
            stopTracingIfNeeded(builderProgram);
        });
    }
    if (!solutionBuilder) {
        solutionBuilder = typescript.createSolutionBuilderWithWatch(solutionBuilderHost, [
            worker_config_config.configFile
        ], {
            watch: true
        });
        solutionBuilder.build();
    }
}
function invalidateSolutionBuilder(withHost = false) {
    if (withHost) solutionBuilderHost = void 0;
    solutionBuilder = void 0;
}
let watchCompilerHost;
let watchProgram;
let shouldUpdateRootFiles = false;
function useWatchProgram() {
    if (!watchCompilerHost) {
        const parsedConfig = getParsedConfig();
        watchCompilerHost = createWatchCompilerHost(parsedConfig, (rootNames, compilerOptions, host, oldProgram, configFileParsingDiagnostics, projectReferences)=>{
            if (compilerOptions) startTracingIfNeeded(compilerOptions);
            return typescript.createSemanticDiagnosticsBuilderProgram(rootNames, compilerOptions, host, oldProgram, configFileParsingDiagnostics, projectReferences);
        }, void 0, void 0, (builderProgram)=>{
            updateDiagnostics(getConfigFilePathFromBuilderProgram(builderProgram), getDiagnosticsOfProgram(builderProgram));
            emitDtsIfNeeded(builderProgram);
            emitTsBuildInfoIfNeeded(builderProgram);
            stopTracingIfNeeded(builderProgram);
        });
        watchProgram = void 0;
    }
    if (!watchProgram) watchProgram = typescript.createWatchProgram(watchCompilerHost);
    if (shouldUpdateRootFiles) {
        watchProgram.updateRootFileNames(getDependencies().files);
        shouldUpdateRootFiles = false;
    }
}
function invalidateWatchProgram(withHost = false) {
    if (withHost) watchCompilerHost = void 0;
    watchProgram = void 0;
}
function invalidateWatchProgramRootFileNames() {
    shouldUpdateRootFiles = true;
}
const getIssuesWorker = async (change, watching)=>{
    system.invalidateCache();
    if (didConfigFileChanged(change)) {
        invalidateConfig();
        invalidateDependencies();
        invalidateArtifacts();
        invalidateDiagnostics();
        invalidateProgram(true);
        invalidateWatchProgram(true);
        invalidateSolutionBuilder(true);
        invalidateTsBuildInfo();
    } else if (didDependenciesProbablyChanged(getDependencies(), change)) {
        invalidateConfig();
        invalidateDependencies();
        invalidateArtifacts();
        if (didRootFilesChanged()) {
            invalidateWatchProgramRootFileNames();
            invalidateSolutionBuilder();
        }
    }
    registerArtifacts();
    enablePerformanceIfNeeded();
    const parseConfigIssues = getParseConfigIssues();
    if (parseConfigIssues.length) return parseConfigIssues;
    if (worker_config_config.build) useSolutionBuilder();
    else if (watching) useWatchProgram();
    else useProgram();
    change.changedFiles?.forEach((changedFile)=>{
        system?.invokeFileChanged(changedFile);
    });
    change.deletedFiles?.forEach((deletedFile)=>{
        system?.invokeFileDeleted(deletedFile);
    });
    await system.waitForQueued();
    const issues = getIssues();
    dumpTracingLegendIfNeeded();
    printPerformanceMeasuresIfNeeded();
    disablePerformanceIfNeeded();
    return issues;
};
exposeRpc(getIssuesWorker);
for(var __webpack_i__ in __webpack_exports__)exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});
