"use strict";
var __webpack_require__ = {};
(()=>{
    __webpack_require__.n = (module)=>{
        var getter = module && module.__esModule ? ()=>module['default'] : ()=>module;
        __webpack_require__.d(getter, {
            a: getter
        });
        return getter;
    };
})();
(()=>{
    __webpack_require__.d = (exports1, definition)=>{
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key)) Object.defineProperty(exports1, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
(()=>{
    __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);
})();
var __webpack_exports__ = {};
const external_process_namespaceObject = require("process");
var external_process_default = /*#__PURE__*/ __webpack_require__.n(external_process_namespaceObject);
function exposeRpc(fn) {
    const sendMessage = (message)=>new Promise((resolve, reject)=>{
            if (external_process_default().send) if (external_process_default().connected) external_process_default().send(message, void 0, void 0, (error)=>{
                if (error) reject(error);
                else resolve(void 0);
            });
            else reject(new Error(`Process ${external_process_default().pid} doesn't have open IPC channels`));
            else reject(new Error(`Process ${external_process_default().pid} doesn't have IPC channels`));
        });
    const handleMessage = async (message)=>{
        if ('call' === message.type) {
            if (!external_process_default().send) return;
            let value;
            let error;
            try {
                value = await fn(...message.args);
            } catch (fnError) {
                error = fnError;
            }
            try {
                if (error) await sendMessage({
                    type: 'reject',
                    id: message.id,
                    error
                });
                else await sendMessage({
                    type: 'resolve',
                    id: message.id,
                    value
                });
            } catch (sendError) {
                if (error) console.error(error);
                console.error(sendError);
            }
        }
    };
    external_process_default().on('message', handleMessage);
}
require("child_process");
const WORKER_DATA_ENV_KEY = 'WORKER_DATA';
function getRpcWorkerData() {
    return JSON.parse(external_process_namespaceObject.env[WORKER_DATA_ENV_KEY] || '{}');
}
const external_path_namespaceObject = require("path");
var external_path_default = /*#__PURE__*/ __webpack_require__.n(external_path_namespaceObject);
function forwardSlash(input) {
    return external_path_default().normalize(input).replace(/\\+/g, '/');
}
require("os");
const worker_config_config = getRpcWorkerData();
const typescript_typescript = require(worker_config_config.typescriptPath);
new Map();
const external_memfs_namespaceObject = require("memfs");
const external_node_fs_namespaceObject = require("node:fs");
var external_node_fs_default = /*#__PURE__*/ __webpack_require__.n(external_node_fs_namespaceObject);
const existsCache = new Map();
const readStatsCache = new Map();
const readFileCache = new Map();
const readDirCache = new Map();
const realPathCache = new Map();
const realFileSystem = {
    exists (path) {
        return exists(getRealPath(path));
    },
    readFile (path, encoding) {
        return readFile(getRealPath(path), encoding);
    },
    readDir (path) {
        return readDir(getRealPath(path));
    },
    readStats (path) {
        return readStats(getRealPath(path));
    },
    realPath (path) {
        return getRealPath(path);
    },
    normalizePath (path) {
        return (0, external_path_namespaceObject.normalize)(path);
    },
    writeFile (path, data) {
        writeFile(getRealPath(path), data);
    },
    deleteFile (path) {
        deleteFile(getRealPath(path));
    },
    createDir (path) {
        createDir(getRealPath(path));
    },
    updateTimes (path, atime, mtime) {
        updateTimes(getRealPath(path), atime, mtime);
    },
    clearCache () {
        existsCache.clear();
        readStatsCache.clear();
        readFileCache.clear();
        readDirCache.clear();
        realPathCache.clear();
    }
};
function exists(path) {
    const normalizedPath = (0, external_path_namespaceObject.normalize)(path);
    if (!existsCache.has(normalizedPath)) existsCache.set(normalizedPath, external_node_fs_default().existsSync(normalizedPath));
    return !!existsCache.get(normalizedPath);
}
function readStats(path) {
    const normalizedPath = (0, external_path_namespaceObject.normalize)(path);
    if (!readStatsCache.has(normalizedPath)) {
        if (exists(normalizedPath)) readStatsCache.set(normalizedPath, external_node_fs_default().statSync(normalizedPath));
    }
    return readStatsCache.get(normalizedPath);
}
function readFile(path, encoding) {
    const normalizedPath = (0, external_path_namespaceObject.normalize)(path);
    if (!readFileCache.has(normalizedPath)) {
        const stats = readStats(normalizedPath);
        if (stats && stats.isFile()) readFileCache.set(normalizedPath, external_node_fs_default().readFileSync(normalizedPath, {
            encoding: encoding
        }).toString());
        else readFileCache.set(normalizedPath, void 0);
    }
    return readFileCache.get(normalizedPath);
}
function readDir(path) {
    const normalizedPath = (0, external_path_namespaceObject.normalize)(path);
    if (!readDirCache.has(normalizedPath)) {
        const stats = readStats(normalizedPath);
        if (stats && stats.isDirectory()) readDirCache.set(normalizedPath, external_node_fs_default().readdirSync(normalizedPath, {
            withFileTypes: true
        }));
        else readDirCache.set(normalizedPath, []);
    }
    return readDirCache.get(normalizedPath) || [];
}
function getRealPath(path) {
    const normalizedPath = (0, external_path_namespaceObject.normalize)(path);
    if (!realPathCache.has(normalizedPath)) {
        let base = normalizedPath;
        let nested = '';
        while(base !== (0, external_path_namespaceObject.dirname)(base)){
            if (exists(base)) {
                realPathCache.set(normalizedPath, (0, external_path_namespaceObject.normalize)((0, external_path_namespaceObject.join)(external_node_fs_default().realpathSync(base), nested)));
                break;
            }
            nested = (0, external_path_namespaceObject.join)((0, external_path_namespaceObject.basename)(base), nested);
            base = (0, external_path_namespaceObject.dirname)(base);
        }
    }
    return realPathCache.get(normalizedPath) || normalizedPath;
}
function createDir(path) {
    const normalizedPath = (0, external_path_namespaceObject.normalize)(path);
    external_node_fs_default().mkdirSync(normalizedPath, {
        recursive: true
    });
    existsCache.set(normalizedPath, true);
    if (readDirCache.has((0, external_path_namespaceObject.dirname)(normalizedPath))) readDirCache.delete((0, external_path_namespaceObject.dirname)(normalizedPath));
    if (readStatsCache.has(normalizedPath)) readStatsCache.delete(normalizedPath);
}
function writeFile(path, data) {
    const normalizedPath = (0, external_path_namespaceObject.normalize)(path);
    if (!exists((0, external_path_namespaceObject.dirname)(normalizedPath))) createDir((0, external_path_namespaceObject.dirname)(normalizedPath));
    external_node_fs_default().writeFileSync(normalizedPath, data);
    existsCache.set(normalizedPath, true);
    if (readDirCache.has((0, external_path_namespaceObject.dirname)(normalizedPath))) readDirCache.delete((0, external_path_namespaceObject.dirname)(normalizedPath));
    if (readStatsCache.has(normalizedPath)) readStatsCache.delete(normalizedPath);
    if (readFileCache.has(normalizedPath)) readFileCache.delete(normalizedPath);
}
function deleteFile(path) {
    if (exists(path)) {
        const normalizedPath = (0, external_path_namespaceObject.normalize)(path);
        external_node_fs_default().unlinkSync(normalizedPath);
        existsCache.set(normalizedPath, false);
        if (readDirCache.has((0, external_path_namespaceObject.dirname)(normalizedPath))) readDirCache.delete((0, external_path_namespaceObject.dirname)(normalizedPath));
        if (readStatsCache.has(normalizedPath)) readStatsCache.delete(normalizedPath);
        if (readFileCache.has(normalizedPath)) readFileCache.delete(normalizedPath);
    }
}
function updateTimes(path, atime, mtime) {
    if (exists(path)) {
        const normalizedPath = (0, external_path_namespaceObject.normalize)(path);
        external_node_fs_default().utimesSync((0, external_path_namespaceObject.normalize)(path), atime, mtime);
        if (readStatsCache.has(normalizedPath)) readStatsCache.delete(normalizedPath);
    }
}
const memFileSystem = {
    ...realFileSystem,
    exists (path) {
        return mem_file_system_exists(realFileSystem.realPath(path));
    },
    readFile (path, encoding) {
        return mem_file_system_readFile(realFileSystem.realPath(path), encoding);
    },
    readDir (path) {
        return mem_file_system_readDir(realFileSystem.realPath(path));
    },
    readStats (path) {
        return mem_file_system_readStats(realFileSystem.realPath(path));
    },
    writeFile (path, data) {
        mem_file_system_writeFile(realFileSystem.realPath(path), data);
    },
    deleteFile (path) {
        mem_file_system_deleteFile(realFileSystem.realPath(path));
    },
    createDir (path) {
        mem_file_system_createDir(realFileSystem.realPath(path));
    },
    updateTimes (path, atime, mtime) {
        mem_file_system_updateTimes(realFileSystem.realPath(path), atime, mtime);
    },
    clearCache () {
        realFileSystem.clearCache();
    }
};
function mem_file_system_exists(path) {
    return external_memfs_namespaceObject.fs.existsSync(realFileSystem.normalizePath(path));
}
function mem_file_system_readStats(path) {
    return mem_file_system_exists(path) ? external_memfs_namespaceObject.fs.statSync(realFileSystem.normalizePath(path)) : void 0;
}
function mem_file_system_readFile(path, encoding) {
    const stats = mem_file_system_readStats(path);
    if (stats && stats.isFile()) return external_memfs_namespaceObject.fs.readFileSync(realFileSystem.normalizePath(path), {
        encoding: encoding
    }).toString();
}
function mem_file_system_readDir(path) {
    const stats = mem_file_system_readStats(path);
    if (stats && stats.isDirectory()) return external_memfs_namespaceObject.fs.readdirSync(realFileSystem.normalizePath(path), {
        withFileTypes: true
    });
    return [];
}
function mem_file_system_createDir(path) {
    external_memfs_namespaceObject.fs.mkdirSync(realFileSystem.normalizePath(path), {
        recursive: true
    });
}
function mem_file_system_writeFile(path, data) {
    if (!mem_file_system_exists((0, external_path_namespaceObject.dirname)(path))) mem_file_system_createDir((0, external_path_namespaceObject.dirname)(path));
    external_memfs_namespaceObject.fs.writeFileSync(realFileSystem.normalizePath(path), data);
}
function mem_file_system_deleteFile(path) {
    if (mem_file_system_exists(path)) external_memfs_namespaceObject.fs.unlinkSync(realFileSystem.normalizePath(path));
}
function mem_file_system_updateTimes(path, atime, mtime) {
    if (mem_file_system_exists(path)) external_memfs_namespaceObject.fs.utimesSync(realFileSystem.normalizePath(path), atime, mtime);
}
const passiveFileSystem = {
    ...memFileSystem,
    exists (path) {
        return passive_file_system_exists(realFileSystem.realPath(path));
    },
    readFile (path, encoding) {
        return passive_file_system_readFile(realFileSystem.realPath(path), encoding);
    },
    readDir (path) {
        return passive_file_system_readDir(realFileSystem.realPath(path));
    },
    readStats (path) {
        return passive_file_system_readStats(realFileSystem.realPath(path));
    },
    realPath (path) {
        return realFileSystem.realPath(path);
    },
    clearCache () {
        realFileSystem.clearCache();
    }
};
function passive_file_system_exists(path) {
    return realFileSystem.exists(path) || memFileSystem.exists(path);
}
function passive_file_system_readFile(path, encoding) {
    const fsStats = realFileSystem.readStats(path);
    const memStats = memFileSystem.readStats(path);
    if (fsStats && memStats) return fsStats.mtimeMs > memStats.mtimeMs ? realFileSystem.readFile(path, encoding) : memFileSystem.readFile(path, encoding);
    if (fsStats) return realFileSystem.readFile(path, encoding);
    if (memStats) return memFileSystem.readFile(path, encoding);
}
function passive_file_system_readDir(path) {
    const fsDirents = realFileSystem.readDir(path);
    const memDirents = memFileSystem.readDir(path);
    return fsDirents.filter((fsDirent)=>!memDirents.some((memDirent)=>memDirent.name === fsDirent.name)).concat(memDirents);
}
function passive_file_system_readStats(path) {
    const fsStats = realFileSystem.readStats(path);
    const memStats = memFileSystem.readStats(path);
    if (fsStats && memStats) return fsStats.mtimeMs > memStats.mtimeMs ? fsStats : memStats;
    if (fsStats) return fsStats;
    if (memStats) return memStats;
}
const mode = worker_config_config.mode;
let artifacts = {
    files: [],
    dirs: [],
    excluded: [],
    extensions: []
};
let isInitialRun = true;
const fileWatcherCallbacksMap = new Map();
const directoryWatcherCallbacksMap = new Map();
const recursiveDirectoryWatcherCallbacksMap = new Map();
const system_deletedFiles = new Map();
const timeoutCallbacks = new Set();
const ignoredPaths = [
    '/node_modules/.',
    '/.git',
    '/.#'
];
const system = {
    ...typescript_typescript.sys,
    useCaseSensitiveFileNames: true,
    realpath (path) {
        return getReadFileSystem(path).realPath(path);
    },
    fileExists (path) {
        const stats = getReadFileSystem(path).readStats(path);
        return !!stats && stats.isFile();
    },
    readFile (path, encoding) {
        return getReadFileSystem(path).readFile(path, encoding);
    },
    getFileSize (path) {
        const stats = getReadFileSystem(path).readStats(path);
        return stats ? stats.size : 0;
    },
    writeFile (path, data) {
        getWriteFileSystem(path).writeFile(path, data);
        system.invokeFileChanged(path);
    },
    deleteFile (path) {
        getWriteFileSystem(path).deleteFile(path);
        system.invokeFileDeleted(path);
    },
    directoryExists (path) {
        return Boolean(getReadFileSystem(path).readStats(path)?.isDirectory());
    },
    createDirectory (path) {
        getWriteFileSystem(path).createDir(path);
        invokeDirectoryWatchers(path);
    },
    getDirectories (path) {
        const dirents = getReadFileSystem(path).readDir(path);
        return dirents.filter((dirent)=>dirent.isDirectory() || dirent.isSymbolicLink() && system.directoryExists((0, external_path_namespaceObject.join)(path, dirent.name))).map((dirent)=>dirent.name);
    },
    getModifiedTime (path) {
        if (void 0 === path) return;
        const stats = getReadFileSystem(path).readStats(path);
        if (stats) return stats.mtime;
    },
    setModifiedTime (path, date) {
        getWriteFileSystem(path).updateTimes(path, date, date);
        invokeDirectoryWatchers(path);
        invokeFileWatchers(path, typescript_typescript.FileWatcherEventKind.Changed);
    },
    watchFile (path, callback) {
        return createWatcher(fileWatcherCallbacksMap, path, callback);
    },
    watchDirectory (path, callback, recursive = false) {
        return createWatcher(recursive ? recursiveDirectoryWatcherCallbacksMap : directoryWatcherCallbacksMap, path, callback);
    },
    setTimeout: (callback, timeout, ...args)=>{
        const timeoutId = setImmediate(()=>{
            callback(...args);
            timeoutCallbacks.delete(timeoutId);
        });
        timeoutCallbacks.add(timeoutId);
        return timeoutId;
    },
    clearTimeout: (timeoutId)=>{
        clearImmediate(timeoutId);
        timeoutCallbacks.delete(timeoutId);
    },
    async waitForQueued () {
        while(timeoutCallbacks.size > 0)await new Promise((resolve)=>setImmediate(resolve));
        isInitialRun = false;
    },
    invokeFileCreated (path) {
        const normalizedPath = normalizeAndResolvePath(path);
        invokeFileWatchers(path, typescript_typescript.FileWatcherEventKind.Created);
        invokeDirectoryWatchers(normalizedPath);
        system_deletedFiles.set(normalizedPath, false);
    },
    invokeFileChanged (path) {
        const normalizedPath = normalizeAndResolvePath(path);
        if (system_deletedFiles.get(normalizedPath) || !fileWatcherCallbacksMap.has(normalizedPath)) {
            invokeFileWatchers(path, typescript_typescript.FileWatcherEventKind.Created);
            invokeDirectoryWatchers(normalizedPath);
            system_deletedFiles.set(normalizedPath, false);
        } else invokeFileWatchers(path, typescript_typescript.FileWatcherEventKind.Changed);
    },
    invokeFileDeleted (path) {
        const normalizedPath = normalizeAndResolvePath(path);
        if (!system_deletedFiles.get(normalizedPath)) {
            invokeFileWatchers(path, typescript_typescript.FileWatcherEventKind.Deleted);
            invokeDirectoryWatchers(path);
            system_deletedFiles.set(normalizedPath, true);
        }
    },
    invalidateCache () {
        realFileSystem.clearCache();
        memFileSystem.clearCache();
        passiveFileSystem.clearCache();
    },
    setArtifacts (nextArtifacts) {
        artifacts = nextArtifacts;
    }
};
function createWatcher(watchersMap, path, callback) {
    const normalizedPath = normalizeAndResolvePath(path);
    const watchers = watchersMap.get(normalizedPath) || [];
    const nextWatchers = [
        ...watchers,
        callback
    ];
    watchersMap.set(normalizedPath, nextWatchers);
    return {
        close: ()=>{
            const watchers = watchersMap.get(normalizedPath) || [];
            const nextWatchers = watchers.filter((watcher)=>watcher !== callback);
            if (nextWatchers.length > 0) watchersMap.set(normalizedPath, nextWatchers);
            else watchersMap.delete(normalizedPath);
        }
    };
}
function invokeFileWatchers(path, event) {
    const normalizedPath = normalizeAndResolvePath(path);
    if (normalizedPath.endsWith('.js')) invokeFileWatchers(normalizedPath.slice(0, -3) + '.d.ts', event);
    const fileWatcherCallbacks = fileWatcherCallbacksMap.get(normalizedPath);
    if (fileWatcherCallbacks) fileWatcherCallbacks.forEach((fileWatcherCallback)=>fileWatcherCallback(forwardSlash(normalizedPath), event));
}
function invokeDirectoryWatchers(path) {
    const normalizedPath = normalizeAndResolvePath(path);
    const directory = (0, external_path_namespaceObject.dirname)(normalizedPath);
    if (ignoredPaths.some((ignoredPath)=>forwardSlash(normalizedPath).includes(ignoredPath))) return;
    const directoryWatcherCallbacks = directoryWatcherCallbacksMap.get(directory);
    if (directoryWatcherCallbacks) directoryWatcherCallbacks.forEach((directoryWatcherCallback)=>directoryWatcherCallback(forwardSlash(normalizedPath)));
    recursiveDirectoryWatcherCallbacksMap.forEach((recursiveDirectoryWatcherCallbacks, watchedDirectory)=>{
        if (watchedDirectory === directory || directory.startsWith(watchedDirectory) && '/' === forwardSlash(directory)[watchedDirectory.length]) recursiveDirectoryWatcherCallbacks.forEach((recursiveDirectoryWatcherCallback)=>recursiveDirectoryWatcherCallback(forwardSlash(normalizedPath)));
    });
}
function normalizeAndResolvePath(path) {
    let normalizedPath = realFileSystem.normalizePath(path);
    try {
        normalizedPath = realFileSystem.realPath(normalizedPath);
    } catch (error) {}
    return normalizedPath;
}
function isArtifact(path) {
    return (artifacts.dirs.some((dir)=>path.includes(dir)) || artifacts.files.some((file)=>path === file)) && artifacts.extensions.some((extension)=>path.endsWith(extension));
}
function getReadFileSystem(path) {
    if (('readonly' === mode || 'write-tsbuildinfo' === mode) && isArtifact(path)) {
        if (isInitialRun && !memFileSystem.exists(path) && passiveFileSystem.exists(path)) {
            const stats = passiveFileSystem.readStats(path);
            if (stats?.isFile()) {
                const content = passiveFileSystem.readFile(path);
                if (content) {
                    memFileSystem.writeFile(path, content);
                    memFileSystem.updateTimes(path, stats.atime, stats.mtime);
                }
            }
            return memFileSystem;
        }
    }
    return passiveFileSystem;
}
function getWriteFileSystem(path) {
    if ('write-references' === mode || 'write-tsbuildinfo' === mode && path.endsWith('.tsbuildinfo') || 'write-dts' === mode && [
        '.tsbuildinfo',
        '.d.ts',
        '.d.ts.map'
    ].some((suffix)=>path.endsWith(suffix))) return realFileSystem;
    return passiveFileSystem;
}
let config_parsedConfig;
let parseConfigDiagnostics = [];
const parseConfigFileHost = {
    ...system,
    onUnRecoverableConfigFileDiagnostic: (diagnostic)=>{
        parseConfigDiagnostics.push(diagnostic);
    }
};
function getUserProvidedConfigOverwrite() {
    return worker_config_config.configOverwrite || {};
}
function getImplicitConfigOverwrite() {
    const baseCompilerOptionsOverwrite = {
        skipLibCheck: true,
        sourceMap: false,
        inlineSourceMap: false
    };
    switch(worker_config_config.mode){
        case 'write-dts':
            return {
                compilerOptions: {
                    ...baseCompilerOptionsOverwrite,
                    declaration: true,
                    emitDeclarationOnly: true,
                    noEmit: false
                }
            };
        case 'write-tsbuildinfo':
        case 'write-references':
            return {
                compilerOptions: {
                    ...baseCompilerOptionsOverwrite,
                    declaration: true,
                    emitDeclarationOnly: false,
                    noEmit: false
                }
            };
    }
    return {
        compilerOptions: baseCompilerOptionsOverwrite
    };
}
function applyConfigOverwrite(baseConfig, ...overwriteConfigs) {
    let config = baseConfig;
    for (const overwriteConfig of overwriteConfigs)config = {
        ...config || {},
        ...overwriteConfig || {},
        compilerOptions: {
            ...config?.compilerOptions || {},
            ...overwriteConfig?.compilerOptions || {}
        }
    };
    return config;
}
function parseConfig(configFileName, configFileContext) {
    const configFilePath = forwardSlash(configFileName);
    const { config: baseConfig, error: readConfigError } = typescript_typescript.readConfigFile(configFilePath, parseConfigFileHost.readFile);
    const overwrittenConfig = applyConfigOverwrite(baseConfig || {}, getImplicitConfigOverwrite(), getUserProvidedConfigOverwrite());
    const parsedConfigFile = typescript_typescript.parseJsonConfigFileContent(overwrittenConfig, parseConfigFileHost, configFileContext);
    return {
        ...parsedConfigFile,
        options: {
            ...parsedConfigFile.options,
            configFilePath: configFilePath
        },
        errors: readConfigError ? [
            readConfigError
        ] : parsedConfigFile.errors
    };
}
function getParsedConfig(force = false) {
    if (!config_parsedConfig || force) {
        config_parsedConfig = parseConfig(worker_config_config.configFile, worker_config_config.context);
        parseConfigDiagnostics = config_parsedConfig.errors || [];
    }
    return config_parsedConfig;
}
function invalidateConfig() {
    config_parsedConfig = void 0;
    parseConfigDiagnostics = [];
}
function didConfigFileChanged({ changedFiles = [], deletedFiles = [] }) {
    return [
        ...changedFiles,
        ...deletedFiles
    ].map((file)=>external_path_namespaceObject.normalize(file)).includes(external_path_namespaceObject.normalize(worker_config_config.configFile));
}
function didDependenciesProbablyChanged(dependencies, { changedFiles = [], deletedFiles = [] }) {
    const didSomeDependencyHasBeenAdded = changedFiles.some((changeFile)=>!dependencies.files.includes(changeFile));
    const didSomeDependencyHasBeenDeleted = deletedFiles.some((deletedFile)=>dependencies.files.includes(deletedFile));
    return didSomeDependencyHasBeenAdded || didSomeDependencyHasBeenDeleted;
}
let dependencies_dependencies;
function getDependencies(force = false) {
    if (!dependencies_dependencies || force) {
        const parsedConfig = getParsedConfig();
        dependencies_dependencies = getDependenciesWorker(parsedConfig, worker_config_config.context);
    }
    return dependencies_dependencies;
}
function invalidateDependencies() {
    dependencies_dependencies = void 0;
}
function getDependenciesWorker(parsedConfig, configFileContext, processedConfigFiles = []) {
    const files = new Set(parsedConfig.fileNames);
    const configFilePath = parsedConfig.options.configFilePath;
    if ('string' == typeof configFilePath) files.add(configFilePath);
    const dirs = new Set(Object.keys(parsedConfig.wildcardDirectories || {}));
    const excluded = new Set((parsedConfig.raw?.exclude || []).map((filePath)=>external_path_namespaceObject.resolve(configFileContext, filePath)));
    for (const projectReference of parsedConfig.projectReferences || []){
        const childConfigFilePath = typescript_typescript.resolveProjectReferencePath(projectReference);
        const childConfigContext = external_path_namespaceObject.dirname(childConfigFilePath);
        if (processedConfigFiles.includes(childConfigFilePath)) continue;
        const childParsedConfig = parseConfig(childConfigFilePath, childConfigContext);
        const childDependencies = getDependenciesWorker(childParsedConfig, childConfigContext, [
            ...processedConfigFiles,
            childConfigFilePath
        ]);
        childDependencies.files.forEach((file)=>{
            files.add(file);
        });
        childDependencies.dirs.forEach((dir)=>{
            dirs.add(dir);
        });
    }
    const extensions = [
        typescript_typescript.Extension.Ts,
        typescript_typescript.Extension.Tsx,
        typescript_typescript.Extension.Js,
        typescript_typescript.Extension.Jsx,
        typescript_typescript.Extension.TsBuildInfo
    ];
    return {
        files: Array.from(files).map((file)=>external_path_namespaceObject.normalize(file)),
        dirs: Array.from(dirs).map((dir)=>external_path_namespaceObject.normalize(dir)),
        excluded: Array.from(excluded).map((aPath)=>external_path_namespaceObject.normalize(aPath)),
        extensions: extensions
    };
}
const get_dependencies_worker_getDependenciesWorker = (change)=>{
    system.invalidateCache();
    if (didConfigFileChanged(change) || didDependenciesProbablyChanged(getDependencies(), change)) {
        invalidateConfig();
        invalidateDependencies();
    }
    return getDependencies();
};
exposeRpc(get_dependencies_worker_getDependenciesWorker);
for(var __webpack_i__ in __webpack_exports__)exports[__webpack_i__] = __webpack_exports__[__webpack_i__];
Object.defineProperty(exports, '__esModule', {
    value: true
});
