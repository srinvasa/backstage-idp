import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import { useMemo, useState, isValidElement, useCallback } from 'react';
import { WidthProvider, Responsive } from 'react-grid-layout';
import { useElementFilter, getComponentData, useApi, storageApiRef } from '@backstage/core-plugin-api';
import 'react-grid-layout/css/styles.css';
import 'react-resizable/css/styles.css';
import Dialog from '@material-ui/core/Dialog';
import { makeStyles, createStyles, useTheme } from '@material-ui/core/styles';
import { compact } from 'lodash';
import useObservable from 'react-use/esm/useObservable';
import { Progress, ContentHeader, ErrorBoundary } from '@backstage/core-components';
import Typography from '@material-ui/core/Typography';
import { WidgetSettingsOverlay } from './WidgetSettingsOverlay.esm.js';
import { AddWidgetDialog } from './AddWidgetDialog.esm.js';
import { CustomHomepageButtons } from './CustomHomepageButtons.esm.js';
import { WidgetSchema, LayoutConfigurationSchema, CustomHomepageGridStateV1Schema } from './types.esm.js';
import { useTranslationRef } from '@backstage/frontend-plugin-api';
import { homeTranslationRef } from '../../translation.esm.js';

const ResponsiveGrid = WidthProvider(Responsive);
const useStyles = makeStyles(
  (theme) => createStyles({
    responsiveGrid: {
      "& .react-grid-item > .react-resizable-handle:after": {
        position: "absolute",
        content: '""',
        borderStyle: "solid",
        borderWidth: "0 0 20px 20px",
        borderColor: `transparent transparent ${theme.palette.primary.light} transparent`
      }
    },
    contentHeaderBtn: {
      marginLeft: theme.spacing(2)
    },
    widgetWrapper: {
      '& > div[class*="MuiCard-root"]': {
        width: "100%",
        height: "100%"
      },
      '& div[class*="MuiCardContent-root"]': {
        overflow: "auto"
      },
      "& + .react-grid-placeholder": {
        backgroundColor: theme.palette.primary.light
      },
      "&.edit > :active": {
        cursor: "move"
      }
    }
  })
);
function useHomeStorage(defaultWidgets) {
  const key = "home";
  const storageApi = useApi(storageApiRef).forBucket("home.customHomepage");
  const setWidgets = useCallback(
    (value) => {
      const grid = {
        version: 1,
        pages: {
          default: value
        }
      };
      storageApi.set(key, JSON.stringify(grid));
    },
    [key, storageApi]
  );
  const homeSnapshot = useObservable(
    storageApi.observe$(key),
    storageApi.snapshot(key)
  );
  const isStorageLoading = homeSnapshot.presence === "unknown" || !homeSnapshot;
  const widgets = useMemo(() => {
    if (homeSnapshot.presence === "absent") {
      return defaultWidgets;
    }
    try {
      const grid = JSON.parse(homeSnapshot.value);
      return CustomHomepageGridStateV1Schema.parse(grid).pages.default;
    } catch (e) {
      return defaultWidgets;
    }
  }, [homeSnapshot, defaultWidgets]);
  return [widgets, setWidgets, isStorageLoading];
}
const convertConfigToDefaultWidgets = (config, availableWidgets) => {
  const ret = config.map((conf, i) => {
    const c = LayoutConfigurationSchema.parse(conf);
    const name = isValidElement(c.component) ? getComponentData(c.component, "core.extensionName") : c.component;
    if (!name) {
      return null;
    }
    const widget = availableWidgets.find((w) => w.name === name);
    if (!widget) {
      return null;
    }
    const widgetId = `${widget.name}__${i}${Math.random().toString(36).slice(2)}`;
    return {
      id: widgetId,
      layout: {
        i: widgetId,
        x: c.x,
        y: c.y,
        w: Math.min(widget.maxWidth ?? Number.MAX_VALUE, c.width),
        h: Math.min(widget.maxHeight ?? Number.MAX_VALUE, c.height),
        minW: widget.minWidth,
        maxW: widget.maxWidth,
        minH: widget.minHeight,
        maxH: widget.maxHeight,
        isDraggable: false,
        isResizable: false
      },
      settings: {},
      movable: conf.movable,
      deletable: conf.deletable,
      resizable: conf.resizable
    };
  });
  return compact(ret);
};
const availableWidgetsFilter = (elements) => {
  return elements.selectByComponentData({
    key: "core.extensionName"
  }).getElements().flatMap((elem) => {
    const config = getComponentData(elem, "home.widget.config");
    return [
      WidgetSchema.parse({
        component: elem,
        name: getComponentData(elem, "core.extensionName"),
        title: getComponentData(elem, "title"),
        description: getComponentData(elem, "description"),
        settingsSchema: config?.settings?.schema,
        uiSchema: config?.settings?.uiSchema,
        width: config?.layout?.width?.defaultColumns,
        minWidth: config?.layout?.width?.minColumns,
        maxWidth: config?.layout?.width?.maxColumns,
        height: config?.layout?.height?.defaultRows,
        minHeight: config?.layout?.height?.minRows,
        maxHeight: config?.layout?.height?.maxRows
      })
    ];
  });
};
const CustomHomepageGrid = (props) => {
  const styles = useStyles();
  const theme = useTheme();
  const availableWidgets = useElementFilter(
    props.children,
    availableWidgetsFilter,
    [props]
  );
  const defaultLayout = useMemo(() => {
    return props.config ? convertConfigToDefaultWidgets(props.config, availableWidgets) : [];
  }, [props.config, availableWidgets]);
  const [widgets, setWidgets, isStorageLoading] = useHomeStorage(defaultLayout);
  const [addWidgetDialogOpen, setAddWidgetDialogOpen] = useState(false);
  const editModeOn = widgets.find((w) => w.layout.isResizable) !== void 0;
  const [editMode, setEditMode] = useState(editModeOn);
  const getWidgetByName = (name) => {
    return availableWidgets.find((widget) => widget.name === name);
  };
  const getWidgetNameFromKey = (key) => {
    return key.split("__")[0];
  };
  const { t } = useTranslationRef(homeTranslationRef);
  const handleAdd = (widget) => {
    const widgetId = `${widget.name}__${widgets.length + 1}${Math.random().toString(36).slice(2)}`;
    setWidgets([
      ...widgets,
      {
        id: widgetId,
        layout: {
          i: widgetId,
          x: 0,
          y: Math.max(...widgets.map((w) => w.layout.y + w.layout.h)) + 1,
          w: Math.min(widget.maxWidth ?? Number.MAX_VALUE, widget.width ?? 12),
          h: Math.min(widget.maxHeight ?? Number.MAX_VALUE, widget.height ?? 4),
          minW: widget.minWidth,
          maxW: widget.maxWidth,
          minH: widget.minHeight,
          maxH: widget.maxHeight,
          isResizable: editMode,
          isDraggable: editMode
        },
        settings: {},
        movable: widget.movable,
        deletable: widget.deletable,
        resizable: widget.resizable
      }
    ]);
    setAddWidgetDialogOpen(false);
  };
  const handleRemove = (widgetId) => {
    setWidgets(widgets.filter((w) => w.id !== widgetId));
  };
  const handleSettingsSave = (widgetId, widgetSettings) => {
    const idx = widgets.findIndex((w) => w.id === widgetId);
    if (idx >= 0) {
      const widget = widgets[idx];
      widget.settings = widgetSettings;
      widgets[idx] = widget;
      setWidgets(widgets);
    }
  };
  const clearLayout = () => {
    setWidgets(widgets.filter((w) => w.deletable === false));
  };
  const changeEditMode = (mode) => {
    setEditMode(mode);
    setWidgets(
      widgets.map((w) => {
        const resizable = w.resizable === false ? false : mode;
        const movable = w.movable === false ? false : mode;
        return {
          ...w,
          layout: { ...w.layout, isDraggable: movable, isResizable: resizable }
        };
      })
    );
  };
  const handleLayoutChange = (newLayout, _) => {
    if (editMode) {
      const newWidgets = newLayout.map((l) => {
        const widget = widgets.find((w) => w.id === l.i);
        return {
          ...widget,
          layout: l
        };
      });
      setWidgets(newWidgets);
    }
  };
  const handleRestoreDefaultConfig = () => {
    setWidgets(
      defaultLayout.map((w) => {
        const resizable = w.resizable === false ? false : editMode;
        const movable = w.movable === false ? false : editMode;
        return {
          ...w,
          layout: {
            ...w.layout,
            isDraggable: movable,
            isResizable: resizable
          }
        };
      })
    );
  };
  if (isStorageLoading) {
    return /* @__PURE__ */ jsx(Progress, {});
  }
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(ContentHeader, { title: props.title, children: /* @__PURE__ */ jsx(
      CustomHomepageButtons,
      {
        editMode,
        numWidgets: widgets.length,
        clearLayout,
        setAddWidgetDialogOpen,
        changeEditMode,
        defaultConfigAvailable: props.config !== void 0,
        restoreDefault: handleRestoreDefaultConfig
      }
    ) }),
    /* @__PURE__ */ jsx(
      Dialog,
      {
        open: addWidgetDialogOpen,
        onClose: () => setAddWidgetDialogOpen(false),
        children: /* @__PURE__ */ jsx(AddWidgetDialog, { widgets: availableWidgets, handleAdd })
      }
    ),
    !editMode && widgets.length === 0 && /* @__PURE__ */ jsx(Typography, { variant: "h5", align: "center", children: t("customHomepage.noWidgets") }),
    /* @__PURE__ */ jsx(
      ResponsiveGrid,
      {
        className: styles.responsiveGrid,
        measureBeforeMount: true,
        compactType: props.compactType,
        style: props.style,
        allowOverlap: props.allowOverlap,
        preventCollision: props.preventCollision ?? true,
        draggableCancel: ".overlayGridItem,.widgetSettingsDialog,.disabled",
        containerPadding: props.containerPadding,
        margin: props.containerMargin,
        breakpoints: props.breakpoints ? props.breakpoints : theme.breakpoints.values,
        cols: props.cols ? props.cols : { xl: 12, lg: 12, md: 10, sm: 6, xs: 4, xxs: 2 },
        rowHeight: props.rowHeight ?? 60,
        onLayoutChange: handleLayoutChange,
        layouts: { xl: widgets.map((w) => w.layout) },
        children: widgets.map((w) => {
          const l = w.layout;
          const widgetName = getWidgetNameFromKey(l.i);
          const widget = getWidgetByName(widgetName);
          if (!widget || !widget.component) {
            return null;
          }
          const widgetProps = {
            ...widget.component.props,
            ...w.settings ?? {}
          };
          return /* @__PURE__ */ jsxs(
            "div",
            {
              className: `${styles.widgetWrapper} ${editMode && "edit"} ${w.movable === false && "disabled"}`,
              children: [
                /* @__PURE__ */ jsx(ErrorBoundary, { children: /* @__PURE__ */ jsx(widget.component.type, { ...widgetProps }) }),
                editMode && /* @__PURE__ */ jsx(
                  WidgetSettingsOverlay,
                  {
                    id: l.i,
                    widget,
                    handleRemove,
                    handleSettingsSave,
                    settings: w.settings,
                    deletable: w.deletable
                  }
                )
              ]
            },
            l.i
          );
        })
      }
    )
  ] });
};

export { CustomHomepageGrid };
//# sourceMappingURL=CustomHomepageGrid.esm.js.map
