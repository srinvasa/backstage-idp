const DEFAULT_LIST_LIMIT = 8;
class VisitsStorageApi {
  limit;
  storageApi;
  storageKeyPrefix = "@backstage/plugin-home:visits";
  identityApi;
  transformPathnameImpl;
  canSaveImpl;
  enrichVisitImpl;
  static create(options) {
    return new VisitsStorageApi(options);
  }
  constructor(options) {
    this.limit = Math.abs(options.limit ?? 100);
    this.storageApi = options.storageApi;
    this.identityApi = options.identityApi;
    this.transformPathnameImpl = options.transformPathname;
    this.canSaveImpl = options.canSave;
    this.enrichVisitImpl = options.enrichVisit;
  }
  /**
   * Returns a list of visits through the visitsApi
   */
  async list(queryParams) {
    let visits = [...await this.retrieveAll()];
    (queryParams?.orderBy ?? []).reverse().forEach((order) => {
      if (order.direction === "asc") {
        visits.sort((a, b) => this.compare(order, a, b));
      } else {
        visits.sort((a, b) => this.compare(order, b, a));
      }
    });
    (queryParams?.filterBy ?? []).reverse().forEach((filter) => {
      visits = visits.filter((visit) => {
        const field = visit[filter.field];
        if (filter.operator === ">") return field > filter.value;
        if (filter.operator === ">=") return field >= filter.value;
        if (filter.operator === "<") return field < filter.value;
        if (filter.operator === "<=") return field <= filter.value;
        if (filter.operator === "==") return field === filter.value;
        if (filter.operator === "!=") return field !== filter.value;
        if (filter.operator === "contains")
          return `${field}`.includes(`${filter.value}`);
        return false;
      });
    });
    return visits.slice(0, queryParams?.limit ?? DEFAULT_LIST_LIMIT);
  }
  /**
   * Transform the pathname before it is considered for any other processing.
   * @param pathname - the original pathname
   * @returns the transformed pathname
   */
  transformPathname(pathname) {
    return this.transformPathnameImpl?.(pathname) ?? pathname;
  }
  /**
   * Determine whether a visit should be saved.
   * @param visit - page visit data
   */
  async canSave(visit) {
    if (!this.canSaveImpl) {
      return true;
    }
    return Promise.resolve(this.canSaveImpl(visit));
  }
  /**
   * Add additional data to the visit before saving.
   * @param visit - page visit data
   */
  async enrichVisit(visit) {
    if (!this.enrichVisitImpl) {
      return {};
    }
    return Promise.resolve(this.enrichVisitImpl(visit));
  }
  /**
   * Saves a visit through the visitsApi
   */
  async save(saveParams) {
    let visit = saveParams.visit;
    visit = {
      ...visit,
      pathname: this.transformPathname(visit.pathname)
    };
    if (!await this.canSave(visit)) {
      return {
        ...visit,
        id: "",
        hits: 0,
        timestamp: Date.now()
      };
    }
    const enrichedData = await this.enrichVisit(visit);
    const enrichedVisit = { ...visit, ...enrichedData };
    const visits = [...await this.retrieveAll()];
    const visitToSave = {
      ...enrichedVisit,
      id: window.crypto.randomUUID(),
      hits: 1,
      timestamp: Date.now()
    };
    const visitIndex = visits.findIndex(
      (e) => e.pathname === visitToSave.pathname
    );
    if (visitIndex >= 0) {
      visitToSave.id = visits[visitIndex].id;
      visitToSave.hits = visits[visitIndex].hits + 1;
      visits[visitIndex] = visitToSave;
    } else {
      visits.push(visitToSave);
    }
    visits.sort((a, b) => b.timestamp - a.timestamp);
    await this.persistAll(visits.splice(0, this.limit));
    return visitToSave;
  }
  async persistAll(visits) {
    const storageKey = await this.getStorageKey();
    return this.storageApi.set(storageKey, visits);
  }
  async retrieveAll() {
    const storageKey = await this.getStorageKey();
    const snapshot = this.storageApi.snapshot(storageKey);
    if (snapshot?.presence !== "unknown") {
      return snapshot?.value ?? [];
    }
    return new Promise((resolve, reject) => {
      const subscription = this.storageApi.observe$(storageKey).subscribe({
        next: (next) => {
          const visits = next.value ?? [];
          subscription.unsubscribe();
          resolve(visits);
        },
        error: (err) => {
          subscription.unsubscribe();
          reject(err);
        }
      });
    });
  }
  async getStorageKey() {
    const { userEntityRef } = await this.identityApi.getBackstageIdentity();
    const storageKey = `${this.storageKeyPrefix}:${userEntityRef}`;
    return storageKey;
  }
  // This assumes Visit fields are either numbers or strings
  compare(order, a, b) {
    const isNumber = typeof a[order.field] === "number";
    return isNumber ? a[order.field] - b[order.field] : `${a[order.field]}`.localeCompare(`${b[order.field]}`);
  }
}

export { VisitsStorageApi };
//# sourceMappingURL=VisitsStorageApi.esm.js.map
