import { jsx, jsxs } from 'react/jsx-runtime';
import { catalogApiRef, useStarredEntities } from '@backstage/plugin-catalog-react';
import { stringifyEntityRef } from '@backstage/catalog-model';
import { useApi } from '@backstage/core-plugin-api';
import { Progress, ResponseErrorPanel } from '@backstage/core-components';
import List from '@material-ui/core/List';
import Typography from '@material-ui/core/Typography';
import Tabs from '@material-ui/core/Tabs';
import Tab from '@material-ui/core/Tab';
import { useState } from 'react';
import useAsync from 'react-use/esm/useAsync';
import { StarredEntityListItem } from '../../components/StarredEntityListItem/StarredEntityListItem.esm.js';
import { makeStyles } from '@material-ui/core/styles';
import { useTranslationRef } from '@backstage/frontend-plugin-api';
import { homeTranslationRef } from '../../translation.esm.js';

const useStyles = makeStyles((theme) => ({
  tabs: {
    marginBottom: theme.spacing(1)
  },
  list: {
    paddingTop: 0,
    paddingBottom: 0
  }
}));
const Content = ({
  noStarredEntitiesMessage,
  groupByKind
}) => {
  const classes = useStyles();
  const catalogApi = useApi(catalogApiRef);
  const { starredEntities, toggleStarredEntity } = useStarredEntities();
  const [activeTab, setActiveTab] = useState(0);
  const { t } = useTranslationRef(homeTranslationRef);
  const entities = useAsync(async () => {
    if (!starredEntities.size) {
      return [];
    }
    return (await catalogApi.getEntitiesByRefs({
      entityRefs: [...starredEntities],
      fields: [
        "kind",
        "metadata.namespace",
        "metadata.name",
        "spec.type",
        "metadata.title",
        "spec.profile.displayName"
      ]
    })).items.filter((e) => !!e);
  }, [catalogApi, starredEntities]);
  if (starredEntities.size === 0)
    return /* @__PURE__ */ jsx(Typography, { variant: "body1", children: noStarredEntitiesMessage || t("starredEntities.noStarredEntitiesMessage") });
  if (entities.loading) {
    return /* @__PURE__ */ jsx(Progress, {});
  }
  const groupedEntities = {};
  entities.value?.forEach((entity) => {
    const kind = entity.kind;
    if (!groupedEntities[kind]) {
      groupedEntities[kind] = [];
    }
    groupedEntities[kind].push(entity);
  });
  const groupByKindEntries = Object.entries(groupedEntities);
  return entities.error ? /* @__PURE__ */ jsx(ResponseErrorPanel, { error: entities.error }) : /* @__PURE__ */ jsxs("div", { children: [
    !groupByKind && /* @__PURE__ */ jsx(List, { className: classes.list, children: entities.value?.sort(
      (a, b) => (a.metadata.title ?? a.metadata.name).localeCompare(
        b.metadata.title ?? b.metadata.name
      )
    ).map((entity) => /* @__PURE__ */ jsx(
      StarredEntityListItem,
      {
        entity,
        onToggleStarredEntity: toggleStarredEntity,
        showKind: true
      },
      stringifyEntityRef(entity)
    )) }),
    groupByKind && /* @__PURE__ */ jsx(
      Tabs,
      {
        className: classes.tabs,
        value: activeTab,
        onChange: (_, newValue) => setActiveTab(newValue),
        variant: "scrollable",
        scrollButtons: "auto",
        "aria-label": "entity-tabs",
        children: groupByKindEntries.map(([kind]) => /* @__PURE__ */ jsx(Tab, { label: kind }, kind))
      }
    ),
    groupByKind && groupByKindEntries.map(([kind, entitiesByKind], index) => /* @__PURE__ */ jsx("div", { hidden: groupByKind && activeTab !== index, children: /* @__PURE__ */ jsx(List, { className: classes.list, children: entitiesByKind?.sort(
      (a, b) => (a.metadata.title ?? a.metadata.name).localeCompare(
        b.metadata.title ?? b.metadata.name
      )
    ).map((entity) => /* @__PURE__ */ jsx(
      StarredEntityListItem,
      {
        entity,
        onToggleStarredEntity: toggleStarredEntity,
        showKind: false
      },
      stringifyEntityRef(entity)
    )) }) }, kind))
  ] });
};

export { Content };
//# sourceMappingURL=Content.esm.js.map
