{"version":3,"file":"helpers.cjs.js","sources":["../../src/location/helpers.ts"],"sourcesContent":["/*\n * Copyright 2021 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Entity } from '../entity/Entity';\nimport { stringifyEntityRef } from '../entity/ref';\nimport { ANNOTATION_LOCATION, ANNOTATION_SOURCE_LOCATION } from './annotation';\n\n// See https://github.com/facebook/react/blob/f0cf832e1d0c8544c36aa8b310960885a11a847c/packages/react-dom-bindings/src/shared/sanitizeURL.js\nconst scriptProtocolPattern =\n  // eslint-disable-next-line no-control-regex\n  /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*\\:/i;\n\n/**\n * Parses a string form location reference.\n *\n * @public\n * @param ref - A string-form location ref, e.g. `'url:https://host'`\n * @returns A location ref, e.g. `{ type: 'url', target: 'https://host' }`\n */\nexport function parseLocationRef(ref: string): {\n  type: string;\n  target: string;\n} {\n  if (typeof ref !== 'string') {\n    throw new TypeError(\n      `Unable to parse location ref '${ref}', unexpected argument ${typeof ref}`,\n    );\n  }\n\n  const splitIndex = ref.indexOf(':');\n  if (splitIndex < 0) {\n    throw new TypeError(\n      `Unable to parse location ref '${ref}', expected '<type>:<target>', e.g. 'url:https://host/path'`,\n    );\n  }\n\n  const type = ref.substring(0, splitIndex).trim();\n  const target = ref.substring(splitIndex + 1).trim();\n\n  if (!type || !target) {\n    throw new TypeError(\n      `Unable to parse location ref '${ref}', expected '<type>:<target>', e.g. 'url:https://host/path'`,\n    );\n  }\n\n  if (type === 'http' || type === 'https') {\n    throw new TypeError(\n      `Invalid location ref '${ref}', please prefix it with 'url:', e.g. 'url:${ref}'`,\n    );\n  }\n\n  if (scriptProtocolPattern.test(target)) {\n    throw new TypeError(\n      `Invalid location ref '${ref}', target is a javascript: URL`,\n    );\n  }\n\n  return { type, target };\n}\n\n/**\n * Turns a location ref into its string form.\n *\n * @public\n * @param ref - A location ref, e.g. `{ type: 'url', target: 'https://host' }`\n * @returns A string-form location ref, e.g. `'url:https://host'`\n */\nexport function stringifyLocationRef(ref: {\n  type: string;\n  target: string;\n}): string {\n  const { type, target } = ref;\n\n  if (!type) {\n    throw new TypeError(`Unable to stringify location ref, empty type`);\n  } else if (!target) {\n    throw new TypeError(`Unable to stringify location ref, empty target`);\n  }\n\n  if (scriptProtocolPattern.test(target)) {\n    throw new TypeError(\n      `Invalid location ref '${type}:${target}', target is a javascript: URL`,\n    );\n  }\n\n  return `${type}:${target}`;\n}\n\n/**\n * Returns the source code location of the Entity, to the extent that one exists.\n *\n * @remarks\n *\n * If the returned location type is of type 'url', the target should be readable at least\n * using the UrlReader from `@backstage/backend-common`. If it is not of type 'url', the caller\n * needs to have explicit handling of each location type or signal that it is not supported.\n *\n * @public\n */\nexport function getEntitySourceLocation(entity: Entity): {\n  type: string;\n  target: string;\n} {\n  const locationRef =\n    entity.metadata?.annotations?.[ANNOTATION_SOURCE_LOCATION] ??\n    entity.metadata?.annotations?.[ANNOTATION_LOCATION];\n\n  if (!locationRef) {\n    throw new Error(\n      `Entity '${stringifyEntityRef(entity)}' is missing location`,\n    );\n  }\n\n  return parseLocationRef(locationRef);\n}\n"],"names":["ANNOTATION_SOURCE_LOCATION","ANNOTATION_LOCATION","stringifyEntityRef"],"mappings":";;;;;AAqBA,MAAM,qBAAA;AAAA;AAAA,EAEJ;AAAA,CAAA;AASK,SAAS,iBAAiB,GAAA,EAG/B;AACA,EAAA,IAAI,OAAO,QAAQ,QAAA,EAAU;AAC3B,IAAA,MAAM,IAAI,SAAA;AAAA,MACR,CAAA,8BAAA,EAAiC,GAAG,CAAA,uBAAA,EAA0B,OAAO,GAAG,CAAA;AAAA,KAC1E;AAAA,EACF;AAEA,EAAA,MAAM,UAAA,GAAa,GAAA,CAAI,OAAA,CAAQ,GAAG,CAAA;AAClC,EAAA,IAAI,aAAa,CAAA,EAAG;AAClB,IAAA,MAAM,IAAI,SAAA;AAAA,MACR,iCAAiC,GAAG,CAAA,2DAAA;AAAA,KACtC;AAAA,EACF;AAEA,EAAA,MAAM,OAAO,GAAA,CAAI,SAAA,CAAU,CAAA,EAAG,UAAU,EAAE,IAAA,EAAK;AAC/C,EAAA,MAAM,SAAS,GAAA,CAAI,SAAA,CAAU,UAAA,GAAa,CAAC,EAAE,IAAA,EAAK;AAElD,EAAA,IAAI,CAAC,IAAA,IAAQ,CAAC,MAAA,EAAQ;AACpB,IAAA,MAAM,IAAI,SAAA;AAAA,MACR,iCAAiC,GAAG,CAAA,2DAAA;AAAA,KACtC;AAAA,EACF;AAEA,EAAA,IAAI,IAAA,KAAS,MAAA,IAAU,IAAA,KAAS,OAAA,EAAS;AACvC,IAAA,MAAM,IAAI,SAAA;AAAA,MACR,CAAA,sBAAA,EAAyB,GAAG,CAAA,2CAAA,EAA8C,GAAG,CAAA,CAAA;AAAA,KAC/E;AAAA,EACF;AAEA,EAAA,IAAI,qBAAA,CAAsB,IAAA,CAAK,MAAM,CAAA,EAAG;AACtC,IAAA,MAAM,IAAI,SAAA;AAAA,MACR,yBAAyB,GAAG,CAAA,8BAAA;AAAA,KAC9B;AAAA,EACF;AAEA,EAAA,OAAO,EAAE,MAAM,MAAA,EAAO;AACxB;AASO,SAAS,qBAAqB,GAAA,EAG1B;AACT,EAAA,MAAM,EAAE,IAAA,EAAM,MAAA,EAAO,GAAI,GAAA;AAEzB,EAAA,IAAI,CAAC,IAAA,EAAM;AACT,IAAA,MAAM,IAAI,UAAU,CAAA,4CAAA,CAA8C,CAAA;AAAA,EACpE,CAAA,MAAA,IAAW,CAAC,MAAA,EAAQ;AAClB,IAAA,MAAM,IAAI,UAAU,CAAA,8CAAA,CAAgD,CAAA;AAAA,EACtE;AAEA,EAAA,IAAI,qBAAA,CAAsB,IAAA,CAAK,MAAM,CAAA,EAAG;AACtC,IAAA,MAAM,IAAI,SAAA;AAAA,MACR,CAAA,sBAAA,EAAyB,IAAI,CAAA,CAAA,EAAI,MAAM,CAAA,8BAAA;AAAA,KACzC;AAAA,EACF;AAEA,EAAA,OAAO,CAAA,EAAG,IAAI,CAAA,CAAA,EAAI,MAAM,CAAA,CAAA;AAC1B;AAaO,SAAS,wBAAwB,MAAA,EAGtC;AACA,EAAA,MAAM,WAAA,GACJ,OAAO,QAAA,EAAU,WAAA,GAAcA,qCAA0B,CAAA,IACzD,MAAA,CAAO,QAAA,EAAU,WAAA,GAAcC,8BAAmB,CAAA;AAEpD,EAAA,IAAI,CAAC,WAAA,EAAa;AAChB,IAAA,MAAM,IAAI,KAAA;AAAA,MACR,CAAA,QAAA,EAAWC,sBAAA,CAAmB,MAAM,CAAC,CAAA,qBAAA;AAAA,KACvC;AAAA,EACF;AAEA,EAAA,OAAO,iBAAiB,WAAW,CAAA;AACrC;;;;;;"}