import * as react from 'react';
import { ReactElement, ReactNode, ElementType, ComponentPropsWithRef, ComponentProps } from 'react';
import { ButtonProps as ButtonProps$1, DisclosureProps, HeadingProps, DisclosurePanelProps, DisclosureGroupProps, DialogTriggerProps as DialogTriggerProps$1, ModalOverlayProps, TabsProps as TabsProps$1, TabListProps as TabListProps$1, TabProps as TabProps$1, TabPanelProps as TabPanelProps$1, LinkProps as LinkProps$1, CheckboxProps as CheckboxProps$1, RadioGroupProps as RadioGroupProps$1, RadioProps as RadioProps$1, TableProps, TableHeaderProps, TableBodyProps, ColumnProps as ColumnProps$1, CellProps as CellProps$1, RowProps, TagGroupProps as TagGroupProps$1, TagListProps, TagProps as TagProps$1, TextFieldProps as TextFieldProps$1, TooltipProps as TooltipProps$1, TooltipTriggerComponentProps, MenuTriggerProps as MenuTriggerProps$1, SubmenuTriggerProps as SubmenuTriggerProps$1, MenuProps as MenuProps$1, PopoverProps, ListBoxProps, MenuItemProps as MenuItemProps$1, ListBoxItemProps, MenuSectionProps as MenuSectionProps$1, SeparatorProps, SearchFieldProps as SearchFieldProps$1, SelectProps as SelectProps$1, SwitchProps as SwitchProps$1 } from 'react-aria-components';
import * as react_jsx_runtime from 'react/jsx-runtime';
import { NavigateOptions } from 'react-router-dom';

/** @public */
type Breakpoint = 'initial' | 'xs' | 'sm' | 'md' | 'lg' | 'xl';
/** @public */
type Responsive<T> = T | Partial<Record<Breakpoint, T>>;
/** @public */
type Space = '0.5' | '1' | '1.5' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '10' | '11' | '12' | '13' | '14' | string;
/** @public */
type Display = 'none' | 'flex' | 'block' | 'inline';
/** @public */
type FlexDirection = 'row' | 'column';
/** @public */
type FlexWrap = 'wrap' | 'nowrap' | 'wrap-reverse';
/** @public */
type JustifyContent = 'stretch' | 'start' | 'center' | 'end' | 'around' | 'between';
/** @public */
type AlignItems = 'stretch' | 'start' | 'center' | 'end';
/** @public */
type BorderRadius = 'none' | '2xs' | 'xs' | 'sm' | 'md' | 'lg' | 'xl' | '2xl';
/** @public */
type Border = 'none' | 'base' | 'error' | 'warning' | 'selected';
/** @public */
type Columns = '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | '10' | '11' | '12' | 'auto';
/** @public */
interface SpaceProps {
    m?: Responsive<Space>;
    mb?: Responsive<Space>;
    ml?: Responsive<Space>;
    mr?: Responsive<Space>;
    mt?: Responsive<Space>;
    mx?: Responsive<Space>;
    my?: Responsive<Space>;
    p?: Responsive<Space>;
    pb?: Responsive<Space>;
    pl?: Responsive<Space>;
    pr?: Responsive<Space>;
    pt?: Responsive<Space>;
    px?: Responsive<Space>;
    py?: Responsive<Space>;
}
/** @public */
type TextVariants = 'title-large' | 'title-medium' | 'title-small' | 'title-x-small' | 'body-large' | 'body-medium' | 'body-small' | 'body-x-small';
/** @public */
type TextColors = 'primary' | 'secondary';
/** @public */
type TextColorStatus = 'danger' | 'warning' | 'success';
/** @public */
type TextWeights = 'regular' | 'bold';
/** @public */
interface UtilityProps extends SpaceProps {
    alignItems?: Responsive<AlignItems>;
    border?: Responsive<Border>;
    borderRadius?: Responsive<BorderRadius>;
    colEnd?: Responsive<Columns | 'auto'>;
    colSpan?: Responsive<Columns | 'full'>;
    colStart?: Responsive<Columns | 'auto'>;
    columns?: Responsive<Columns>;
    display?: Responsive<Display>;
    flexDirection?: Responsive<FlexDirection>;
    flexWrap?: Responsive<FlexWrap>;
    gap?: Responsive<Space>;
    justifyContent?: Responsive<JustifyContent>;
    rowSpan?: Responsive<Columns | 'full'>;
}
/**
 * Base type for the component styles structure
 * @public
 */
type ClassNamesMap = Record<string, string>;
/**
 * Base type for the component styles structure
 * @public
 */
type DataAttributeValues = readonly (string | number | boolean)[];
/**
 * Base type for the component styles structure
 * @public
 */
type DataAttributesMap = Record<string, DataAttributeValues>;
/**
 * Base type for the component styles structure
 * @public
 */
interface ComponentDefinition {
    classNames: ClassNamesMap;
    dataAttributes?: DataAttributesMap;
    utilityProps?: string[];
}

/** @public */
interface BoxProps extends SpaceProps {
    display?: Responsive<'none' | 'flex' | 'block' | 'inline'>;
    as?: keyof JSX.IntrinsicElements;
    width?: Responsive<string>;
    minWidth?: Responsive<string>;
    maxWidth?: Responsive<string>;
    height?: Responsive<string>;
    minHeight?: Responsive<string>;
    maxHeight?: Responsive<string>;
    position?: Responsive<'static' | 'relative' | 'absolute' | 'fixed' | 'sticky'>;
    children?: React.ReactNode;
    className?: string;
    style?: React.CSSProperties;
}

/** @public */
declare const Box: react.ForwardRefExoticComponent<BoxProps & react.RefAttributes<HTMLDivElement>>;

/**
 * Component definition for Box
 * @public
 */
declare const BoxDefinition: {
    readonly classNames: {
        readonly root: "bui-Box";
    };
    readonly utilityProps: ["m", "mb", "ml", "mr", "mt", "mx", "my", "p", "pb", "pl", "pr", "pt", "px", "py", "position", "display", "width", "minWidth", "maxWidth", "height", "minHeight", "maxHeight"];
};

/** @public */
interface GridProps extends SpaceProps {
    children?: React.ReactNode;
    className?: string;
    columns?: Responsive<Columns>;
    gap?: Responsive<Space>;
    style?: React.CSSProperties;
}
/** @public */
interface GridItemProps {
    children?: React.ReactNode;
    className?: string;
    colSpan?: Responsive<Columns>;
    colEnd?: Responsive<Columns>;
    colStart?: Responsive<Columns>;
    rowSpan?: Responsive<Columns>;
    style?: React.CSSProperties;
}

/** @public */
declare const Grid: {
    Root: react.ForwardRefExoticComponent<GridProps & react.RefAttributes<HTMLDivElement>>;
    Item: react.ForwardRefExoticComponent<GridItemProps & react.RefAttributes<HTMLDivElement>>;
};

/**
 * Component definition for Grid
 * @public
 */
declare const GridDefinition: {
    readonly classNames: {
        readonly root: "bui-Grid";
    };
    readonly utilityProps: ["columns", "gap", "m", "mb", "ml", "mr", "mt", "mx", "my", "p", "pb", "pl", "pr", "pt", "px", "py"];
};
/**
 * Component definition for GridItem
 * @public
 */
declare const GridItemDefinition: {
    readonly classNames: {
        readonly root: "bui-GridItem";
    };
    readonly utilityProps: ["colSpan", "colEnd", "colStart", "rowSpan"];
};

/** @public */
interface FlexProps extends SpaceProps {
    children?: React.ReactNode;
    gap?: Responsive<Space>;
    align?: Responsive<'start' | 'center' | 'end' | 'baseline' | 'stretch'>;
    justify?: Responsive<'start' | 'center' | 'end' | 'between'>;
    direction?: Responsive<'row' | 'column' | 'row-reverse' | 'column-reverse'>;
    className?: string;
    style?: React.CSSProperties;
}

/** @public */
declare const Flex: react.ForwardRefExoticComponent<FlexProps & react.RefAttributes<HTMLDivElement>>;

/**
 * Component definition for Flex
 * @public
 */
declare const FlexDefinition: {
    readonly classNames: {
        readonly root: "bui-Flex";
    };
    readonly utilityProps: ["m", "mb", "ml", "mr", "mt", "mx", "my", "p", "pb", "pl", "pr", "pt", "px", "py", "gap", "align", "justify", "direction"];
};

/** @public */
interface ContainerProps {
    children?: React.ReactNode;
    className?: string;
    my?: SpaceProps['my'];
    mb?: SpaceProps['mb'];
    mt?: SpaceProps['mt'];
    py?: SpaceProps['py'];
    pb?: SpaceProps['pb'];
    pt?: SpaceProps['pt'];
    style?: React.CSSProperties;
}

/** @public */
declare const Container: react.ForwardRefExoticComponent<ContainerProps & react.RefAttributes<HTMLDivElement>>;

/**
 * Component definition for Container
 * @public
 */
declare const ContainerDefinition: {
    readonly classNames: {
        readonly root: "bui-Container";
    };
    readonly utilityProps: ["my", "mt", "mb", "py", "pt", "pb", "display"];
};

/** @public */
interface AvatarProps extends React.ComponentPropsWithoutRef<'div'> {
    /**
     * URL of the image to display
     */
    src: string;
    /**
     * Name of the person - used for generating initials and accessibility labels
     */
    name: string;
    /**
     * Size of the avatar
     * @defaultValue 'medium'
     */
    size?: 'x-small' | 'small' | 'medium' | 'large' | 'x-large';
    /**
     * Determines how the avatar is presented to assistive technologies.
     * - 'informative': Avatar is announced as "\{name\}" to screen readers
     * - 'decoration': Avatar is hidden from screen readers (use when name appears in adjacent text)
     * @defaultValue 'informative'
     */
    purpose?: 'decoration' | 'informative';
}

/** @public */
declare const Avatar: react.ForwardRefExoticComponent<AvatarProps & react.RefAttributes<HTMLDivElement>>;

/**
 * Component definition for Avatar
 * @public
 */
declare const AvatarDefinition: {
    readonly classNames: {
        readonly root: "bui-AvatarRoot";
        readonly image: "bui-AvatarImage";
        readonly fallback: "bui-AvatarFallback";
    };
    readonly dataAttributes: {
        readonly size: readonly ["small", "medium", "large"];
    };
};

/**
 * Properties for {@link Button}
 *
 * @public
 */
interface ButtonProps extends ButtonProps$1 {
    size?: 'small' | 'medium' | Partial<Record<Breakpoint, 'small' | 'medium'>>;
    variant?: 'primary' | 'secondary' | 'tertiary' | Partial<Record<Breakpoint, 'primary' | 'secondary' | 'tertiary'>>;
    iconStart?: ReactElement;
    iconEnd?: ReactElement;
    children?: ReactNode;
    loading?: boolean;
}

/** @public */
declare const Button: react.ForwardRefExoticComponent<ButtonProps & react.RefAttributes<HTMLButtonElement>>;

/**
 * Component definition for Button
 * @public
 */
declare const ButtonDefinition: {
    readonly classNames: {
        readonly root: "bui-Button";
        readonly content: "bui-ButtonContent";
        readonly spinner: "bui-ButtonSpinner";
    };
    readonly dataAttributes: {
        readonly size: readonly ["small", "medium", "large"];
        readonly variant: readonly ["primary", "secondary", "tertiary"];
        readonly loading: readonly [true, false];
    };
};

/**
 * Props for the Card component.
 *
 * @public
 */
interface CardProps extends React.HTMLAttributes<HTMLDivElement> {
    children?: React.ReactNode;
}
/**
 * Props for the CardHeader component.
 *
 * @public
 */
interface CardHeaderProps extends React.HTMLAttributes<HTMLDivElement> {
    children?: React.ReactNode;
}
/**
 * Props for the CardBody component.
 *
 * @public
 */
interface CardBodyProps extends React.HTMLAttributes<HTMLDivElement> {
    children?: React.ReactNode;
}
/**
 * Props for the CardFooter component.
 *
 * @public
 */
interface CardFooterProps extends React.HTMLAttributes<HTMLDivElement> {
    children?: React.ReactNode;
}

/**
 * Card component.
 *
 * @public
 */
declare const Card: react.ForwardRefExoticComponent<CardProps & react.RefAttributes<HTMLDivElement>>;
/**
 * CardHeader component.
 *
 * @public
 */
declare const CardHeader: react.ForwardRefExoticComponent<CardHeaderProps & react.RefAttributes<HTMLDivElement>>;
/**
 * CardBody component.
 *
 * @public
 */
declare const CardBody: react.ForwardRefExoticComponent<CardBodyProps & react.RefAttributes<HTMLDivElement>>;
/**
 * CardFooter component.
 *
 * @public
 */
declare const CardFooter: react.ForwardRefExoticComponent<CardFooterProps & react.RefAttributes<HTMLDivElement>>;

/**
 * Component definition for Card
 * @public
 */
declare const CardDefinition: {
    readonly classNames: {
        readonly root: "bui-Card";
        readonly header: "bui-CardHeader";
        readonly body: "bui-CardBody";
        readonly footer: "bui-CardFooter";
    };
};

/**
 * Props for the Accordion component.
 * @public
 */
interface AccordionProps extends DisclosureProps {
    className?: string;
}
/**
 * Props for the AccordionTrigger component.
 * @public
 */
interface AccordionTriggerProps extends HeadingProps {
    className?: string;
    title?: string;
    subtitle?: string;
    children?: React.ReactNode;
}
/**
 * Props for the AccordionPanel component.
 * @public
 */
interface AccordionPanelProps extends DisclosurePanelProps {
    className?: string;
}
/**
 * Props for the AccordionGroup component.
 * @public
 */
interface AccordionGroupProps extends DisclosureGroupProps {
    className?: string;
    /**
     * Whether multiple accordions can be expanded at the same time.
     * @defaultValue false
     */
    allowsMultiple?: boolean;
}

/** @public */
declare const Accordion: react.ForwardRefExoticComponent<AccordionProps & react.RefAttributes<HTMLDivElement>>;
/** @public */
declare const AccordionTrigger: react.ForwardRefExoticComponent<AccordionTriggerProps & react.RefAttributes<HTMLHeadingElement>>;
/** @public */
declare const AccordionPanel: react.ForwardRefExoticComponent<AccordionPanelProps & react.RefAttributes<HTMLDivElement>>;
/** @public */
declare const AccordionGroup: react.ForwardRefExoticComponent<AccordionGroupProps & react.RefAttributes<HTMLDivElement>>;

/**
 * Component definition for Accordion
 * @public
 */
declare const AccordionDefinition: {
    readonly classNames: {
        readonly root: "bui-Accordion";
        readonly trigger: "bui-AccordionTrigger";
        readonly triggerButton: "bui-AccordionTriggerButton";
        readonly triggerTitle: "bui-AccordionTriggerTitle";
        readonly triggerSubtitle: "bui-AccordionTriggerSubtitle";
        readonly triggerIcon: "bui-AccordionTriggerIcon";
        readonly panel: "bui-AccordionPanel";
        readonly group: "bui-AccordionGroup";
    };
};

/**
 * Props for the DialogTrigger component.
 * @public
 */
interface DialogTriggerProps extends DialogTriggerProps$1 {
}
/**
 * Props for the Dialog component.
 * @public
 */
interface DialogProps extends ModalOverlayProps {
    className?: string;
    children?: React.ReactNode;
    width?: number | string;
    height?: number | string;
}
/**
 * Props for the DialogHeader component.
 * @public
 */
interface DialogHeaderProps extends HeadingProps {
    children?: React.ReactNode;
    className?: string;
}
/**
 * Props for the DialogBody component.
 * @public
 */
interface DialogBodyProps {
    children?: React.ReactNode;
    className?: string;
}

/** @public */
declare const DialogTrigger: (props: DialogTriggerProps) => react_jsx_runtime.JSX.Element;
/** @public */
declare const Dialog: react.ForwardRefExoticComponent<DialogProps & react.RefAttributes<HTMLDivElement>>;
/** @public */
declare const DialogHeader: react.ForwardRefExoticComponent<DialogHeaderProps & react.RefAttributes<HTMLDivElement>>;
/** @public */
declare const DialogBody: react.ForwardRefExoticComponent<DialogBodyProps & react.RefAttributes<HTMLDivElement>>;
/** @public */
declare const DialogFooter: react.ForwardRefExoticComponent<Omit<react.DetailedHTMLProps<react.HTMLAttributes<HTMLDivElement>, HTMLDivElement>, "ref"> & react.RefAttributes<HTMLDivElement>>;

/**
 * Component definition for Dialog
 * @public
 */
declare const DialogDefinition: {
    readonly classNames: {
        readonly overlay: "bui-DialogOverlay";
        readonly dialog: "bui-Dialog";
        readonly header: "bui-DialogHeader";
        readonly headerTitle: "bui-DialogHeaderTitle";
        readonly body: "bui-DialogBody";
        readonly footer: "bui-DialogFooter";
    };
};

/** @public */
interface FieldLabelProps extends Pick<React.HTMLAttributes<HTMLDivElement>, 'className'> {
    /**
     * The label of the text field
     */
    label?: string | null;
    /**
     * The secondary label of the text field
     */
    secondaryLabel?: string | null;
    /**
     * The description of the text field
     */
    description?: string | null;
    /**
     * The HTML for attribute of the text field
     */
    htmlFor?: string;
    /**
     * The id of the text field
     */
    id?: string;
}

/** @public */
declare const FieldLabel: react.ForwardRefExoticComponent<FieldLabelProps & react.RefAttributes<HTMLDivElement>>;

/**
 * Component definition for FieldLabel
 * @public
 */
declare const FieldLabelDefinition: {
    readonly classNames: {
        readonly root: "bui-FieldLabelWrapper";
        readonly label: "bui-FieldLabel";
        readonly secondaryLabel: "bui-FieldSecondaryLabel";
        readonly description: "bui-FieldDescription";
    };
};

/**
 * Strategies for matching the current route to determine which tab should be active.
 *
 * @public
 */
type TabMatchStrategy = 'exact' | 'prefix';
/**
 * Props for the Tabs component.
 *
 * @public
 */
interface TabsProps extends TabsProps$1 {
}
/**
 * Props for the TabList component.
 *
 * @public
 */
interface TabListProps extends Omit<TabListProps$1<object>, 'items'> {
}
/**
 * Props for the Tab component.
 *
 * @public
 */
interface TabProps extends TabProps$1 {
    /**
     * Strategy for matching the current route to determine if this tab should be active.
     * - 'exact': Tab href must exactly match the current pathname (default)
     * - 'prefix': Tab is active if current pathname starts with tab href
     */
    matchStrategy?: 'exact' | 'prefix';
}
/**
 * Props for the TabPanel component.
 *
 * @public
 */
interface TabPanelProps extends TabPanelProps$1 {
}

/**
 * A component that renders a list of tabs.
 *
 * @public
 */
declare const Tabs: (props: TabsProps) => react_jsx_runtime.JSX.Element | null;
/**
 * A component that renders a list of tabs.
 *
 * @public
 */
declare const TabList: (props: TabListProps) => react_jsx_runtime.JSX.Element;
/**
 * A component that renders a tab.
 *
 * @public
 */
declare const Tab: (props: TabProps) => react_jsx_runtime.JSX.Element;
/**
 * A component that renders the content of a tab.
 *
 * @public
 */
declare const TabPanel: (props: TabPanelProps) => react_jsx_runtime.JSX.Element;

/**
 * Component definition for Tabs
 * @public
 */
declare const TabsDefinition: {
    readonly classNames: {
        readonly tabs: "bui-Tabs";
        readonly tabList: "bui-TabList";
        readonly tabListWrapper: "bui-TabListWrapper";
        readonly tab: "bui-Tab";
        readonly tabActive: "bui-TabActive";
        readonly tabHovered: "bui-TabHovered";
        readonly panel: "bui-TabPanel";
    };
};

/**
 * Props for the main Header component.
 *
 * @public
 */
interface HeaderProps {
    icon?: React.ReactNode;
    title?: string;
    titleLink?: string;
    customActions?: React.ReactNode;
    tabs?: HeaderTab[];
    onTabSelectionChange?: TabsProps$1['onSelectionChange'];
    className?: string;
}
/**
 * Represents a tab item in the header navigation.
 *
 * @public
 */
interface HeaderTab {
    id: string;
    label: string;
    href: string;
    /**
     * Strategy for matching the current route to determine if this tab should be active.
     * - 'exact': Tab href must exactly match the current pathname (default)
     * - 'prefix': Tab is active if current pathname starts with tab href
     */
    matchStrategy?: TabMatchStrategy;
}

declare module 'react-aria-components' {
    interface RouterConfig {
        routerOptions: NavigateOptions;
    }
}
/**
 * A component that renders a toolbar.
 *
 * @public
 */
declare const Header: (props: HeaderProps) => react_jsx_runtime.JSX.Element;

/**
 * Component definition for Header
 * @public
 */
declare const HeaderDefinition: {
    readonly classNames: {
        readonly toolbar: "bui-HeaderToolbar";
        readonly toolbarWrapper: "bui-HeaderToolbarWrapper";
        readonly toolbarContent: "bui-HeaderToolbarContent";
        readonly toolbarControls: "bui-HeaderToolbarControls";
        readonly toolbarIcon: "bui-HeaderToolbarIcon";
        readonly toolbarName: "bui-HeaderToolbarName";
        readonly tabsWrapper: "bui-HeaderTabsWrapper";
    };
};

/**
 * Props for the main HeaderPage component.
 *
 * @public
 */
interface HeaderPageProps {
    title?: string;
    customActions?: React.ReactNode;
    tabs?: HeaderTab[];
    breadcrumbs?: HeaderPageBreadcrumb[];
    className?: string;
}
/**
 * Represents a breadcrumb item in the header.
 *
 * @public
 */
interface HeaderPageBreadcrumb {
    label: string;
    href: string;
}

/**
 * A component that renders a header page.
 *
 * @public
 */
declare const HeaderPage: (props: HeaderPageProps) => react_jsx_runtime.JSX.Element;

/**
 * Component definition for HeaderPage
 * @public
 */
declare const HeaderPageDefinition: {
    readonly classNames: {
        readonly root: "bui-HeaderPage";
        readonly content: "bui-HeaderPageContent";
        readonly breadcrumbs: "bui-HeaderPageBreadcrumbs";
        readonly tabsWrapper: "bui-HeaderPageTabsWrapper";
        readonly controls: "bui-HeaderPageControls";
    };
};

/**
 * Properties for {@link ButtonIcon}
 *
 * @public
 */
interface ButtonIconProps extends ButtonProps$1 {
    size?: 'small' | 'medium' | Partial<Record<Breakpoint, 'small' | 'medium'>>;
    variant?: 'primary' | 'secondary' | 'tertiary' | Partial<Record<Breakpoint, 'primary' | 'secondary' | 'tertiary'>>;
    icon?: ReactElement;
    loading?: boolean;
}

/** @public */
declare const ButtonIcon: react.ForwardRefExoticComponent<ButtonIconProps & react.RefAttributes<HTMLButtonElement>>;

/**
 * Component definition for ButtonIcon
 * @public
 */
declare const ButtonIconDefinition: {
    readonly classNames: {
        readonly root: "bui-ButtonIcon";
        readonly content: "bui-ButtonIconContent";
        readonly spinner: "bui-ButtonIconSpinner";
    };
};

/**
 * Properties for {@link ButtonLink}
 *
 * @public
 */
interface ButtonLinkProps extends LinkProps$1 {
    size?: 'small' | 'medium' | Partial<Record<Breakpoint, 'small' | 'medium'>>;
    variant?: 'primary' | 'secondary' | 'tertiary' | Partial<Record<Breakpoint, 'primary' | 'secondary' | 'tertiary'>>;
    iconStart?: ReactElement;
    iconEnd?: ReactElement;
    children?: ReactNode;
}

/** @public */
declare const ButtonLink: react.ForwardRefExoticComponent<ButtonLinkProps & react.RefAttributes<HTMLAnchorElement>>;

/**
 * Component definition for ButtonLink
 * @public
 */
declare const ButtonLinkDefinition: {
    readonly classNames: {
        readonly root: "bui-ButtonLink";
    };
};

/** @public */
interface CheckboxProps extends CheckboxProps$1 {
    children: React.ReactNode;
}

/** @public */
declare const Checkbox: react.ForwardRefExoticComponent<CheckboxProps & react.RefAttributes<HTMLLabelElement>>;

/**
 * Component definition for Checkbox
 * @public
 */
declare const CheckboxDefinition: {
    readonly classNames: {
        readonly root: "bui-Checkbox";
        readonly indicator: "bui-CheckboxIndicator";
    };
    readonly dataAttributes: {
        readonly selected: readonly [true, false];
    };
};

/** @public */
interface RadioGroupProps extends Omit<RadioGroupProps$1, 'children'>, Omit<FieldLabelProps, 'htmlFor' | 'id' | 'className'> {
    children?: ReactNode;
}
/** @public */
interface RadioProps extends RadioProps$1 {
}

/** @public */
declare const RadioGroup: react.ForwardRefExoticComponent<RadioGroupProps & react.RefAttributes<HTMLDivElement>>;
/** @public */
declare const Radio: react.ForwardRefExoticComponent<RadioProps & react.RefAttributes<HTMLLabelElement>>;

/**
 * Component definition for RadioGroup
 * @public
 */
declare const RadioGroupDefinition: {
    readonly classNames: {
        readonly root: "bui-RadioGroup";
        readonly content: "bui-RadioGroupContent";
        readonly radio: "bui-Radio";
    };
};

/** @public */
declare const Table: (props: TableProps) => react_jsx_runtime.JSX.Element;

/** @public */
declare const TableHeader: <T extends object>(props: TableHeaderProps<T>) => react_jsx_runtime.JSX.Element;

/** @public */
declare const TableBody: <T extends object>(props: TableBodyProps<T>) => react_jsx_runtime.JSX.Element;

/** @public */
interface CellProps extends CellProps$1 {
    title: string;
    description?: string;
    color?: TextColors;
    leadingIcon?: React.ReactNode | null;
    href?: string;
}
/** @public */
interface CellProfileProps extends CellProps$1 {
    src?: string;
    name?: string;
    href?: string;
    description?: string;
    color?: TextColors;
}
/** @public */
interface ColumnProps extends Omit<ColumnProps$1, 'children'> {
    children?: React.ReactNode;
}

/** @public */
declare const Column: (props: ColumnProps) => react_jsx_runtime.JSX.Element;

/** @public */
declare function Row<T extends object>(props: RowProps<T>): react_jsx_runtime.JSX.Element;

/** @public */
declare const Cell: {
    (props: CellProps): react_jsx_runtime.JSX.Element;
    displayName: string;
};

/** @public */
declare const CellProfile: (props: CellProfileProps) => react_jsx_runtime.JSX.Element;

/** @public */
interface TablePaginationProps extends React.HTMLAttributes<HTMLDivElement> {
    offset?: number;
    pageSize?: number;
    setPageSize?: (pageSize: number) => void;
    setOffset?: (offset: number) => void;
    rowCount?: number;
    onNextPage?: () => void;
    onPreviousPage?: () => void;
    onPageSizeChange?: (pageSize: number) => void;
    showPageSizeOptions?: boolean;
}

/** @public */
interface UseTablePaginationConfig {
    /** Total number of rows in the dataset - only needed when data is not provided at the top level */
    rowCount?: number;
    /** Current offset. When provided, pagination is controlled */
    offset?: number;
    /** Current page size. When provided, pagination is controlled */
    pageSize?: number;
    /** Callback when offset changes */
    onOffsetChange?: (offset: number) => void;
    /** Callback when page size changes */
    onPageSizeChange?: (pageSize: number) => void;
    /** Default page size for uncontrolled mode */
    defaultPageSize?: number;
    /** Default offset for uncontrolled mode */
    defaultOffset?: number;
    /** Callback when next page is clicked */
    onNextPage?: () => void;
    /** Callback when previous page is clicked */
    onPreviousPage?: () => void;
    /** Whether to show page size options */
    showPageSizeOptions?: boolean;
}
/** @public */
interface UseTablePagination<T = any> {
    /** Props to pass to TablePagination component */
    paginationProps: TablePaginationProps;
    /** Current offset */
    offset: number;
    /** Current page size */
    pageSize: number;
    /** Sliced data for current page - only available when data is provided to useTable */
    data?: T[];
    /** Go to next page */
    nextPage: () => void;
    /** Go to previous page */
    previousPage: () => void;
    /** Set specific offset */
    setOffset: (offset: number) => void;
    /** Set page size */
    setPageSize: (pageSize: number) => void;
}
/** @public */
interface UseTableConfig<T = any> {
    /** Full dataset - when provided, rowCount is calculated automatically and sliced data is returned */
    data?: T[];
    /** Pagination configuration */
    pagination?: UseTablePaginationConfig;
}
/** @public */
interface UseTableResult<T = any> {
    /** Sliced data for current page */
    data?: T[];
    /** Props to pass to TablePagination component */
    paginationProps: TablePaginationProps;
    /** Pagination utilities */
    pagination: UseTablePagination<T>;
}

/**
 * Hook for managing table state including pagination and future features like sorting.
 * Supports both controlled and uncontrolled modes using offset/pageSize pattern (Backstage style).
 *
 * @public
 */
declare function useTable<T = any>(config?: UseTableConfig<T>): UseTableResult<T>;

/**
 * Component definition for Table
 * @public
 */
declare const TableDefinition: {
    readonly classNames: {
        readonly table: "bui-Table";
        readonly header: "bui-TableHeader";
        readonly body: "bui-TableBody";
        readonly row: "bui-TableRow";
        readonly head: "bui-TableHead";
        readonly headContent: "bui-TableHeadContent";
        readonly headSortButton: "bui-TableHeadSortButton";
        readonly caption: "bui-TableCaption";
        readonly cell: "bui-TableCell";
        readonly cellContentWrapper: "bui-TableCellContentWrapper";
        readonly cellContent: "bui-TableCellContent";
        readonly cellIcon: "bui-TableCellIcon";
        readonly cellProfileAvatar: "bui-TableCellProfileAvatar";
        readonly cellProfileAvatarImage: "bui-TableCellProfileAvatarImage";
        readonly cellProfileAvatarFallback: "bui-TableCellProfileAvatarFallback";
        readonly cellProfileName: "bui-TableCellProfileName";
        readonly cellProfileLink: "bui-TableCellProfileLink";
    };
};

/**
 * Pagination controls for Table components with page navigation and size selection.
 *
 * @public
 */
declare function TablePagination(props: TablePaginationProps): react_jsx_runtime.JSX.Element;

/**
 * Component definition for TablePagination
 * @public
 */
declare const TablePaginationDefinition: {
    readonly classNames: {
        readonly root: "bui-TablePagination";
        readonly left: "bui-TablePaginationLeft";
        readonly right: "bui-TablePaginationRight";
        readonly select: "bui-TablePaginationSelect";
    };
};

/**
 * Props for the TagGroup component.
 *
 * @public
 */
interface TagGroupProps<T> extends Omit<TagGroupProps$1, 'children'>, Pick<TagListProps<T>, 'items' | 'children' | 'renderEmptyState'> {
}
/**
 * Props for the Tag component.
 *
 * @public
 */
interface TagProps extends TagProps$1 {
    /**
     * The icon to display in the chip.
     */
    icon?: React.ReactNode;
    /**
     * The size of the chip.
     */
    size?: 'small' | 'medium';
}

/**
 * A component that renders a list of tags.
 *
 * @public
 */
declare const TagGroup: <T extends object>(props: TagGroupProps<T>) => react_jsx_runtime.JSX.Element;
/**
 * A component that renders a tag.
 *
 * @public
 */
declare const Tag: (props: TagProps) => react_jsx_runtime.JSX.Element;

/**
 * Component definition for TagGroup
 * @public
 */
declare const TagGroupDefinition: {
    readonly classNames: {
        readonly group: "bui-TagGroup";
        readonly list: "bui-TagList";
        readonly tag: "bui-Tag";
        readonly tagIcon: "bui-TagIcon";
        readonly tagRemoveButton: "bui-TagRemoveButton";
    };
};

/** @public */
type TextOwnProps = {
    as?: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6' | 'p' | 'span' | 'label' | 'div' | 'strong' | 'em' | 'small' | 'legend';
    variant?: TextVariants | Partial<Record<Breakpoint, TextVariants>>;
    weight?: TextWeights | Partial<Record<Breakpoint, TextWeights>>;
    color?: TextColors | TextColorStatus | Partial<Record<Breakpoint, TextColors | TextColorStatus>>;
    truncate?: boolean;
};
/** @public */
type TextProps<T extends ElementType = 'span'> = TextOwnProps & Omit<ComponentPropsWithRef<T>, keyof TextOwnProps>;

/** @public */
declare const Text: {
    <T extends ElementType = "p">(props: TextProps<T> & {
        ref?: React.ComponentPropsWithRef<T>["ref"];
    }): React.ReactElement<TextProps<T>, T>;
    displayName: string;
};

/**
 * Component definition for Text
 * @public
 */
declare const TextDefinition: {
    readonly classNames: {
        readonly root: "bui-Text";
    };
    readonly dataAttributes: {
        readonly variant: readonly ["subtitle", "body", "caption", "label"];
        readonly weight: readonly ["regular", "bold"];
        readonly color: readonly ["primary", "secondary", "danger", "warning", "success"];
        readonly truncate: readonly [true, false];
    };
};

/** @public */
interface TextFieldProps extends TextFieldProps$1, Omit<FieldLabelProps, 'htmlFor' | 'id' | 'className'> {
    /**
     * The HTML input type for the text field
     *
     * @remarks
     * Use `SearchField` for
     * search inputs and `PasswordField` for password inputs.
     */
    type?: 'text' | 'email' | 'tel' | 'url';
    /**
     * An icon to render before the input
     */
    icon?: ReactNode;
    /**
     * The size of the text field
     * @defaultValue 'medium'
     */
    size?: 'small' | 'medium' | Partial<Record<Breakpoint, 'small' | 'medium'>>;
    /**
     * Text to display in the input when it has no value
     */
    placeholder?: string;
}

/** @public */
declare const TextField: react.ForwardRefExoticComponent<TextFieldProps & react.RefAttributes<HTMLDivElement>>;

/**
 * Component definition for TextField
 * @public
 */
declare const TextFieldDefinition: {
    readonly classNames: {
        readonly root: "bui-TextField";
        readonly inputWrapper: "bui-InputWrapper";
        readonly input: "bui-Input";
        readonly inputIcon: "bui-InputIcon";
        readonly inputAction: "bui-InputAction";
    };
    readonly dataAttributes: {
        readonly invalid: readonly [true, false];
        readonly disabled: readonly [true, false];
        readonly size: readonly ["small", "medium"];
    };
};

/** @public */
interface TooltipProps extends Omit<TooltipProps$1, 'children'> {
    children: React.ReactNode;
}

/** @public */
declare const TooltipTrigger: (props: TooltipTriggerComponentProps) => react_jsx_runtime.JSX.Element;
/** @public */
declare const Tooltip: react.ForwardRefExoticComponent<TooltipProps & react.RefAttributes<HTMLDivElement>>;

/**
 * Component definition for Tooltip
 * @public
 */
declare const TooltipDefinition: {
    readonly classNames: {
        readonly tooltip: "bui-Tooltip";
        readonly arrow: "bui-TooltipArrow";
    };
};

/** @public */
interface MenuTriggerProps extends MenuTriggerProps$1 {
}
/** @public */
interface SubmenuTriggerProps extends SubmenuTriggerProps$1 {
}
/** @public */
interface MenuProps<T> extends MenuProps$1<T>, Omit<MenuProps$1<T>, 'children'> {
    placement?: PopoverProps['placement'];
    virtualized?: boolean;
    maxWidth?: string;
    maxHeight?: string;
}
/** @public */
interface MenuListBoxProps<T> extends ListBoxProps<T>, Omit<ListBoxProps<T>, 'children'> {
    placement?: PopoverProps['placement'];
    virtualized?: boolean;
    maxWidth?: string;
    maxHeight?: string;
}
/** @public */
interface MenuAutocompleteProps<T> extends MenuProps$1<T>, Omit<MenuProps$1<T>, 'children'> {
    placeholder?: string;
    placement?: PopoverProps['placement'];
    virtualized?: boolean;
    maxWidth?: string;
    maxHeight?: string;
}
/** @public */
interface MenuAutocompleteListBoxProps<T> extends ListBoxProps<T>, Omit<ListBoxProps<T>, 'children'> {
    placeholder?: string;
    placement?: PopoverProps['placement'];
    virtualized?: boolean;
    maxWidth?: string;
    maxHeight?: string;
}
/** @public */
interface MenuItemProps extends MenuItemProps$1, Omit<MenuItemProps$1, 'children'> {
    iconStart?: React.ReactNode;
    children: React.ReactNode;
    color?: 'primary' | 'danger';
}
/** @public */
interface MenuListBoxItemProps extends ListBoxItemProps, Omit<ListBoxItemProps, 'children'> {
    children: React.ReactNode;
}
/** @public */
interface MenuSectionProps<T> extends MenuSectionProps$1<T>, Omit<MenuSectionProps$1<T>, 'children'> {
    title: string;
    children: React.ReactNode;
}
/** @public */
interface MenuSeparatorProps extends SeparatorProps {
}

/** @public */
declare const MenuTrigger: (props: MenuTriggerProps) => react_jsx_runtime.JSX.Element;
/** @public */
declare const SubmenuTrigger: (props: SubmenuTriggerProps) => react_jsx_runtime.JSX.Element;
/** @public */
declare const Menu: (props: MenuProps<object>) => react_jsx_runtime.JSX.Element;
/** @public */
declare const MenuListBox: (props: MenuListBoxProps<object>) => react_jsx_runtime.JSX.Element;
/** @public */
declare const MenuAutocomplete: (props: MenuAutocompleteProps<object>) => react_jsx_runtime.JSX.Element;
/** @public */
declare const MenuAutocompleteListbox: (props: MenuAutocompleteListBoxProps<object>) => react_jsx_runtime.JSX.Element;
/** @public */
declare const MenuItem: (props: MenuItemProps) => react_jsx_runtime.JSX.Element;
/** @public */
declare const MenuListBoxItem: (props: MenuListBoxItemProps) => react_jsx_runtime.JSX.Element;
/** @public */
declare const MenuSection: (props: MenuSectionProps<object>) => react_jsx_runtime.JSX.Element;
/** @public */
declare const MenuSeparator: (props: MenuSeparatorProps) => react_jsx_runtime.JSX.Element;

/**
 * Component definition for Menu
 * @public
 */
declare const MenuDefinition: {
    readonly classNames: {
        readonly root: "bui-Menu";
        readonly popover: "bui-MenuPopover";
        readonly content: "bui-MenuContent";
        readonly section: "bui-MenuSection";
        readonly sectionHeader: "bui-MenuSectionHeader";
        readonly item: "bui-MenuItem";
        readonly itemListBox: "bui-MenuItemListBox";
        readonly itemListBoxCheck: "bui-MenuItemListBoxCheck";
        readonly itemWrapper: "bui-MenuItemWrapper";
        readonly itemContent: "bui-MenuItemContent";
        readonly itemArrow: "bui-MenuItemArrow";
        readonly separator: "bui-MenuSeparator";
        readonly searchField: "bui-MenuSearchField";
        readonly searchFieldInput: "bui-MenuSearchFieldInput";
        readonly searchFieldClear: "bui-MenuSearchFieldClear";
        readonly emptyState: "bui-MenuEmptyState";
    };
};

/** @public */
interface SearchFieldProps extends SearchFieldProps$1, Omit<FieldLabelProps, 'htmlFor' | 'id' | 'className'> {
    /**
     * An icon to render before the input
     */
    icon?: ReactNode | false;
    /**
     * The size of the text field
     * @defaultValue 'medium'
     */
    size?: 'small' | 'medium' | Partial<Record<Breakpoint, 'small' | 'medium'>>;
    /**
     * The placeholder text for the input
     */
    placeholder?: string;
    /**
     * Controls whether the SearchField starts in a collapsed state.
     */
    startCollapsed?: boolean;
}

/** @public */
declare const SearchField: react.ForwardRefExoticComponent<SearchFieldProps & react.RefAttributes<HTMLDivElement>>;

/**
 * Component definition for SearchField
 * @public
 */
declare const SearchFieldDefinition: {
    readonly classNames: {
        readonly root: "bui-SearchField";
        readonly clear: "bui-SearchFieldClear";
        readonly inputWrapper: "bui-SearchFieldInputWrapper";
        readonly input: "bui-SearchFieldInput";
        readonly inputIcon: "bui-SearchFieldInputIcon";
    };
    readonly dataAttributes: {
        readonly startCollapsed: readonly [true, false];
        readonly size: readonly ["small", "medium"];
    };
};

/** @public */
interface LinkProps extends LinkProps$1 {
    variant?: TextVariants | Partial<Record<Breakpoint, TextVariants>>;
    weight?: TextWeights | Partial<Record<Breakpoint, TextWeights>>;
    color?: TextColors | TextColorStatus | Partial<Record<Breakpoint, TextColors | TextColorStatus>>;
    truncate?: boolean;
}

/** @public */
declare const Link: react.ForwardRefExoticComponent<LinkProps & react.RefAttributes<HTMLAnchorElement>>;

/**
 * Component definition for Link
 * @public
 */
declare const LinkDefinition: {
    readonly classNames: {
        readonly root: "bui-Link";
    };
    readonly dataAttributes: {
        readonly variant: readonly ["subtitle", "body", "caption", "label"];
        readonly weight: readonly ["regular", "bold"];
        readonly color: readonly ["primary", "secondary", "danger", "warning", "success"];
        readonly truncate: readonly [true, false];
    };
};

/** @public */
type Option = {
    value: string;
    label: string;
    disabled?: boolean;
};
/** @public */
interface SelectProps<T extends 'single' | 'multiple'> extends SelectProps$1<Option, T>, Omit<FieldLabelProps, 'htmlFor' | 'id' | 'className'> {
    /**
     * An icon to render before the input
     */
    icon?: ReactNode;
    /**
     * The size of the select field
     * @defaultValue 'small'
     */
    size?: 'small' | 'medium' | Partial<Record<Breakpoint, 'small' | 'medium'>>;
    /**
     * The options of the select field
     */
    options?: Array<Option>;
    /**
     * Enable search/filter functionality in the dropdown
     * @defaultValue false
     */
    searchable?: boolean;
    /**
     * placeholder text for the search input
     * only used when searchable is true
     * @defaultvalue 'search...'
     */
    searchPlaceholder?: string;
    /**
     * Selection mode, single or multiple
     * @defaultvalue 'single'
     */
    selectionMode?: T;
}

/** @public */
declare const Select: react.ForwardRefExoticComponent<SelectProps<"multiple" | "single"> & react.RefAttributes<HTMLDivElement>>;

/**
 * Component definition for Select
 * @public
 */
declare const SelectDefinition: {
    readonly classNames: {
        readonly root: "bui-Select";
        readonly popover: "bui-SelectPopover";
        readonly trigger: "bui-SelectTrigger";
        readonly chevron: "bui-SelectTriggerChevron";
        readonly value: "bui-SelectValue";
        readonly list: "bui-SelectList";
        readonly item: "bui-SelectItem";
        readonly itemIndicator: "bui-SelectItemIndicator";
        readonly itemLabel: "bui-SelectItemLabel";
        readonly searchWrapper: "bui-SelectSearchWrapper";
        readonly search: "bui-SelectSearch";
        readonly searchClear: "bui-SelectSearchClear";
        readonly noResults: "bui-SelectNoResults";
    };
    readonly dataAttributes: {
        readonly size: readonly ["small", "medium"];
    };
};

/** @public */
interface SkeletonProps extends ComponentProps<'div'> {
    width?: number | string;
    height?: number | string;
    rounded?: boolean;
}

/** @public */
declare const Skeleton: (props: SkeletonProps) => react_jsx_runtime.JSX.Element;

/**
 * Component definition for Skeleton
 * @public
 */
declare const SkeletonDefinition: {
    readonly classNames: {
        readonly root: "bui-Skeleton";
    };
};

/** @public */
interface SwitchProps extends SwitchProps$1 {
    /**
     * The label of the switch
     */
    label?: string;
}

/** @public */
declare const Switch: react.ForwardRefExoticComponent<SwitchProps & react.RefAttributes<HTMLLabelElement>>;

/**
 * Component definition for Switch
 * @public
 */
declare const SwitchDefinition: {
    readonly classNames: {
        readonly root: "bui-Switch";
        readonly indicator: "bui-SwitchIndicator";
    };
};

/**
 * Properties for {@link VisuallyHidden}
 *
 * @public
 */
interface VisuallyHiddenProps extends ComponentProps<'div'> {
    children?: React.ReactNode;
}

/**
 * Visually hides content while keeping it accessible to screen readers.
 * Useful for descriptive labels and other screen-reader-only content.
 *
 * Note: This component is for content that should ALWAYS remain visually hidden.
 * For skip links that become visible on focus, use a different approach.
 *
 * @public
 */
declare const VisuallyHidden: (props: VisuallyHiddenProps) => react_jsx_runtime.JSX.Element;

/**
 * Component definition for VisuallyHidden
 * @public
 */
declare const VisuallyHiddenDefinition: {
    readonly classNames: {
        readonly root: "bui-VisuallyHidden";
    };
};

/** @public */
declare const useBreakpoint: () => {
    breakpoint: Breakpoint;
    up: (key: Breakpoint) => boolean;
    down: (key: Breakpoint) => boolean;
};

export { Accordion, AccordionDefinition, AccordionGroup, type AccordionGroupProps, AccordionPanel, type AccordionPanelProps, type AccordionProps, AccordionTrigger, type AccordionTriggerProps, type AlignItems, Avatar, AvatarDefinition, type AvatarProps, type Border, type BorderRadius, Box, BoxDefinition, type BoxProps, type Breakpoint, Button, ButtonDefinition, ButtonIcon, ButtonIconDefinition, type ButtonIconProps, ButtonLink, ButtonLinkDefinition, type ButtonLinkProps, type ButtonProps, Card, CardBody, type CardBodyProps, CardDefinition, CardFooter, type CardFooterProps, CardHeader, type CardHeaderProps, type CardProps, Cell, CellProfile, type CellProfileProps, type CellProps, Checkbox, CheckboxDefinition, type CheckboxProps, type ClassNamesMap, Column, type ColumnProps, type Columns, type ComponentDefinition, Container, ContainerDefinition, type ContainerProps, type DataAttributeValues, type DataAttributesMap, Dialog, DialogBody, type DialogBodyProps, DialogDefinition, DialogFooter, DialogHeader, type DialogHeaderProps, type DialogProps, DialogTrigger, type DialogTriggerProps, type Display, FieldLabel, FieldLabelDefinition, type FieldLabelProps, Flex, FlexDefinition, type FlexDirection, type FlexProps, type FlexWrap, Grid, GridDefinition, GridItemDefinition, type GridItemProps, type GridProps, Header, HeaderDefinition, HeaderPage, type HeaderPageBreadcrumb, HeaderPageDefinition, type HeaderPageProps, type HeaderProps, type HeaderTab, type JustifyContent, Link, LinkDefinition, type LinkProps, Menu, MenuAutocomplete, type MenuAutocompleteListBoxProps, MenuAutocompleteListbox, type MenuAutocompleteProps, MenuDefinition, MenuItem, type MenuItemProps, MenuListBox, MenuListBoxItem, type MenuListBoxItemProps, type MenuListBoxProps, type MenuProps, MenuSection, type MenuSectionProps, MenuSeparator, type MenuSeparatorProps, MenuTrigger, type MenuTriggerProps, type Option, Radio, RadioGroup, RadioGroupDefinition, type RadioGroupProps, type RadioProps, type Responsive, Row, SearchField, SearchFieldDefinition, type SearchFieldProps, Select, SelectDefinition, type SelectProps, Skeleton, SkeletonDefinition, type SkeletonProps, type Space, type SpaceProps, SubmenuTrigger, type SubmenuTriggerProps, Switch, SwitchDefinition, type SwitchProps, Tab, TabList, type TabListProps, type TabMatchStrategy, TabPanel, type TabPanelProps, type TabProps, Table, TableBody, TableDefinition, TableHeader, TablePagination, TablePaginationDefinition, type TablePaginationProps, Tabs, TabsDefinition, type TabsProps, Tag, TagGroup, TagGroupDefinition, type TagGroupProps, type TagProps, Text, type TextColorStatus, type TextColors, TextDefinition, TextField, TextFieldDefinition, type TextFieldProps, type TextOwnProps, type TextProps, type TextVariants, type TextWeights, Tooltip, TooltipDefinition, type TooltipProps, TooltipTrigger, type UseTableConfig, type UseTablePagination, type UseTablePaginationConfig, type UseTableResult, type UtilityProps, VisuallyHidden, VisuallyHiddenDefinition, type VisuallyHiddenProps, useBreakpoint, useTable };
