import { jsx, jsxs } from 'react/jsx-runtime';
import { MenuTrigger as MenuTrigger$1, SubmenuTrigger as SubmenuTrigger$1, OverlayTriggerStateContext, Menu as Menu$1, Popover, RouterProvider, Virtualizer, ListLayout, ListBox, useFilter, Autocomplete, SearchField, Input, Button, MenuItem as MenuItem$1, ListBoxItem, MenuSection as MenuSection$1, Header, Separator } from 'react-aria-components';
import { useStyles } from '../../hooks/useStyles.esm.js';
import { MenuDefinition } from './definition.esm.js';
import { RiCloseCircleLine, RiArrowRightSLine, RiCheckLine } from '@remixicon/react';
import { useNavigate, useHref } from 'react-router-dom';
import { isExternalLink } from '../../utils/isExternalLink.esm.js';
import { useRef, useContext, useEffect } from 'react';
import styles from './Menu.module.css.esm.js';
import clsx from 'clsx';

const rowHeight = 32;
const MenuEmptyState = () => {
  const { classNames } = useStyles(MenuDefinition);
  return /* @__PURE__ */ jsx("div", { className: clsx(classNames.emptyState, styles[classNames.emptyState]), children: "No results found." });
};
const MenuTrigger = (props) => {
  return /* @__PURE__ */ jsx(MenuTrigger$1, { ...props });
};
const SubmenuTrigger = (props) => {
  return /* @__PURE__ */ jsx(SubmenuTrigger$1, { ...props });
};
const Menu = (props) => {
  const { classNames, cleanedProps } = useStyles(MenuDefinition, props);
  const {
    className,
    placement = "bottom start",
    virtualized = false,
    maxWidth,
    maxHeight,
    style,
    ...rest
  } = cleanedProps;
  const navigate = useNavigate();
  let newMaxWidth = maxWidth || (virtualized ? "260px" : "undefined");
  const popoverRef = useRef(null);
  const state = useContext(OverlayTriggerStateContext);
  useEffect(() => {
    if (!state?.isOpen) return;
    const handleClickOutside = (event) => {
      const target = event.target;
      if (popoverRef.current && !popoverRef.current.contains(target)) {
        const isOnTrigger = target.closest("[data-trigger]");
        const isOnSubmenu = target.closest('[role="menu"]');
        if (!isOnTrigger && !isOnSubmenu) {
          state.close();
        }
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
    };
  }, [state]);
  const menuContent = /* @__PURE__ */ jsx(
    Menu$1,
    {
      className: clsx(classNames.content, styles[classNames.content]),
      renderEmptyState: () => /* @__PURE__ */ jsx(MenuEmptyState, {}),
      style: { width: newMaxWidth, maxHeight, ...style },
      ...rest
    }
  );
  return /* @__PURE__ */ jsx(
    Popover,
    {
      ref: popoverRef,
      className: clsx(
        classNames.popover,
        styles[classNames.popover],
        className
      ),
      placement,
      isNonModal: true,
      isKeyboardDismissDisabled: false,
      children: /* @__PURE__ */ jsx(RouterProvider, { navigate, useHref, children: virtualized ? /* @__PURE__ */ jsx(
        Virtualizer,
        {
          layout: ListLayout,
          layoutOptions: {
            rowHeight
          },
          children: menuContent
        }
      ) : menuContent })
    }
  );
};
const MenuListBox = (props) => {
  const { classNames, cleanedProps } = useStyles(MenuDefinition, props);
  const {
    className,
    selectionMode = "single",
    placement = "bottom start",
    virtualized = false,
    maxWidth,
    maxHeight,
    style,
    ...rest
  } = cleanedProps;
  let newMaxWidth = maxWidth || (virtualized ? "260px" : "undefined");
  const listBoxContent = /* @__PURE__ */ jsx(
    ListBox,
    {
      className: clsx(classNames.content, styles[classNames.content]),
      selectionMode,
      style: { width: newMaxWidth, maxHeight, ...style },
      ...rest
    }
  );
  return /* @__PURE__ */ jsx(
    Popover,
    {
      className: clsx(
        classNames.popover,
        styles[classNames.popover],
        className
      ),
      placement,
      children: virtualized ? /* @__PURE__ */ jsx(
        Virtualizer,
        {
          layout: ListLayout,
          layoutOptions: {
            rowHeight
          },
          children: listBoxContent
        }
      ) : listBoxContent
    }
  );
};
const MenuAutocomplete = (props) => {
  const { classNames, cleanedProps } = useStyles(MenuDefinition, props);
  const {
    className,
    placement = "bottom start",
    virtualized = false,
    maxWidth,
    maxHeight,
    style,
    ...rest
  } = cleanedProps;
  const { contains } = useFilter({ sensitivity: "base" });
  let newMaxWidth = maxWidth || (virtualized ? "260px" : "undefined");
  const navigate = useNavigate();
  const menuContent = /* @__PURE__ */ jsx(
    Menu$1,
    {
      className: clsx(classNames.content, styles[classNames.content]),
      renderEmptyState: () => /* @__PURE__ */ jsx(MenuEmptyState, {}),
      style: { width: newMaxWidth, maxHeight, ...style },
      ...rest
    }
  );
  return /* @__PURE__ */ jsx(
    Popover,
    {
      className: clsx(
        classNames.popover,
        styles[classNames.popover],
        className
      ),
      placement,
      children: /* @__PURE__ */ jsx(RouterProvider, { navigate, useHref, children: /* @__PURE__ */ jsxs(Autocomplete, { filter: contains, children: [
        /* @__PURE__ */ jsxs(
          SearchField,
          {
            className: clsx(
              classNames.searchField,
              styles[classNames.searchField]
            ),
            children: [
              /* @__PURE__ */ jsx(
                Input,
                {
                  className: clsx(
                    classNames.searchFieldInput,
                    styles[classNames.searchFieldInput]
                  ),
                  "aria-label": "Search",
                  placeholder: props.placeholder || "Search..."
                }
              ),
              /* @__PURE__ */ jsx(
                Button,
                {
                  className: clsx(
                    classNames.searchFieldClear,
                    styles[classNames.searchFieldClear]
                  ),
                  children: /* @__PURE__ */ jsx(RiCloseCircleLine, {})
                }
              )
            ]
          }
        ),
        virtualized ? /* @__PURE__ */ jsx(
          Virtualizer,
          {
            layout: ListLayout,
            layoutOptions: {
              rowHeight
            },
            children: menuContent
          }
        ) : menuContent
      ] }) })
    }
  );
};
const MenuAutocompleteListbox = (props) => {
  const { classNames, cleanedProps } = useStyles(MenuDefinition, props);
  const {
    className,
    selectionMode = "single",
    placement = "bottom start",
    virtualized = false,
    maxWidth,
    maxHeight,
    style,
    ...rest
  } = cleanedProps;
  const { contains } = useFilter({ sensitivity: "base" });
  let newMaxWidth = maxWidth || (virtualized ? "260px" : "undefined");
  const listBoxContent = /* @__PURE__ */ jsx(
    ListBox,
    {
      className: clsx(classNames.content, styles[classNames.content]),
      renderEmptyState: () => /* @__PURE__ */ jsx(MenuEmptyState, {}),
      selectionMode,
      style: { width: newMaxWidth, maxHeight, ...style },
      ...rest
    }
  );
  return /* @__PURE__ */ jsx(
    Popover,
    {
      className: clsx(
        classNames.popover,
        styles[classNames.popover],
        className
      ),
      placement,
      children: /* @__PURE__ */ jsxs(Autocomplete, { filter: contains, children: [
        /* @__PURE__ */ jsxs(
          SearchField,
          {
            className: clsx(
              classNames.searchField,
              styles[classNames.searchField]
            ),
            children: [
              /* @__PURE__ */ jsx(
                Input,
                {
                  className: clsx(
                    classNames.searchFieldInput,
                    styles[classNames.searchFieldInput]
                  ),
                  "aria-label": "Search",
                  placeholder: props.placeholder || "Search..."
                }
              ),
              /* @__PURE__ */ jsx(
                Button,
                {
                  className: clsx(
                    classNames.searchFieldClear,
                    styles[classNames.searchFieldClear]
                  ),
                  children: /* @__PURE__ */ jsx(RiCloseCircleLine, {})
                }
              )
            ]
          }
        ),
        virtualized ? /* @__PURE__ */ jsx(
          Virtualizer,
          {
            layout: ListLayout,
            layoutOptions: {
              rowHeight
            },
            children: listBoxContent
          }
        ) : listBoxContent
      ] })
    }
  );
};
const MenuItem = (props) => {
  const { classNames, cleanedProps } = useStyles(MenuDefinition, props);
  const {
    className,
    iconStart,
    color = "primary",
    children,
    href,
    ...rest
  } = cleanedProps;
  const isLink = href !== void 0;
  const isExternal = isExternalLink(href);
  if (isLink && isExternal) {
    return /* @__PURE__ */ jsx(
      MenuItem$1,
      {
        className: clsx(classNames.item, styles[classNames.item], className),
        "data-color": color,
        textValue: typeof children === "string" ? children : void 0,
        onAction: () => window.open(href, "_blank", "noopener,noreferrer"),
        ...rest,
        children: /* @__PURE__ */ jsxs(
          "div",
          {
            className: clsx(
              classNames.itemWrapper,
              styles[classNames.itemWrapper]
            ),
            children: [
              /* @__PURE__ */ jsxs(
                "div",
                {
                  className: clsx(
                    classNames.itemContent,
                    styles[classNames.itemContent]
                  ),
                  children: [
                    iconStart,
                    children
                  ]
                }
              ),
              /* @__PURE__ */ jsx(
                "div",
                {
                  className: clsx(classNames.itemArrow, styles[classNames.itemArrow]),
                  children: /* @__PURE__ */ jsx(RiArrowRightSLine, {})
                }
              )
            ]
          }
        )
      }
    );
  }
  return /* @__PURE__ */ jsx(
    MenuItem$1,
    {
      className: clsx(classNames.item, styles[classNames.item], className),
      "data-color": color,
      href,
      textValue: typeof children === "string" ? children : void 0,
      ...rest,
      children: /* @__PURE__ */ jsxs(
        "div",
        {
          className: clsx(classNames.itemWrapper, styles[classNames.itemWrapper]),
          children: [
            /* @__PURE__ */ jsxs(
              "div",
              {
                className: clsx(
                  classNames.itemContent,
                  styles[classNames.itemContent]
                ),
                children: [
                  iconStart,
                  children
                ]
              }
            ),
            /* @__PURE__ */ jsx(
              "div",
              {
                className: clsx(classNames.itemArrow, styles[classNames.itemArrow]),
                children: /* @__PURE__ */ jsx(RiArrowRightSLine, {})
              }
            )
          ]
        }
      )
    }
  );
};
const MenuListBoxItem = (props) => {
  const { classNames, cleanedProps } = useStyles(MenuDefinition, props);
  const { children, className, ...rest } = cleanedProps;
  return /* @__PURE__ */ jsx(
    ListBoxItem,
    {
      textValue: typeof props.children === "string" ? props.children : void 0,
      className: clsx(
        classNames.itemListBox,
        styles[classNames.itemListBox],
        className
      ),
      ...rest,
      children: /* @__PURE__ */ jsx(
        "div",
        {
          className: clsx(classNames.itemWrapper, styles[classNames.itemWrapper]),
          children: /* @__PURE__ */ jsxs(
            "div",
            {
              className: clsx(
                classNames.itemContent,
                styles[classNames.itemContent]
              ),
              children: [
                /* @__PURE__ */ jsx(
                  "div",
                  {
                    className: clsx(
                      classNames.itemListBoxCheck,
                      styles[classNames.itemListBoxCheck]
                    ),
                    children: /* @__PURE__ */ jsx(RiCheckLine, {})
                  }
                ),
                children
              ]
            }
          )
        }
      )
    }
  );
};
const MenuSection = (props) => {
  const { classNames, cleanedProps } = useStyles(MenuDefinition, props);
  const { children, className, title, ...rest } = cleanedProps;
  return /* @__PURE__ */ jsxs(
    MenuSection$1,
    {
      className: clsx(
        classNames.section,
        styles[classNames.section],
        className
      ),
      ...rest,
      children: [
        /* @__PURE__ */ jsx(
          Header,
          {
            className: clsx(
              classNames.sectionHeader,
              styles[classNames.sectionHeader]
            ),
            children: title
          }
        ),
        children
      ]
    }
  );
};
const MenuSeparator = (props) => {
  const { classNames, cleanedProps } = useStyles(MenuDefinition, props);
  const { className, ...rest } = cleanedProps;
  return /* @__PURE__ */ jsx(
    Separator,
    {
      className: clsx(
        classNames.separator,
        styles[classNames.separator],
        className
      ),
      ...rest
    }
  );
};

export { Menu, MenuAutocomplete, MenuAutocompleteListbox, MenuItem, MenuListBox, MenuListBoxItem, MenuSection, MenuSeparator, MenuTrigger, SubmenuTrigger };
//# sourceMappingURL=Menu.esm.js.map
