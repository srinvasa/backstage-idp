import { jsx, jsxs } from 'react/jsx-runtime';
import { createContext, useRef, useState, Children, isValidElement, cloneElement, useContext } from 'react';
import { useNavigate, useLocation, useHref } from 'react-router-dom';
import { TabsIndicators } from './TabsIndicators.esm.js';
import { RouterProvider, Tabs as Tabs$1, TabList as TabList$1, Tab as Tab$1, TabPanel as TabPanel$1 } from 'react-aria-components';
import { useStyles } from '../../hooks/useStyles.esm.js';
import { TabsDefinition } from './definition.esm.js';
import styles from './Tabs.module.css.esm.js';
import clsx from 'clsx';

const TabsContext = createContext(void 0);
const useTabsContext = () => {
  const context = useContext(TabsContext);
  if (!context) {
    throw new Error("Tab components must be used within a Tabs component");
  }
  return context;
};
const isTabActive = (tabHref, currentPathname, matchStrategy) => {
  if (matchStrategy === "exact") {
    return tabHref === currentPathname;
  }
  if (tabHref === currentPathname) {
    return true;
  }
  return currentPathname.startsWith(`${tabHref}/`);
};
const Tabs = (props) => {
  const { classNames, cleanedProps } = useStyles(TabsDefinition, props);
  const { className, children, ...rest } = cleanedProps;
  const tabsRef = useRef(null);
  const tabRefs = useRef(/* @__PURE__ */ new Map());
  const [hoveredKey, setHoveredKey] = useState(null);
  const prevHoveredKey = useRef(null);
  let navigate = useNavigate();
  const location = useLocation();
  const setTabRef = (key, element) => {
    if (element) {
      tabRefs.current.set(key, element);
    } else {
      tabRefs.current.delete(key);
    }
  };
  const computedSelectedKey = (() => {
    const childrenArray = Children.toArray(children);
    for (const child of childrenArray) {
      if (isValidElement(child) && child.type === TabList) {
        const tabListChildren = Children.toArray(child.props.children);
        for (const tabChild of tabListChildren) {
          if (isValidElement(tabChild) && tabChild.props.href) {
            const strategy = tabChild.props.matchStrategy || "exact";
            if (isTabActive(tabChild.props.href, location.pathname, strategy)) {
              return tabChild.props.id;
            }
          }
        }
        const allTabsHaveHref = tabListChildren.every(
          (child2) => isValidElement(child2) && child2.props.href
        );
        if (allTabsHaveHref) {
          return null;
        } else {
          return void 0;
        }
      }
    }
    return void 0;
  })();
  if (!children) return null;
  const contextValue = {
    tabsRef,
    tabRefs,
    hoveredKey,
    prevHoveredKey,
    setHoveredKey,
    setTabRef
  };
  return /* @__PURE__ */ jsx(TabsContext.Provider, { value: contextValue, children: /* @__PURE__ */ jsx(RouterProvider, { navigate, useHref, children: /* @__PURE__ */ jsx(
    Tabs$1,
    {
      className: clsx(classNames.tabs, styles[classNames.tabs], className),
      keyboardActivation: "manual",
      selectedKey: computedSelectedKey,
      ref: tabsRef,
      ...rest,
      children
    }
  ) }) });
};
const TabList = (props) => {
  const { classNames, cleanedProps } = useStyles(TabsDefinition, props);
  const { className, children, ...rest } = cleanedProps;
  const { setHoveredKey, tabRefs, tabsRef, hoveredKey, prevHoveredKey } = useTabsContext();
  const handleHover = (key) => {
    setHoveredKey(key);
  };
  const enhancedChildren = Children.map(children, (child) => {
    if (isValidElement(child)) {
      return cloneElement(child, {
        onHoverStart: () => handleHover(child.props.id),
        onHoverEnd: () => handleHover(null)
      });
    }
    return child;
  });
  return /* @__PURE__ */ jsxs(
    "div",
    {
      className: clsx(
        classNames.tabListWrapper,
        styles[classNames.tabListWrapper],
        className
      ),
      children: [
        /* @__PURE__ */ jsx(
          TabList$1,
          {
            className: clsx(classNames.tabList, styles[classNames.tabList]),
            "aria-label": "Toolbar tabs",
            ...rest,
            children: enhancedChildren
          }
        ),
        /* @__PURE__ */ jsx(
          TabsIndicators,
          {
            tabRefs,
            tabsRef,
            hoveredKey,
            prevHoveredKey
          }
        )
      ]
    }
  );
};
const Tab = (props) => {
  const { classNames, cleanedProps } = useStyles(TabsDefinition, props);
  const {
    className,
    href,
    children,
    id,
    matchStrategy: _matchStrategy,
    ...rest
  } = cleanedProps;
  const { setTabRef } = useTabsContext();
  return /* @__PURE__ */ jsx(
    Tab$1,
    {
      id,
      className: clsx(classNames.tab, styles[classNames.tab], className),
      ref: (el) => setTabRef(id, el),
      href,
      ...rest,
      children
    }
  );
};
const TabPanel = (props) => {
  const { classNames, cleanedProps } = useStyles(TabsDefinition, props);
  const { className, children, ...rest } = cleanedProps;
  return /* @__PURE__ */ jsx(
    TabPanel$1,
    {
      className: clsx(classNames.panel, styles[classNames.panel], className),
      ...rest,
      children
    }
  );
};

export { Tab, TabList, TabPanel, Tabs };
//# sourceMappingURL=Tabs.esm.js.map
