import { routeRefType } from './types.esm.js';

class ExternalRouteRefImpl {
  [routeRefType] = "external";
  id;
  params;
  optional;
  defaultTarget;
  constructor(id, params, optional, defaultTarget) {
    this.id = id;
    this.params = params;
    this.optional = optional;
    this.defaultTarget = defaultTarget;
  }
  toString() {
    if (this.#nfsId) {
      return `externalRouteRef{id=${this.#nfsId},legacyId=${this.id}}`;
    }
    return `routeRef{type=external,id=${this.id}}`;
  }
  getDefaultTarget() {
    return this.defaultTarget;
  }
  // NFS implementation below
  $$type = "@backstage/ExternalRouteRef";
  version = "v1";
  T = void 0;
  #nfsId = void 0;
  getParams() {
    return this.params;
  }
  getDescription() {
    if (this.#nfsId) {
      return this.#nfsId;
    }
    return this.id;
  }
  setId(newId) {
    if (!newId) {
      throw new Error(`ExternalRouteRef id must be a non-empty string`);
    }
    if (this.#nfsId && this.#nfsId !== newId) {
      throw new Error(
        `ExternalRouteRef was referenced twice as both '${this.#nfsId}' and '${newId}'`
      );
    }
    this.#nfsId = newId;
  }
}
function createExternalRouteRef(options) {
  return new ExternalRouteRefImpl(
    options.id,
    options.params ?? [],
    Boolean(options.optional),
    options?.defaultTarget
  );
}

export { ExternalRouteRefImpl, createExternalRouteRef };
//# sourceMappingURL=ExternalRouteRef.esm.js.map
