import { routeRefType } from './types.esm.js';

const PARAM_PATTERN = /^\w+$/;
class SubRouteRefImpl {
  [routeRefType] = "sub";
  id;
  path;
  parent;
  params;
  constructor(id, path, parent, params) {
    this.id = id;
    this.path = path;
    this.parent = parent;
    this.params = params;
  }
  toString() {
    return `routeRef{type=sub,id=${this.id}}`;
  }
  // NFS implementation below
  $$type = "@backstage/SubRouteRef";
  version = "v1";
  T = void 0;
  getParams() {
    return this.params;
  }
  getParent() {
    return this.parent;
  }
  getDescription() {
    return `at ${this.path} with parent ${this.parent}`;
  }
}
function createSubRouteRef(config) {
  const { id, path, parent } = config;
  const pathParams = path.split("/").filter((p) => p.startsWith(":")).map((p) => p.substring(1));
  const params = [...parent.params, ...pathParams];
  if (parent.params.some((p) => pathParams.includes(p))) {
    throw new Error(
      "SubRouteRef may not have params that overlap with its parent"
    );
  }
  if (!path.startsWith("/")) {
    throw new Error(`SubRouteRef path must start with '/', got '${path}'`);
  }
  if (path.endsWith("/")) {
    throw new Error(`SubRouteRef path must not end with '/', got '${path}'`);
  }
  for (const param of pathParams) {
    if (!PARAM_PATTERN.test(param)) {
      throw new Error(`SubRouteRef path has invalid param, got '${param}'`);
    }
  }
  const subRouteRef = new SubRouteRefImpl(
    id,
    path,
    parent,
    params
  );
  return subRouteRef;
}

export { SubRouteRefImpl, createSubRouteRef };
//# sourceMappingURL=SubRouteRef.esm.js.map
