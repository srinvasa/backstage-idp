{"version":3,"file":"RouteRef.esm.js","sources":["../../src/routing/RouteRef.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { OpaqueRouteRef } from '@internal/frontend';\nimport { describeParentCallSite } from './describeParentCallSite';\nimport { AnyRouteRefParams } from './types';\n\n/**\n * Absolute route reference.\n *\n * @remarks\n *\n * See {@link https://backstage.io/docs/plugins/composability#routing-system}.\n *\n * @public\n */\nexport interface RouteRef<\n  TParams extends AnyRouteRefParams = AnyRouteRefParams,\n> {\n  readonly $$type: '@backstage/RouteRef';\n  readonly T: TParams;\n}\n\n/**\n * Create a {@link RouteRef} from a route descriptor.\n *\n * @param config - Description of the route reference to be created.\n * @public\n */\nexport function createRouteRef<\n  // Params is the type that we care about and the one to be embedded in the route ref.\n  // For example, given the params ['name', 'kind'], Params will be {name: string, kind: string}\n  TParams extends { [param in TParamKeys]: string } | undefined = undefined,\n  TParamKeys extends string = string,\n>(config?: {\n  /** A list of parameter names that the path that this route ref is bound to must contain */\n  readonly params?: string extends TParamKeys\n    ? (keyof TParams)[]\n    : TParamKeys[];\n\n  aliasFor?: string;\n}): RouteRef<\n  keyof TParams extends never\n    ? undefined\n    : string extends TParamKeys\n    ? TParams\n    : { [param in TParamKeys]: string }\n> {\n  const params = (config?.params ?? []) as string[];\n  const creationSite = describeParentCallSite();\n\n  let id: string | undefined = undefined;\n\n  return OpaqueRouteRef.createInstance('v1', {\n    T: undefined as unknown as TParams,\n    getParams() {\n      return params;\n    },\n    getDescription() {\n      if (id) {\n        return id;\n      }\n      return `created at '${creationSite}'`;\n    },\n    alias: config?.aliasFor,\n    setId(newId: string) {\n      if (!newId) {\n        throw new Error(`RouteRef id must be a non-empty string`);\n      }\n      if (id && id !== newId) {\n        throw new Error(\n          `RouteRef was referenced twice as both '${id}' and '${newId}'`,\n        );\n      }\n      id = newId;\n    },\n    toString(): string {\n      return `routeRef{id=${id},at='${creationSite}'}`;\n    },\n  });\n}\n"],"names":[],"mappings":";;;;;AA0CO,SAAS,eAKd,MAAA,EAaA;AACA,EAAA,MAAM,MAAA,GAAU,MAAA,EAAQ,MAAA,IAAU,EAAC;AACnC,EAAA,MAAM,eAAe,sBAAA,EAAuB;AAE5C,EAAA,IAAI,EAAA,GAAyB,MAAA;AAE7B,EAAA,OAAO,cAAA,CAAe,eAAe,IAAA,EAAM;AAAA,IACzC,CAAA,EAAG,MAAA;AAAA,IACH,SAAA,GAAY;AACV,MAAA,OAAO,MAAA;AAAA,IACT,CAAA;AAAA,IACA,cAAA,GAAiB;AACf,MAAA,IAAI,EAAA,EAAI;AACN,QAAA,OAAO,EAAA;AAAA,MACT;AACA,MAAA,OAAO,eAAe,YAAY,CAAA,CAAA,CAAA;AAAA,IACpC,CAAA;AAAA,IACA,OAAO,MAAA,EAAQ,QAAA;AAAA,IACf,MAAM,KAAA,EAAe;AACnB,MAAA,IAAI,CAAC,KAAA,EAAO;AACV,QAAA,MAAM,IAAI,MAAM,CAAA,sCAAA,CAAwC,CAAA;AAAA,MAC1D;AACA,MAAA,IAAI,EAAA,IAAM,OAAO,KAAA,EAAO;AACtB,QAAA,MAAM,IAAI,KAAA;AAAA,UACR,CAAA,uCAAA,EAA0C,EAAE,CAAA,OAAA,EAAU,KAAK,CAAA,CAAA;AAAA,SAC7D;AAAA,MACF;AACA,MAAA,EAAA,GAAK,KAAA;AAAA,IACP,CAAA;AAAA,IACA,QAAA,GAAmB;AACjB,MAAA,OAAO,CAAA,YAAA,EAAe,EAAE,CAAA,KAAA,EAAQ,YAAY,CAAA,EAAA,CAAA;AAAA,IAC9C;AAAA,GACD,CAAA;AACH;;;;"}