{"version":3,"file":"SubRouteRef.esm.js","sources":["../../src/routing/SubRouteRef.ts"],"sourcesContent":["/*\n * Copyright 2020 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { OpaqueRouteRef, OpaqueSubRouteRef } from '@internal/frontend';\nimport { RouteRef } from './RouteRef';\nimport { AnyRouteRefParams } from './types';\n\n// Should match the pattern in react-router\nconst PARAM_PATTERN = /^\\w+$/;\n\n/**\n * Descriptor of a route relative to an absolute {@link RouteRef}.\n *\n * @remarks\n *\n * See {@link https://backstage.io/docs/plugins/composability#routing-system}.\n *\n * @public\n */\nexport interface SubRouteRef<\n  TParams extends AnyRouteRefParams = AnyRouteRefParams,\n> {\n  readonly $$type: '@backstage/SubRouteRef';\n\n  readonly T: TParams;\n\n  readonly path: string;\n}\n\n/** @internal */\nexport interface InternalSubRouteRef<\n  TParams extends AnyRouteRefParams = AnyRouteRefParams,\n> extends SubRouteRef<TParams> {\n  readonly version: 'v1';\n\n  getParams(): string[];\n  getParent(): RouteRef;\n  getDescription(): string;\n}\n\n/**\n * Used in {@link PathParams} type declaration.\n * @ignore\n */\ntype ParamPart<S extends string> = S extends `:${infer Param}` ? Param : never;\n\n/**\n * Used in {@link PathParams} type declaration.\n * @ignore\n */\ntype ParamNames<S extends string> = S extends `${infer Part}/${infer Rest}`\n  ? ParamPart<Part> | ParamNames<Rest>\n  : ParamPart<S>;\n/**\n * This utility type helps us infer a Param object type from a string path\n * For example, `/foo/:bar/:baz` inferred to `{ bar: string, baz: string }`\n * @ignore\n */\ntype PathParams<S extends string> = { [name in ParamNames<S>]: string };\n\n/**\n * Merges a param object type with an optional params type into a params object.\n * @ignore\n */\ntype MergeParams<\n  P1 extends { [param in string]: string },\n  P2 extends AnyRouteRefParams,\n> = (P1[keyof P1] extends never ? {} : P1) & (P2 extends undefined ? {} : P2);\n\n/**\n * Convert empty params to undefined.\n * @ignore\n */\ntype TrimEmptyParams<Params extends { [param in string]: string }> =\n  keyof Params extends never ? undefined : Params;\n\n/**\n * Creates a SubRouteRef type given the desired parameters and parent route parameters.\n * The parameters types are merged together while ensuring that there is no overlap between the two.\n *\n * @ignore\n */\ntype MakeSubRouteRef<\n  Params extends { [param in string]: string },\n  ParentParams extends AnyRouteRefParams,\n> = keyof Params & keyof ParentParams extends never\n  ? SubRouteRef<TrimEmptyParams<MergeParams<Params, ParentParams>>>\n  : never;\n\n/**\n * Create a {@link SubRouteRef} from a route descriptor.\n *\n * @param config - Description of the route reference to be created.\n * @public\n */\nexport function createSubRouteRef<\n  Path extends string,\n  ParentParams extends AnyRouteRefParams = never,\n>(config: {\n  path: Path;\n  parent: RouteRef<ParentParams>;\n}): MakeSubRouteRef<PathParams<Path>, ParentParams> {\n  const { path, parent } = config;\n  type Params = PathParams<Path>;\n\n  const internalParent = OpaqueRouteRef.toInternal(parent);\n  const parentParams = internalParent.getParams();\n  const parentDescription = internalParent.getDescription();\n\n  // Collect runtime parameters from the path, e.g. ['bar', 'baz'] from '/foo/:bar/:baz'\n  const pathParams = path\n    .split('/')\n    .filter(p => p.startsWith(':'))\n    .map(p => p.substring(1));\n  const params = [...parentParams, ...pathParams];\n\n  if (parentParams.some(p => pathParams.includes(p as string))) {\n    throw new Error(\n      'SubRouteRef may not have params that overlap with its parent',\n    );\n  }\n  if (!path.startsWith('/')) {\n    throw new Error(`SubRouteRef path must start with '/', got '${path}'`);\n  }\n  if (path.endsWith('/')) {\n    throw new Error(`SubRouteRef path must not end with '/', got '${path}'`);\n  }\n  for (const param of pathParams) {\n    if (!PARAM_PATTERN.test(param)) {\n      throw new Error(`SubRouteRef path has invalid param, got '${param}'`);\n    }\n  }\n\n  return OpaqueSubRouteRef.createInstance('v1', {\n    T: undefined as unknown as TrimEmptyParams<\n      MergeParams<Params, ParentParams>\n    >,\n    path,\n    getParams() {\n      return params;\n    },\n    getParent() {\n      return parent;\n    },\n    getDescription() {\n      return `at ${path} with parent ${parentDescription}`;\n    },\n    toString() {\n      return `subRouteRef{path='${path}',parent=${parent}}`;\n    },\n  });\n}\n"],"names":[],"mappings":";;;;AAqBA,MAAM,aAAA,GAAgB,OAAA;AAuFf,SAAS,kBAGd,MAAA,EAGkD;AAClD,EAAA,MAAM,EAAE,IAAA,EAAM,MAAA,EAAO,GAAI,MAAA;AAGzB,EAAA,MAAM,cAAA,GAAiB,cAAA,CAAe,UAAA,CAAW,MAAM,CAAA;AACvD,EAAA,MAAM,YAAA,GAAe,eAAe,SAAA,EAAU;AAC9C,EAAA,MAAM,iBAAA,GAAoB,eAAe,cAAA,EAAe;AAGxD,EAAA,MAAM,aAAa,IAAA,CAChB,KAAA,CAAM,GAAG,CAAA,CACT,OAAO,CAAA,CAAA,KAAK,CAAA,CAAE,UAAA,CAAW,GAAG,CAAC,CAAA,CAC7B,GAAA,CAAI,OAAK,CAAA,CAAE,SAAA,CAAU,CAAC,CAAC,CAAA;AAC1B,EAAA,MAAM,MAAA,GAAS,CAAC,GAAG,YAAA,EAAc,GAAG,UAAU,CAAA;AAE9C,EAAA,IAAI,aAAa,IAAA,CAAK,CAAA,CAAA,KAAK,WAAW,QAAA,CAAS,CAAW,CAAC,CAAA,EAAG;AAC5D,IAAA,MAAM,IAAI,KAAA;AAAA,MACR;AAAA,KACF;AAAA,EACF;AACA,EAAA,IAAI,CAAC,IAAA,CAAK,UAAA,CAAW,GAAG,CAAA,EAAG;AACzB,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,2CAAA,EAA8C,IAAI,CAAA,CAAA,CAAG,CAAA;AAAA,EACvE;AACA,EAAA,IAAI,IAAA,CAAK,QAAA,CAAS,GAAG,CAAA,EAAG;AACtB,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,6CAAA,EAAgD,IAAI,CAAA,CAAA,CAAG,CAAA;AAAA,EACzE;AACA,EAAA,KAAA,MAAW,SAAS,UAAA,EAAY;AAC9B,IAAA,IAAI,CAAC,aAAA,CAAc,IAAA,CAAK,KAAK,CAAA,EAAG;AAC9B,MAAA,MAAM,IAAI,KAAA,CAAM,CAAA,yCAAA,EAA4C,KAAK,CAAA,CAAA,CAAG,CAAA;AAAA,IACtE;AAAA,EACF;AAEA,EAAA,OAAO,iBAAA,CAAkB,eAAe,IAAA,EAAM;AAAA,IAC5C,CAAA,EAAG,MAAA;AAAA,IAGH,IAAA;AAAA,IACA,SAAA,GAAY;AACV,MAAA,OAAO,MAAA;AAAA,IACT,CAAA;AAAA,IACA,SAAA,GAAY;AACV,MAAA,OAAO,MAAA;AAAA,IACT,CAAA;AAAA,IACA,cAAA,GAAiB;AACf,MAAA,OAAO,CAAA,GAAA,EAAM,IAAI,CAAA,aAAA,EAAgB,iBAAiB,CAAA,CAAA;AAAA,IACpD,CAAA;AAAA,IACA,QAAA,GAAW;AACT,MAAA,OAAO,CAAA,kBAAA,EAAqB,IAAI,CAAA,SAAA,EAAY,MAAM,CAAA,CAAA,CAAA;AAAA,IACpD;AAAA,GACD,CAAA;AACH;;;;"}