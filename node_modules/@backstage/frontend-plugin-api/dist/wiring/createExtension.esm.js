import { resolveInputOverrides } from './resolveInputOverrides.esm.js';
import { createSchemaFromZod } from '../schema/createSchemaFromZod.esm.js';
import { OpaqueExtensionDefinition } from '../frontend-internal/src/wiring/InternalExtensionDefinition.esm.js';
import { createExtensionDataContainer } from '../frontend-internal/src/wiring/createExtensionDataContainer.esm.js';
import { OpaqueExtensionInput } from '../frontend-internal/src/wiring/InternalExtensionInput.esm.js';
import '../frontend-internal/src/wiring/InternalFrontendPlugin.esm.js';
import '../frontend-internal/src/wiring/InternalSwappableComponentRef.esm.js';

const ctxParamsSymbol = Symbol("params");
function bindInputs(inputs, kind, name) {
  if (!inputs) {
    return {};
  }
  return Object.fromEntries(
    Object.entries(inputs).map(([inputName, input]) => [
      inputName,
      OpaqueExtensionInput.toInternal(input).withContext({
        kind,
        name,
        input: inputName
      })
    ])
  );
}
function createExtension(options) {
  const schemaDeclaration = options.config?.schema;
  const configSchema = schemaDeclaration && createSchemaFromZod(
    (innerZ) => innerZ.object(
      Object.fromEntries(
        Object.entries(schemaDeclaration).map(([k, v]) => [k, v(innerZ)])
      )
    )
  );
  return OpaqueExtensionDefinition.createInstance("v2", {
    T: void 0,
    kind: options.kind,
    name: options.name,
    attachTo: options.attachTo,
    disabled: options.disabled ?? false,
    inputs: bindInputs(options.inputs, options.kind, options.name),
    output: options.output,
    configSchema,
    factory: options.factory,
    toString() {
      const parts = [];
      if (options.kind) {
        parts.push(`kind=${options.kind}`);
      }
      if (options.name) {
        parts.push(`name=${options.name}`);
      }
      const attachTo = [options.attachTo].flat().map((aAny) => {
        const a = aAny;
        if (OpaqueExtensionInput.isType(a)) {
          const { context } = OpaqueExtensionInput.toInternal(a);
          if (!context) {
            return "<detached-input>";
          }
          let id = "<plugin>";
          if (context?.kind) {
            id = `${context?.kind}:${id}`;
          }
          if (context?.name) {
            id = `${id}/${context?.name}`;
          }
          return `${id}@${context.input}`;
        }
        if ("relative" in a && a.relative) {
          let id = "<plugin>";
          if (a.relative.kind) {
            id = `${a.relative.kind}:${id}`;
          }
          if (a.relative.name) {
            id = `${id}/${a.relative.name}`;
          }
          return `${id}@${a.input}`;
        }
        if ("id" in a) {
          return `${a.id}@${a.input}`;
        }
        throw new Error("Invalid attachment point specification");
      }).join("+");
      parts.push(`attachTo=${attachTo}`);
      return `ExtensionDefinition{${parts.join(",")}}`;
    },
    override(overrideOptions) {
      if (!Array.isArray(options.output)) {
        throw new Error(
          "Cannot override an extension that is not declared using the new format with outputs as an array"
        );
      }
      if (overrideOptions.output && !overrideOptions.factory) {
        throw new Error(
          "Refused to override output without also overriding factory"
        );
      }
      if (overrideOptions.params && overrideOptions.factory) {
        throw new Error(
          "Refused to override params and factory at the same time"
        );
      }
      return createExtension({
        kind: options.kind,
        name: options.name,
        attachTo: overrideOptions.attachTo ?? options.attachTo,
        disabled: overrideOptions.disabled ?? options.disabled,
        inputs: bindInputs(
          {
            ...options.inputs ?? {},
            ...overrideOptions.inputs ?? {}
          },
          options.kind,
          options.name
        ),
        output: overrideOptions.output ?? options.output,
        config: options.config || overrideOptions.config ? {
          schema: {
            ...options.config?.schema,
            ...overrideOptions.config?.schema
          }
        } : void 0,
        factory: ({ node, apis, config, inputs }) => {
          if (!overrideOptions.factory) {
            return options.factory({
              node,
              apis,
              config,
              inputs,
              [ctxParamsSymbol]: overrideOptions.params
            });
          }
          const parentResult = overrideOptions.factory(
            (innerContext) => {
              return createExtensionDataContainer(
                options.factory({
                  node,
                  apis,
                  config: innerContext?.config ?? config,
                  inputs: resolveInputOverrides(
                    options.inputs,
                    inputs,
                    innerContext?.inputs
                  ),
                  [ctxParamsSymbol]: innerContext?.params
                }),
                "original extension factory",
                options.output
              );
            },
            {
              node,
              apis,
              config,
              inputs
            }
          );
          if (typeof parentResult !== "object" || !parentResult?.[Symbol.iterator]) {
            throw new Error(
              "extension factory override did not provide an iterable object"
            );
          }
          const deduplicatedResult = /* @__PURE__ */ new Map();
          for (const item of parentResult) {
            deduplicatedResult.set(item.id, item);
          }
          return deduplicatedResult.values();
        }
      });
    }
  });
}

export { createExtension, ctxParamsSymbol };
//# sourceMappingURL=createExtension.esm.js.map
