{"version":3,"file":"createExtension.esm.js","sources":["../../src/wiring/createExtension.ts"],"sourcesContent":["/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ApiHolder, AppNode } from '../apis';\nimport { Expand } from '@backstage/types';\nimport {\n  ResolvedInputValueOverrides,\n  resolveInputOverrides,\n} from './resolveInputOverrides';\nimport {\n  createExtensionDataContainer,\n  OpaqueExtensionInput,\n} from '@internal/frontend';\nimport { ExtensionDataRef, ExtensionDataValue } from './createExtensionDataRef';\nimport { ExtensionInput } from './createExtensionInput';\nimport { z } from 'zod';\nimport { createSchemaFromZod } from '../schema/createSchemaFromZod';\nimport { OpaqueExtensionDefinition } from '@internal/frontend';\nimport { ExtensionDataContainer } from './types';\nimport {\n  ExtensionBlueprint,\n  ExtensionBlueprintDefineParams,\n} from './createExtensionBlueprint';\nimport { FrontendPlugin } from './createFrontendPlugin';\nimport { FrontendModule } from './createFrontendModule';\n\n/**\n * This symbol is used to pass parameter overrides from the extension override to the blueprint factory\n * @internal\n */\nexport const ctxParamsSymbol = Symbol('params');\n\n/**\n * Convert a single extension input into a matching resolved input.\n * @public\n */\nexport type ResolvedExtensionInput<TExtensionInput extends ExtensionInput> =\n  TExtensionInput['extensionData'] extends Array<ExtensionDataRef>\n    ? {\n        node: AppNode;\n      } & ExtensionDataContainer<TExtensionInput['extensionData'][number]>\n    : never;\n\n/**\n * Converts an extension input map into a matching collection of resolved inputs.\n * @public\n */\nexport type ResolvedExtensionInputs<\n  TInputs extends {\n    [name in string]: ExtensionInput;\n  },\n> = {\n  [InputName in keyof TInputs]: false extends TInputs[InputName]['config']['singleton']\n    ? Array<Expand<ResolvedExtensionInput<TInputs[InputName]>>>\n    : false extends TInputs[InputName]['config']['optional']\n    ? Expand<ResolvedExtensionInput<TInputs[InputName]>>\n    : Expand<ResolvedExtensionInput<TInputs[InputName]> | undefined>;\n};\n\ntype ToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n  k: infer I,\n) => void\n  ? I\n  : never;\n\ntype PopUnion<U> = ToIntersection<\n  U extends any ? () => U : never\n> extends () => infer R\n  ? [rest: Exclude<U, R>, next: R]\n  : undefined;\n\n/** @ignore */\ntype JoinStringUnion<\n  U,\n  TDiv extends string = ', ',\n  TResult extends string = '',\n> = PopUnion<U> extends [infer IRest extends string, infer INext extends string]\n  ? TResult extends ''\n    ? JoinStringUnion<IRest, TDiv, INext>\n    : JoinStringUnion<IRest, TDiv, `${TResult}${TDiv}${INext}`>\n  : TResult;\n\n/** @ignore */\nexport type RequiredExtensionIds<UExtensionData extends ExtensionDataRef> =\n  UExtensionData extends any\n    ? UExtensionData['config']['optional'] extends true\n      ? never\n      : UExtensionData['id']\n    : never;\n\n/** @ignore */\nexport type VerifyExtensionFactoryOutput<\n  UDeclaredOutput extends ExtensionDataRef,\n  UFactoryOutput extends ExtensionDataValue<any, any>,\n> = [RequiredExtensionIds<UDeclaredOutput>] extends [UFactoryOutput['id']]\n  ? [UFactoryOutput['id']] extends [UDeclaredOutput['id']]\n    ? {}\n    : `Error: The extension factory has undeclared output(s): ${JoinStringUnion<\n        Exclude<UFactoryOutput['id'], UDeclaredOutput['id']>\n      >}`\n  : `Error: The extension factory is missing the following output(s): ${JoinStringUnion<\n      Exclude<RequiredExtensionIds<UDeclaredOutput>, UFactoryOutput['id']>\n    >}`;\n\n/** @ignore */\nexport type VerifyExtensionAttachTo<\n  UOutput extends ExtensionDataRef,\n  UParentInput extends ExtensionDataRef,\n> = ExtensionDataRef extends UParentInput\n  ? {}\n  : [RequiredExtensionIds<UParentInput>] extends [RequiredExtensionIds<UOutput>]\n  ? {}\n  : `Error: This parent extension input requires the following extension data, but it is not declared as guaranteed output of this extension: ${JoinStringUnion<\n      Exclude<RequiredExtensionIds<UParentInput>, RequiredExtensionIds<UOutput>>\n    >}`;\n\n/**\n * Specifies where an extension should attach in the extension tree.\n *\n * @remarks\n *\n * A standard attachment point declaration will specify the ID of the parent extension, as well as the name of the input to attach to.\n *\n * There are three more advanced forms that are available for more complex use-cases:\n *\n * 1. Relative attachment points: using the `relative` property instead of `id`, the attachment point is resolved relative to the current plugin.\n * 2. Extension input references: using a reference in code to another extension's input in the same plugin. These references are always relative.\n * 3. Array of attachment points: an array of attachment points can be used to clone and attach to multiple extensions at once.\n *\n * @example\n * ```ts\n * // Attach to a specific extension by full ID\n * { id: 'app/routes', input: 'routes' }\n *\n * // Attach to an extension in the same plugin by kind\n * { relative: { kind: 'page' }, input: 'actions' }\n *\n * // Attach to a specific input of another extension\n * const page = ParentBlueprint.make({ ... });\n * const child = ChildBlueprint.make({ attachTo: page.inputs.children });\n *\n * // Attach to multiple parents at once\n * [\n *   { id: 'page/home', input: 'widgets' },\n *   { relative: { kind: 'page' }, input: 'widgets' },\n * ]\n * ```\n *\n * @public\n */\nexport type ExtensionDefinitionAttachTo<\n  UParentInputs extends ExtensionDataRef = ExtensionDataRef,\n> =\n  | { id: string; input: string; relative?: never }\n  | { relative: { kind?: string; name?: string }; input: string; id?: never }\n  | ExtensionInput<UParentInputs>\n  | Array<\n      | { id: string; input: string; relative?: never }\n      | {\n          relative: { kind?: string; name?: string };\n          input: string;\n          id?: never;\n        }\n      | ExtensionInput<UParentInputs>\n    >;\n\n/** @public */\nexport type CreateExtensionOptions<\n  TKind extends string | undefined,\n  TName extends string | undefined,\n  UOutput extends ExtensionDataRef,\n  TInputs extends { [inputName in string]: ExtensionInput },\n  TConfigSchema extends { [key: string]: (zImpl: typeof z) => z.ZodType },\n  UFactoryOutput extends ExtensionDataValue<any, any>,\n  UParentInputs extends ExtensionDataRef,\n> = {\n  kind?: TKind;\n  name?: TName;\n  attachTo: ExtensionDefinitionAttachTo<UParentInputs> &\n    VerifyExtensionAttachTo<UOutput, UParentInputs>;\n  disabled?: boolean;\n  inputs?: TInputs;\n  output: Array<UOutput>;\n  config?: {\n    schema: TConfigSchema;\n  };\n  factory(context: {\n    node: AppNode;\n    apis: ApiHolder;\n    config: {\n      [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;\n    };\n    inputs: Expand<ResolvedExtensionInputs<TInputs>>;\n  }): Iterable<UFactoryOutput>;\n} & VerifyExtensionFactoryOutput<UOutput, UFactoryOutput>;\n\n/** @public */\nexport type ExtensionDefinitionParameters = {\n  kind?: string;\n  name?: string;\n  configInput?: { [K in string]: any };\n  config?: { [K in string]: any };\n  output?: ExtensionDataRef;\n  inputs?: { [KName in string]: ExtensionInput };\n  params?: object | ExtensionBlueprintDefineParams;\n};\n\n/**\n * Same as the one in `createExtensionBlueprint`, but with `ParamsFactory` inlined.\n * It can't be exported because it breaks API reports.\n * @ignore\n */\ntype AnyParamsInput<TParams extends object | ExtensionBlueprintDefineParams> =\n  TParams extends ExtensionBlueprintDefineParams<infer IParams>\n    ? IParams | ((define: TParams) => ReturnType<TParams>)\n    :\n        | TParams\n        | ((\n            define: ExtensionBlueprintDefineParams<TParams, TParams>,\n          ) => ReturnType<ExtensionBlueprintDefineParams<TParams, TParams>>);\n\n/** @public */\nexport interface ExtensionDefinition<\n  TParams extends ExtensionDefinitionParameters = ExtensionDefinitionParameters,\n> {\n  $$type: '@backstage/ExtensionDefinition';\n  readonly T: TParams;\n}\n\n/** @public */\nexport interface OverridableExtensionDefinition<\n  T extends ExtensionDefinitionParameters = ExtensionDefinitionParameters,\n> extends ExtensionDefinition<T> {\n  /**\n   * References to the inputs of this extension, which can be used to attach child extensions.\n   */\n  readonly inputs: {\n    [K in keyof T['inputs']]: ExtensionInput<\n      T['inputs'][K] extends ExtensionInput<infer IData> ? IData : never\n    >;\n  };\n\n  override<\n    TExtensionConfigSchema extends {\n      [key in string]: (zImpl: typeof z) => z.ZodType;\n    },\n    UFactoryOutput extends ExtensionDataValue<any, any>,\n    UNewOutput extends ExtensionDataRef,\n    TExtraInputs extends { [inputName in string]: ExtensionInput },\n    TParamsInput extends AnyParamsInput<NonNullable<T['params']>>,\n    UParentInputs extends ExtensionDataRef,\n  >(\n    args: Expand<\n      {\n        attachTo?: ExtensionDefinitionAttachTo<UParentInputs> &\n          VerifyExtensionAttachTo<\n            ExtensionDataRef extends UNewOutput\n              ? NonNullable<T['output']>\n              : UNewOutput,\n            UParentInputs\n          >;\n        disabled?: boolean;\n        inputs?: TExtraInputs & {\n          [KName in keyof T['inputs']]?: `Error: Input '${KName &\n            string}' is already defined in parent definition`;\n        };\n        output?: Array<UNewOutput>;\n        config?: {\n          schema: TExtensionConfigSchema & {\n            [KName in keyof T['config']]?: `Error: Config key '${KName &\n              string}' is already defined in parent schema`;\n          };\n        };\n        factory?(\n          originalFactory: <\n            TFactoryParamsReturn extends AnyParamsInput<\n              NonNullable<T['params']>\n            >,\n          >(\n            context?: Expand<\n              {\n                config?: T['config'];\n                inputs?: ResolvedInputValueOverrides<NonNullable<T['inputs']>>;\n              } & ([T['params']] extends [never]\n                ? {}\n                : {\n                    params?: TFactoryParamsReturn extends ExtensionBlueprintDefineParams\n                      ? TFactoryParamsReturn\n                      : T['params'] extends ExtensionBlueprintDefineParams\n                      ? 'Error: This blueprint uses advanced parameter types and requires you to pass parameters as using the following callback syntax: `originalFactory(defineParams => defineParams(<params>))`'\n                      : Partial<T['params']>;\n                  })\n            >,\n          ) => ExtensionDataContainer<NonNullable<T['output']>>,\n          context: {\n            node: AppNode;\n            apis: ApiHolder;\n            config: T['config'] & {\n              [key in keyof TExtensionConfigSchema]: z.infer<\n                ReturnType<TExtensionConfigSchema[key]>\n              >;\n            };\n            inputs: Expand<ResolvedExtensionInputs<T['inputs'] & TExtraInputs>>;\n          },\n        ): Iterable<UFactoryOutput>;\n      } & ([T['params']] extends [never]\n        ? {}\n        : {\n            params?: TParamsInput extends ExtensionBlueprintDefineParams\n              ? TParamsInput\n              : T['params'] extends ExtensionBlueprintDefineParams\n              ? 'Error: This blueprint uses advanced parameter types and requires you to pass parameters as using the following callback syntax: `originalFactory(defineParams => defineParams(<params>))`'\n              : Partial<T['params']>;\n          })\n    > &\n      VerifyExtensionFactoryOutput<\n        ExtensionDataRef extends UNewOutput\n          ? NonNullable<T['output']>\n          : UNewOutput,\n        UFactoryOutput\n      >,\n  ): OverridableExtensionDefinition<{\n    kind: T['kind'];\n    name: T['name'];\n    output: ExtensionDataRef extends UNewOutput ? T['output'] : UNewOutput;\n    inputs: T['inputs'] & TExtraInputs;\n    config: T['config'] & {\n      [key in keyof TExtensionConfigSchema]: z.infer<\n        ReturnType<TExtensionConfigSchema[key]>\n      >;\n    };\n    configInput: T['configInput'] &\n      z.input<\n        z.ZodObject<{\n          [key in keyof TExtensionConfigSchema]: ReturnType<\n            TExtensionConfigSchema[key]\n          >;\n        }>\n      >;\n  }>;\n}\n\n/**\n * @internal\n */\nfunction bindInputs(\n  inputs: { [inputName in string]: ExtensionInput } | undefined,\n  kind?: string,\n  name?: string,\n) {\n  if (!inputs) {\n    return {};\n  }\n\n  return Object.fromEntries(\n    Object.entries(inputs).map(([inputName, input]) => [\n      inputName,\n      OpaqueExtensionInput.toInternal(input).withContext({\n        kind,\n        name,\n        input: inputName,\n      }),\n    ]),\n  );\n}\n\n/**\n * Creates a new extension definition for installation in a Backstage app.\n *\n * @remarks\n *\n * This is a low-level function for creation of extensions with arbitrary inputs\n * and outputs and is typically only intended to be used for advanced overrides\n * or framework-level extensions. For most extension creation needs, it is\n * recommended to use existing {@link ExtensionBlueprint}s instead. You can find\n * blueprints both in the `@backstage/frontend-plugin-api` package as well as\n * other plugin libraries. There is also a list of\n * {@link https://backstage.io/docs/frontend-system/building-plugins/common-extension-blueprints | commonly used blueprints}\n * in the frontend system documentation.\n *\n * Extension definitions that are created with this function can be installed in\n * a Backstage app via a {@link FrontendPlugin} or {@link FrontendModule}.\n *\n * For more details on how extensions work, see the\n * {@link https://backstage.io/docs/frontend-system/architecture/extensions | documentation for extensions}.\n *\n * @example\n *\n * ```ts\n * const myExtension = createExtension({\n *   name: 'example',\n *   attachTo: { id: 'app', input: 'root' },\n *   output: [coreExtensionData.reactElement],\n *   factory() {\n *     return [coreExtensionData.reactElement(<h1>Hello, world!</h1>)];\n *   },\n * });\n * ```\n *\n * @public\n */\nexport function createExtension<\n  UOutput extends ExtensionDataRef,\n  TInputs extends { [inputName in string]: ExtensionInput },\n  TConfigSchema extends { [key: string]: (zImpl: typeof z) => z.ZodType },\n  UFactoryOutput extends ExtensionDataValue<any, any>,\n  const TKind extends string | undefined = undefined,\n  const TName extends string | undefined = undefined,\n  UParentInputs extends ExtensionDataRef = ExtensionDataRef,\n>(\n  options: CreateExtensionOptions<\n    TKind,\n    TName,\n    UOutput,\n    TInputs,\n    TConfigSchema,\n    UFactoryOutput,\n    UParentInputs\n  >,\n): OverridableExtensionDefinition<{\n  config: string extends keyof TConfigSchema\n    ? {}\n    : {\n        [key in keyof TConfigSchema]: z.infer<ReturnType<TConfigSchema[key]>>;\n      };\n  configInput: string extends keyof TConfigSchema\n    ? {}\n    : z.input<\n        z.ZodObject<{\n          [key in keyof TConfigSchema]: ReturnType<TConfigSchema[key]>;\n        }>\n      >;\n  // This inference and remapping back to ExtensionDataRef eliminates any occurrences ConfigurationExtensionDataRef\n  output: UOutput extends ExtensionDataRef<\n    infer IData,\n    infer IId,\n    infer IConfig\n  >\n    ? ExtensionDataRef<IData, IId, IConfig>\n    : never;\n  inputs: TInputs;\n  params: never;\n  kind: string | undefined extends TKind ? undefined : TKind;\n  name: string | undefined extends TName ? undefined : TName;\n}> {\n  const schemaDeclaration = options.config?.schema;\n  const configSchema =\n    schemaDeclaration &&\n    createSchemaFromZod(innerZ =>\n      innerZ.object(\n        Object.fromEntries(\n          Object.entries(schemaDeclaration).map(([k, v]) => [k, v(innerZ)]),\n        ),\n      ),\n    );\n\n  return OpaqueExtensionDefinition.createInstance('v2', {\n    T: undefined as unknown as {\n      config: string extends keyof TConfigSchema\n        ? {}\n        : {\n            [key in keyof TConfigSchema]: z.infer<\n              ReturnType<TConfigSchema[key]>\n            >;\n          };\n      configInput: string extends keyof TConfigSchema\n        ? {}\n        : z.input<\n            z.ZodObject<{\n              [key in keyof TConfigSchema]: ReturnType<TConfigSchema[key]>;\n            }>\n          >;\n      output: UOutput;\n      inputs: TInputs;\n      kind: string | undefined extends TKind ? undefined : TKind;\n      name: string | undefined extends TName ? undefined : TName;\n    },\n    kind: options.kind,\n    name: options.name,\n    attachTo: options.attachTo,\n    disabled: options.disabled ?? false,\n    inputs: bindInputs(options.inputs, options.kind, options.name),\n    output: options.output,\n    configSchema,\n    factory: options.factory,\n    toString() {\n      const parts: string[] = [];\n      if (options.kind) {\n        parts.push(`kind=${options.kind}`);\n      }\n      if (options.name) {\n        parts.push(`name=${options.name}`);\n      }\n      const attachTo = [options.attachTo]\n        .flat()\n        .map(aAny => {\n          const a = aAny as ExtensionDefinitionAttachTo;\n          if (OpaqueExtensionInput.isType(a)) {\n            const { context } = OpaqueExtensionInput.toInternal(a);\n            if (!context) {\n              return '<detached-input>';\n            }\n            let id = '<plugin>';\n            if (context?.kind) {\n              id = `${context?.kind}:${id}`;\n            }\n            if (context?.name) {\n              id = `${id}/${context?.name}`;\n            }\n            return `${id}@${context.input}`;\n          }\n          if ('relative' in a && a.relative) {\n            let id = '<plugin>';\n            if (a.relative.kind) {\n              id = `${a.relative.kind}:${id}`;\n            }\n            if (a.relative.name) {\n              id = `${id}/${a.relative.name}`;\n            }\n            return `${id}@${a.input}`;\n          }\n          if ('id' in a) {\n            return `${a.id}@${a.input}`;\n          }\n          throw new Error('Invalid attachment point specification');\n        })\n        .join('+');\n      parts.push(`attachTo=${attachTo}`);\n      return `ExtensionDefinition{${parts.join(',')}}`;\n    },\n    override(overrideOptions) {\n      if (!Array.isArray(options.output)) {\n        throw new Error(\n          'Cannot override an extension that is not declared using the new format with outputs as an array',\n        );\n      }\n\n      // TODO(Rugvip): Making this a type check would be optimal, but it seems\n      //               like it's tricky to add that and still have the type\n      //               inference work correctly for the factory output.\n      if (overrideOptions.output && !overrideOptions.factory) {\n        throw new Error(\n          'Refused to override output without also overriding factory',\n        );\n      }\n      // TODO(Rugvip): Similar to above, would be nice to error during type checking, but don't want to complicate the types too much\n      if (overrideOptions.params && overrideOptions.factory) {\n        throw new Error(\n          'Refused to override params and factory at the same time',\n        );\n      }\n\n      return createExtension({\n        kind: options.kind,\n        name: options.name,\n        attachTo: (overrideOptions.attachTo ??\n          options.attachTo) as ExtensionDefinitionAttachTo,\n        disabled: overrideOptions.disabled ?? options.disabled,\n        inputs: bindInputs(\n          {\n            ...(options.inputs ?? {}),\n            ...(overrideOptions.inputs ?? {}),\n          },\n          options.kind,\n          options.name,\n        ),\n        output: (overrideOptions.output ??\n          options.output) as ExtensionDataRef[],\n        config:\n          options.config || overrideOptions.config\n            ? {\n                schema: {\n                  ...options.config?.schema,\n                  ...overrideOptions.config?.schema,\n                },\n              }\n            : undefined,\n        factory: ({ node, apis, config, inputs }) => {\n          if (!overrideOptions.factory) {\n            return options.factory({\n              node,\n              apis,\n              config: config as any,\n              inputs: inputs as any,\n              [ctxParamsSymbol as any]: overrideOptions.params,\n            });\n          }\n          const parentResult = overrideOptions.factory(\n            (innerContext): ExtensionDataContainer<UOutput> => {\n              return createExtensionDataContainer<UOutput>(\n                options.factory({\n                  node,\n                  apis,\n                  config: (innerContext?.config ?? config) as any,\n                  inputs: resolveInputOverrides(\n                    options.inputs,\n                    inputs,\n                    innerContext?.inputs,\n                  ) as any,\n                  [ctxParamsSymbol as any]: innerContext?.params,\n                }) as Iterable<any>,\n                'original extension factory',\n                options.output,\n              );\n            },\n            {\n              node,\n              apis,\n              config: config as any,\n              inputs: inputs as any,\n            },\n          );\n\n          if (\n            typeof parentResult !== 'object' ||\n            !parentResult?.[Symbol.iterator]\n          ) {\n            throw new Error(\n              'extension factory override did not provide an iterable object',\n            );\n          }\n\n          const deduplicatedResult = new Map<\n            string,\n            ExtensionDataValue<any, any>\n          >();\n          for (const item of parentResult) {\n            deduplicatedResult.set(item.id, item);\n          }\n\n          return deduplicatedResult.values();\n        },\n      }) as OverridableExtensionDefinition<any>;\n    },\n  });\n}\n"],"names":[],"mappings":"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"}