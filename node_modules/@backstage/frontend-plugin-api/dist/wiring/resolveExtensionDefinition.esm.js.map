{"version":3,"file":"resolveExtensionDefinition.esm.js","sources":["../../src/wiring/resolveExtensionDefinition.ts"],"sourcesContent":["/*\n * Copyright 2023 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ApiHolder, AppNode } from '../apis';\nimport {\n  ExtensionDefinitionAttachTo,\n  ExtensionDefinition,\n  ExtensionDefinitionParameters,\n  ResolvedExtensionInputs,\n} from './createExtension';\nimport { PortableSchema } from '../schema';\nimport { ExtensionInput } from './createExtensionInput';\nimport { ExtensionDataRef, ExtensionDataValue } from './createExtensionDataRef';\nimport {\n  OpaqueExtensionDefinition,\n  OpaqueExtensionInput,\n} from '@internal/frontend';\n\n/** @public */\nexport type ExtensionAttachTo =\n  | { id: string; input: string }\n  | Array<{ id: string; input: string }>;\n\n/**\n * @deprecated Use {@link ExtensionAttachTo} instead.\n * @public\n */\nexport type ExtensionAttachToSpec = ExtensionAttachTo;\n\n/** @public */\nexport interface Extension<TConfig, TConfigInput = TConfig> {\n  $$type: '@backstage/Extension';\n  readonly id: string;\n  readonly attachTo: ExtensionAttachToSpec;\n  readonly disabled: boolean;\n  readonly configSchema?: PortableSchema<TConfig, TConfigInput>;\n}\n\n/** @internal */\nexport type InternalExtension<TConfig, TConfigInput> = Extension<\n  TConfig,\n  TConfigInput\n> &\n  (\n    | {\n        readonly version: 'v1';\n        readonly inputs: {\n          [inputName in string]: {\n            $$type: '@backstage/ExtensionInput';\n            extensionData: {\n              [name in string]: ExtensionDataRef;\n            };\n            config: { optional: boolean; singleton: boolean };\n          };\n        };\n        readonly output: {\n          [name in string]: ExtensionDataRef;\n        };\n        factory(context: {\n          apis: ApiHolder;\n          node: AppNode;\n          config: TConfig;\n          inputs: {\n            [inputName in string]: unknown;\n          };\n        }): {\n          [inputName in string]: unknown;\n        };\n      }\n    | {\n        readonly version: 'v2';\n        readonly inputs: { [inputName in string]: ExtensionInput };\n        readonly output: Array<ExtensionDataRef>;\n        factory(options: {\n          apis: ApiHolder;\n          node: AppNode;\n          config: TConfig;\n          inputs: ResolvedExtensionInputs<{\n            [inputName in string]: ExtensionInput;\n          }>;\n        }): Iterable<ExtensionDataValue<any, any>>;\n      }\n  );\n\n/** @internal */\nexport function toInternalExtension<TConfig, TConfigInput>(\n  overrides: Extension<TConfig, TConfigInput>,\n): InternalExtension<TConfig, TConfigInput> {\n  const internal = overrides as InternalExtension<TConfig, TConfigInput>;\n  if (internal.$$type !== '@backstage/Extension') {\n    throw new Error(\n      `Invalid extension instance, bad type '${internal.$$type}'`,\n    );\n  }\n  const version = internal.version;\n  if (version !== 'v1' && version !== 'v2') {\n    throw new Error(`Invalid extension instance, bad version '${version}'`);\n  }\n  return internal;\n}\n\n/** @ignore */\nexport type ResolveExtensionId<\n  TExtension extends ExtensionDefinition,\n  TNamespace extends string,\n> = TExtension extends ExtensionDefinition<{\n  kind: infer IKind extends string | undefined;\n  name: infer IName extends string | undefined;\n  params: any;\n}>\n  ? [string] extends [IKind | IName]\n    ? never\n    : (\n        undefined extends IName ? TNamespace : `${TNamespace}/${IName}`\n      ) extends infer INamePart extends string\n    ? IKind extends string\n      ? `${IKind}:${INamePart}`\n      : INamePart\n    : never\n  : never;\n\nfunction resolveExtensionId(\n  kind?: string,\n  namespace?: string,\n  name?: string,\n): string {\n  const namePart =\n    name && namespace ? `${namespace}/${name}` : namespace || name;\n  if (!namePart) {\n    throw new Error(\n      `Extension must declare an explicit namespace or name as it could not be resolved from context, kind=${kind} namespace=${namespace} name=${name}`,\n    );\n  }\n\n  return kind ? `${kind}:${namePart}` : namePart;\n}\n\nfunction resolveAttachTo(\n  attachTo: ExtensionDefinitionAttachTo,\n  namespace?: string,\n): ExtensionAttachToSpec {\n  const resolveSpec = (\n    spec: Exclude<ExtensionDefinitionAttachTo, Array<any>>,\n  ): { id: string; input: string } => {\n    if (OpaqueExtensionInput.isType(spec)) {\n      const { context } = OpaqueExtensionInput.toInternal(spec);\n      if (!context) {\n        throw new Error(\n          'Invalid input object without a parent extension used as attachment point',\n        );\n      }\n      return {\n        id: resolveExtensionId(context.kind, namespace, context.name),\n        input: context.input,\n      };\n    }\n    if ('relative' in spec && spec.relative) {\n      return {\n        id: resolveExtensionId(\n          spec.relative.kind,\n          namespace,\n          spec.relative.name,\n        ),\n        input: spec.input,\n      };\n    }\n    if ('id' in spec) {\n      return { id: spec.id, input: spec.input };\n    }\n    throw new Error('Invalid attachment point specification');\n  };\n\n  if (Array.isArray(attachTo)) {\n    return attachTo.map(resolveSpec);\n  }\n\n  return resolveSpec(attachTo);\n}\n\n/** @internal */\nexport function resolveExtensionDefinition<\n  T extends ExtensionDefinitionParameters,\n>(\n  definition: ExtensionDefinition<T>,\n  context?: { namespace?: string },\n): Extension<T['config'], T['configInput']> {\n  const internalDefinition = OpaqueExtensionDefinition.toInternal(definition);\n\n  const {\n    name,\n    kind,\n    namespace: internalNamespace,\n    override: _skip2,\n    attachTo,\n    ...rest\n  } = internalDefinition;\n\n  const namespace = internalNamespace ?? context?.namespace;\n  const id = resolveExtensionId(kind, namespace, name);\n\n  return {\n    ...rest,\n    attachTo: resolveAttachTo(attachTo, namespace),\n    $$type: '@backstage/Extension',\n    version: internalDefinition.version,\n    id,\n    toString() {\n      return `Extension{id=${id}}`;\n    },\n  } as InternalExtension<T['config'], T['configInput']> & Object;\n}\n"],"names":[],"mappings":";;;AAsIA,SAAS,kBAAA,CACP,IAAA,EACA,SAAA,EACA,IAAA,EACQ;AACR,EAAA,MAAM,QAAA,GACJ,QAAQ,SAAA,GAAY,CAAA,EAAG,SAAS,CAAA,CAAA,EAAI,IAAI,KAAK,SAAA,IAAa,IAAA;AAC5D,EAAA,IAAI,CAAC,QAAA,EAAU;AACb,IAAA,MAAM,IAAI,KAAA;AAAA,MACR,CAAA,oGAAA,EAAuG,IAAI,CAAA,WAAA,EAAc,SAAS,SAAS,IAAI,CAAA;AAAA,KACjJ;AAAA,EACF;AAEA,EAAA,OAAO,IAAA,GAAO,CAAA,EAAG,IAAI,CAAA,CAAA,EAAI,QAAQ,CAAA,CAAA,GAAK,QAAA;AACxC;AAEA,SAAS,eAAA,CACP,UACA,SAAA,EACuB;AACvB,EAAA,MAAM,WAAA,GAAc,CAClB,IAAA,KACkC;AAClC,IAAA,IAAI,oBAAA,CAAqB,MAAA,CAAO,IAAI,CAAA,EAAG;AACrC,MAAA,MAAM,EAAE,OAAA,EAAQ,GAAI,oBAAA,CAAqB,WAAW,IAAI,CAAA;AACxD,MAAA,IAAI,CAAC,OAAA,EAAS;AACZ,QAAA,MAAM,IAAI,KAAA;AAAA,UACR;AAAA,SACF;AAAA,MACF;AACA,MAAA,OAAO;AAAA,QACL,IAAI,kBAAA,CAAmB,OAAA,CAAQ,IAAA,EAAM,SAAA,EAAW,QAAQ,IAAI,CAAA;AAAA,QAC5D,OAAO,OAAA,CAAQ;AAAA,OACjB;AAAA,IACF;AACA,IAAA,IAAI,UAAA,IAAc,IAAA,IAAQ,IAAA,CAAK,QAAA,EAAU;AACvC,MAAA,OAAO;AAAA,QACL,EAAA,EAAI,kBAAA;AAAA,UACF,KAAK,QAAA,CAAS,IAAA;AAAA,UACd,SAAA;AAAA,UACA,KAAK,QAAA,CAAS;AAAA,SAChB;AAAA,QACA,OAAO,IAAA,CAAK;AAAA,OACd;AAAA,IACF;AACA,IAAA,IAAI,QAAQ,IAAA,EAAM;AAChB,MAAA,OAAO,EAAE,EAAA,EAAI,IAAA,CAAK,EAAA,EAAI,KAAA,EAAO,KAAK,KAAA,EAAM;AAAA,IAC1C;AACA,IAAA,MAAM,IAAI,MAAM,wCAAwC,CAAA;AAAA,EAC1D,CAAA;AAEA,EAAA,IAAI,KAAA,CAAM,OAAA,CAAQ,QAAQ,CAAA,EAAG;AAC3B,IAAA,OAAO,QAAA,CAAS,IAAI,WAAW,CAAA;AAAA,EACjC;AAEA,EAAA,OAAO,YAAY,QAAQ,CAAA;AAC7B;AAGO,SAAS,0BAAA,CAGd,YACA,OAAA,EAC0C;AAC1C,EAAA,MAAM,kBAAA,GAAqB,yBAAA,CAA0B,UAAA,CAAW,UAAU,CAAA;AAE1E,EAAA,MAAM;AAAA,IACJ,IAAA;AAAA,IACA,IAAA;AAAA,IACA,SAAA,EAAW,iBAAA;AAAA,IACX,QAAA,EAAU,MAAA;AAAA,IACV,QAAA;AAAA,IACA,GAAG;AAAA,GACL,GAAI,kBAAA;AAEJ,EAAA,MAAM,SAAA,GAAY,qBAAqB,OAAA,EAAS,SAAA;AAChD,EAAA,MAAM,EAAA,GAAK,kBAAA,CAAmB,IAAA,EAAM,SAAA,EAAW,IAAI,CAAA;AAEnD,EAAA,OAAO;AAAA,IACL,GAAG,IAAA;AAAA,IACH,QAAA,EAAU,eAAA,CAAgB,QAAA,EAAU,SAAS,CAAA;AAAA,IAC7C,MAAA,EAAQ,sBAAA;AAAA,IACR,SAAS,kBAAA,CAAmB,OAAA;AAAA,IAC5B,EAAA;AAAA,IACA,QAAA,GAAW;AACT,MAAA,OAAO,gBAAgB,EAAE,CAAA,CAAA,CAAA;AAAA,IAC3B;AAAA,GACF;AACF;;;;"}