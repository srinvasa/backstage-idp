import { useRef, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import useAsync from 'react-use/esm/useAsync';
import { useApi, useRouteRef } from '@backstage/core-plugin-api';
import { catalogApiRef } from '@backstage/plugin-catalog-react';
import { stringifyEntityRef } from '@backstage/catalog-model';
import { buildTechDocsURL } from '@backstage/plugin-techdocs-react';
import { TECHDOCS_EXTERNAL_ANNOTATION } from '@backstage/plugin-techdocs-common';
import { rootDocsRouteRef } from '../../../routes.esm.js';

function useExternalRedirect(entityRef) {
  const catalogApi = useApi(catalogApiRef);
  const navigate = useNavigate();
  const viewTechdocLink = useRouteRef(rootDocsRouteRef);
  const entityKey = stringifyEntityRef(entityRef);
  const checkedEntityRef = useRef(null);
  const shouldCheckForRedirect = checkedEntityRef.current !== entityKey;
  const externalRedirectResult = useAsync(async () => {
    try {
      const catalogEntity = await catalogApi.getEntityByRef(entityRef);
      if (catalogEntity?.metadata?.annotations?.[TECHDOCS_EXTERNAL_ANNOTATION]) {
        return buildTechDocsURL(catalogEntity, viewTechdocLink);
      }
    } catch (error) {
    }
    return void 0;
  }, [entityKey, catalogApi]);
  useEffect(() => {
    if (!externalRedirectResult.loading && externalRedirectResult.value) {
      navigate(externalRedirectResult.value, { replace: true });
    }
    if (!externalRedirectResult.loading && !externalRedirectResult.value) {
      checkedEntityRef.current = entityKey;
    }
  }, [
    externalRedirectResult.loading,
    externalRedirectResult.value,
    navigate,
    entityKey
  ]);
  const shouldShowProgress = shouldCheckForRedirect && externalRedirectResult.loading || !!externalRedirectResult.value;
  return {
    loading: externalRedirectResult.loading,
    shouldShowProgress
  };
}

export { useExternalRedirect };
//# sourceMappingURL=useExternalRedirect.esm.js.map
