'use strict';

var pluginKubernetesCommon = require('@backstage/plugin-kubernetes-common');
var pluginPermissionNode = require('@backstage/plugin-permission-node');
var express = require('express');
var Router = require('express-promise-router');
require('@aws-sdk/credential-providers');
require('@aws-sdk/signature-v4');
require('@aws-crypto/sha256-js');
require('@backstage/integration-aws-node');
require('@azure/identity');
require('@google-cloud/container');
var DispatchStrategy = require('../auth/DispatchStrategy.cjs.js');
require('fs-extra');
var resourcesRoutes = require('../routes/resourcesRoutes.cjs.js');
var KubernetesProxy = require('./KubernetesProxy.cjs.js');
var requirePermission = require('../auth/requirePermission.cjs.js');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; }

var express__default = /*#__PURE__*/_interopDefaultCompat(express);
var Router__default = /*#__PURE__*/_interopDefaultCompat(Router);

class KubernetesRouter {
  static create(env) {
    return new KubernetesRouter(env);
  }
  env;
  constructor(env) {
    this.env = env;
  }
  async getRouter() {
    const {
      logger,
      config,
      permissions,
      authStrategyMap,
      clusterSupplier,
      objectsProvider,
      catalog,
      discovery,
      httpAuth
    } = this.env;
    logger.info("Initializing Kubernetes backend");
    if (!config.has("kubernetes")) {
      if (process.env.NODE_ENV !== "development") {
        throw new Error("Kubernetes configuration is missing");
      }
      logger.warn(
        "Failed to initialize kubernetes backend: kubernetes config is missing"
      );
      return Router__default.default();
    }
    const proxy = this.buildProxy(
      logger,
      clusterSupplier,
      discovery,
      httpAuth,
      authStrategyMap
    );
    return this.buildRouter(
      objectsProvider,
      clusterSupplier,
      catalog,
      proxy,
      permissions,
      httpAuth,
      authStrategyMap
    );
  }
  buildProxy(logger, clusterSupplier, discovery, httpAuth, authStrategyMap) {
    const authStrategy = new DispatchStrategy.DispatchStrategy({
      authStrategyMap
    });
    return new KubernetesProxy.KubernetesProxy({
      logger,
      clusterSupplier,
      authStrategy,
      discovery,
      httpAuth
    });
  }
  buildRouter(objectsProvider, clusterSupplier, catalog, proxy, permissionApi, httpAuth, authStrategyMap) {
    const logger = this.env.logger;
    const router = Router__default.default();
    router.use("/proxy", proxy.createRequestHandler({ permissionApi }));
    router.use(express__default.default.json());
    router.use(
      pluginPermissionNode.createPermissionIntegrationRouter({
        permissions: pluginKubernetesCommon.kubernetesPermissions
      })
    );
    router.post("/services/:serviceId", async (req, res) => {
      await requirePermission.requirePermission(
        permissionApi,
        pluginKubernetesCommon.kubernetesResourcesReadPermission,
        httpAuth,
        req
      );
      const serviceId = req.params.serviceId;
      const requestBody = req.body;
      try {
        const response = await objectsProvider.getKubernetesObjectsByEntity(
          {
            entity: requestBody.entity,
            auth: requestBody.auth || {}
          },
          { credentials: await httpAuth.credentials(req) }
        );
        res.json(response);
      } catch (e) {
        logger.error(
          `action=retrieveObjectsByServiceId service=${serviceId}, error=${e}`
        );
        res.status(500).json({ error: e.message });
      }
    });
    router.get("/clusters", async (req, res) => {
      await requirePermission.requirePermission(
        permissionApi,
        pluginKubernetesCommon.kubernetesClustersReadPermission,
        httpAuth,
        req
      );
      const credentials = await httpAuth.credentials(req);
      const clusterDetails = await this.fetchClusterDetails(clusterSupplier, {
        credentials
      });
      res.json({
        items: clusterDetails.map((cd) => {
          const oidcTokenProvider = cd.authMetadata[pluginKubernetesCommon.ANNOTATION_KUBERNETES_OIDC_TOKEN_PROVIDER];
          const authProvider = cd.authMetadata[pluginKubernetesCommon.ANNOTATION_KUBERNETES_AUTH_PROVIDER];
          const strategy = authStrategyMap[authProvider];
          let auth = {};
          if (strategy) {
            auth = strategy.presentAuthMetadata(cd.authMetadata);
          }
          return {
            name: cd.name,
            title: cd.title,
            dashboardUrl: cd.dashboardUrl,
            authProvider,
            ...oidcTokenProvider && { oidcTokenProvider },
            ...auth && Object.keys(auth).length !== 0 && { auth }
          };
        })
      });
    });
    resourcesRoutes.addResourceRoutesToRouter(
      router,
      catalog,
      objectsProvider,
      httpAuth,
      permissionApi
    );
    return router;
  }
  async fetchClusterDetails(clusterSupplier, options) {
    const clusterDetails = await clusterSupplier.getClusters(options);
    this.env.logger.debug(
      `action=loadClusterDetails numOfClustersLoaded=${clusterDetails.length}`
    );
    return clusterDetails;
  }
}

exports.KubernetesRouter = KubernetesRouter;
//# sourceMappingURL=KubernetesRouter.cjs.js.map
