'use strict';

var backendPluginApi = require('@backstage/backend-plugin-api');
var pluginCatalogNode = require('@backstage/plugin-catalog-node');
var pluginKubernetesNode = require('@backstage/plugin-kubernetes-node');
var KubernetesRouter = require('./service/KubernetesRouter.cjs.js');
var KubernetesInitializer = require('./service/KubernetesInitializer.cjs.js');

class ObjectsProvider {
  objectsProvider;
  getObjectsProvider() {
    return this.objectsProvider;
  }
  addObjectsProvider(provider) {
    if (this.objectsProvider) {
      throw new Error(
        "Multiple Kubernetes objects provider is not supported at this time"
      );
    }
    if (typeof provider !== "function") {
      this.objectsProvider = async () => provider;
    } else {
      this.objectsProvider = provider;
    }
  }
}
class ClusterSuplier {
  clusterSupplier;
  getClusterSupplier() {
    return this.clusterSupplier;
  }
  addClusterSupplier(clusterSupplier) {
    if (this.clusterSupplier) {
      throw new Error(
        "Multiple Kubernetes Cluster Suppliers is not supported at this time"
      );
    }
    if (typeof clusterSupplier !== "function") {
      this.clusterSupplier = async () => clusterSupplier;
    } else {
      this.clusterSupplier = clusterSupplier;
    }
  }
}
class Fetcher {
  fetcher;
  getFetcher() {
    return this.fetcher;
  }
  addFetcher(fetcher) {
    if (this.fetcher) {
      throw new Error(
        "Multiple Kubernetes Fetchers is not supported at this time"
      );
    }
    if (typeof fetcher !== "function") {
      this.fetcher = async () => fetcher;
    } else {
      this.fetcher = fetcher;
    }
  }
}
class ServiceLocator {
  serviceLocator;
  getServiceLocator() {
    return this.serviceLocator;
  }
  addServiceLocator(serviceLocator) {
    if (this.serviceLocator) {
      throw new Error(
        "Multiple Kubernetes Service Locators is not supported at this time"
      );
    }
    if (typeof serviceLocator !== "function") {
      this.serviceLocator = async () => serviceLocator;
    } else {
      this.serviceLocator = serviceLocator;
    }
  }
}
class AuthStrategy {
  authStrategies;
  getAuthenticationStrategies() {
    return this.authStrategies;
  }
  addAuthStrategy(key, authStrategy) {
    if (!this.authStrategies) {
      this.authStrategies = /* @__PURE__ */ new Map();
    }
    if (key.includes("-")) {
      throw new Error("Strategy name can not include dashes");
    }
    this.authStrategies.set(key, authStrategy);
  }
}
const kubernetesPlugin = backendPluginApi.createBackendPlugin({
  pluginId: "kubernetes",
  register(env) {
    const extPointObjectsProvider = new ObjectsProvider();
    const extPointClusterSuplier = new ClusterSuplier();
    const extPointAuthStrategy = new AuthStrategy();
    const extPointFetcher = new Fetcher();
    const extPointServiceLocator = new ServiceLocator();
    env.registerExtensionPoint(
      pluginKubernetesNode.kubernetesObjectsProviderExtensionPoint,
      extPointObjectsProvider
    );
    env.registerExtensionPoint(
      pluginKubernetesNode.kubernetesClusterSupplierExtensionPoint,
      extPointClusterSuplier
    );
    env.registerExtensionPoint(
      pluginKubernetesNode.kubernetesAuthStrategyExtensionPoint,
      extPointAuthStrategy
    );
    env.registerExtensionPoint(
      pluginKubernetesNode.kubernetesFetcherExtensionPoint,
      extPointFetcher
    );
    env.registerExtensionPoint(
      pluginKubernetesNode.kubernetesServiceLocatorExtensionPoint,
      extPointServiceLocator
    );
    env.registerInit({
      deps: {
        http: backendPluginApi.coreServices.httpRouter,
        logger: backendPluginApi.coreServices.logger,
        config: backendPluginApi.coreServices.rootConfig,
        discovery: backendPluginApi.coreServices.discovery,
        catalog: pluginCatalogNode.catalogServiceRef,
        permissions: backendPluginApi.coreServices.permissions,
        auth: backendPluginApi.coreServices.auth,
        httpAuth: backendPluginApi.coreServices.httpAuth
      },
      async init({
        http,
        logger,
        config,
        discovery,
        catalog,
        permissions,
        auth,
        httpAuth
      }) {
        if (config.has("kubernetes")) {
          const initializer = KubernetesInitializer.KubernetesInitializer.create({
            logger,
            config,
            catalog,
            auth,
            fetcher: extPointFetcher.getFetcher(),
            clusterSupplier: extPointClusterSuplier.getClusterSupplier(),
            serviceLocator: extPointServiceLocator.getServiceLocator(),
            objectsProvider: extPointObjectsProvider.getObjectsProvider(),
            authStrategyMap: extPointAuthStrategy.getAuthenticationStrategies()
          });
          const {
            fetcher,
            authStrategyMap,
            clusterSupplier,
            serviceLocator,
            objectsProvider
          } = await initializer.init();
          const router = KubernetesRouter.KubernetesRouter.create({
            logger,
            config,
            catalog,
            permissions,
            discovery,
            auth,
            httpAuth,
            authStrategyMap: Object.fromEntries(authStrategyMap.entries()),
            fetcher,
            clusterSupplier,
            serviceLocator,
            objectsProvider
          });
          http.use(await router.getRouter());
        } else {
          logger.warn(
            "Failed to initialize kubernetes backend: valid kubernetes config is missing"
          );
        }
      }
    });
  }
});

exports.kubernetesPlugin = kubernetesPlugin;
//# sourceMappingURL=plugin.cjs.js.map
