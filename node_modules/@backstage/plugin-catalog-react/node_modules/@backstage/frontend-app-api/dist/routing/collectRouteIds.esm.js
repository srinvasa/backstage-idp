import { OpaqueFrontendPlugin } from '../frontend-internal/src/wiring/InternalFrontendPlugin.esm.js';
import '../frontend-internal/src/wiring/InternalExtensionDefinition.esm.js';
import '../frontend-internal/src/wiring/InternalExtensionInput.esm.js';
import '../frontend-internal/src/wiring/InternalSwappableComponentRef.esm.js';
import { OpaqueRouteRef } from '../frontend-internal/src/routing/OpaqueRouteRef.esm.js';
import { OpaqueSubRouteRef } from '../frontend-internal/src/routing/OpaqueSubRouteRef.esm.js';
import { OpaqueExternalRouteRef } from '../frontend-internal/src/routing/OpaqueExternalRouteRef.esm.js';

function collectRouteIds(features, collector) {
  const routesById = /* @__PURE__ */ new Map();
  const externalRoutesById = /* @__PURE__ */ new Map();
  for (const feature of features) {
    if (!OpaqueFrontendPlugin.isType(feature)) {
      continue;
    }
    for (const [name, ref] of Object.entries(feature.routes)) {
      const refId = `${feature.id}.${name}`;
      if (routesById.has(refId)) {
        collector.report({
          code: "ROUTE_DUPLICATE",
          message: `Duplicate route id '${refId}' encountered while collecting routes`,
          context: { routeId: refId }
        });
        continue;
      }
      if (OpaqueRouteRef.isType(ref)) {
        const internalRef = OpaqueRouteRef.toInternal(ref);
        internalRef.setId(refId);
        routesById.set(refId, ref);
      } else {
        const internalRef = OpaqueSubRouteRef.toInternal(ref);
        routesById.set(refId, internalRef);
      }
    }
    for (const [name, ref] of Object.entries(feature.externalRoutes)) {
      const refId = `${feature.id}.${name}`;
      if (externalRoutesById.has(refId)) {
        collector.report({
          code: "ROUTE_DUPLICATE",
          message: `Duplicate external route id '${refId}' encountered while collecting routes`,
          context: { routeId: refId }
        });
        continue;
      }
      const internalRef = OpaqueExternalRouteRef.toInternal(ref);
      internalRef.setId(refId);
      externalRoutesById.set(refId, ref);
    }
  }
  return { routes: routesById, externalRoutes: externalRoutesById };
}

export { collectRouteIds };
//# sourceMappingURL=collectRouteIds.esm.js.map
