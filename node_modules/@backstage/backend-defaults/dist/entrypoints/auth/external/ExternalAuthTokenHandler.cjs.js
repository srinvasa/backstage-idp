'use strict';

var backendPluginApi = require('@backstage/backend-plugin-api');
var errors = require('@backstage/errors');
var legacy = require('./legacy.cjs.js');
var _static = require('./static.cjs.js');
var jwks = require('./jwks.cjs.js');
var helpers = require('./helpers.cjs.js');

const NEW_CONFIG_KEY = "backend.auth.externalAccess";
const OLD_CONFIG_KEY = "backend.auth.keys";
let loggedDeprecationWarning = false;
const externalTokenHandlersServiceRef = backendPluginApi.createServiceRef({
  id: "core.auth.externalTokenHandlers",
  multiton: true
});
const defaultHandlers = {
  static: _static.staticTokenHandler,
  legacy: legacy.legacyTokenHandler,
  jwks: jwks.jwksTokenHandler
};
class ExternalAuthTokenHandler {
  static create(options) {
    const {
      ownPluginId,
      config,
      externalTokenHandlers: customHandlers = [],
      logger
    } = options;
    const handlersTypes = customHandlers.reduce(
      (acc, handler) => {
        if (acc[handler.type]) {
          throw new Error(
            `Duplicate external token handler type '${handler.type}', each handler must have a unique type`
          );
        }
        acc[handler.type] = handler;
        return acc;
      },
      { ...defaultHandlers }
    );
    const handlerConfigs = config.getOptionalConfigArray(NEW_CONFIG_KEY) ?? [];
    const contexts = handlerConfigs.map(
      (handlerConfig) => {
        const type = handlerConfig.getString("type");
        const handler = handlersTypes[type];
        if (!handler) {
          const valid = Object.keys(handlersTypes).map((h) => `'${h}'`).join(", ");
          throw new Error(
            `Unknown type '${type}' in ${NEW_CONFIG_KEY}, expected one of ${valid}`
          );
        }
        return {
          context: handler.initialize({
            options: handlerConfig.getConfig("options")
          }),
          handler,
          allAccessRestrictions: handlerConfig ? helpers.readAccessRestrictionsFromConfig(handlerConfig) : void 0
        };
      }
    );
    const legacyConfigs = config.getOptionalConfigArray(OLD_CONFIG_KEY) ?? [];
    if (legacyConfigs.length && !loggedDeprecationWarning) {
      loggedDeprecationWarning = true;
      logger.warn(
        `DEPRECATION WARNING: The ${OLD_CONFIG_KEY} config has been replaced by ${NEW_CONFIG_KEY}, see https://backstage.io/docs/auth/service-to-service-auth`
      );
    }
    for (const legacyConfig of legacyConfigs) {
      contexts.push({
        context: legacy.legacyTokenHandler.initialize({
          legacy: true,
          options: legacyConfig
        }),
        handler: legacy.legacyTokenHandler,
        allAccessRestrictions: helpers.readAccessRestrictionsFromConfig(legacyConfig)
      });
    }
    return new ExternalAuthTokenHandler(ownPluginId, contexts);
  }
  ownPluginId;
  contexts;
  constructor(ownPluginId, contexts) {
    this.ownPluginId = ownPluginId;
    this.contexts = contexts;
  }
  async verifyToken(token) {
    for (const { handler, allAccessRestrictions, context } of this.contexts) {
      const result = await handler.verifyToken(token, context);
      if (result) {
        if (allAccessRestrictions) {
          const accessRestrictions = allAccessRestrictions.get(
            this.ownPluginId
          );
          if (!accessRestrictions) {
            const valid = [...allAccessRestrictions.keys()].map((k) => `'${k}'`).join(", ");
            throw new errors.NotAllowedError(
              `This token's access is restricted to plugin(s) ${valid}`
            );
          }
          return {
            ...result,
            accessRestrictions
          };
        }
        return result;
      }
    }
    return void 0;
  }
}

exports.ExternalAuthTokenHandler = ExternalAuthTokenHandler;
exports.externalTokenHandlersServiceRef = externalTokenHandlersServiceRef;
//# sourceMappingURL=ExternalAuthTokenHandler.cjs.js.map
