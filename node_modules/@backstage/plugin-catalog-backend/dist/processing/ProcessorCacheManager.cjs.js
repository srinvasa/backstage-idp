'use strict';

var util = require('./util.cjs.js');

class SingleProcessorSubCache {
  newState;
  existingState;
  constructor(existingState) {
    this.existingState = existingState;
  }
  async get(key) {
    return this.existingState?.[key];
  }
  async set(key, value) {
    if (!this.newState) {
      this.newState = {};
    }
    this.newState[key] = value;
  }
  collect() {
    return this.newState ?? this.existingState;
  }
}
class SingleProcessorCache {
  newState;
  subCaches = /* @__PURE__ */ new Map();
  existingState;
  constructor(existingState) {
    this.existingState = existingState;
  }
  async get(key) {
    return this.existingState?.[key];
  }
  async set(key, value) {
    if (!this.newState) {
      this.newState = {};
    }
    this.newState[key] = value;
  }
  withKey(key) {
    const existingSubCache = this.subCaches.get(key);
    if (existingSubCache) {
      return existingSubCache;
    }
    const existing = this.existingState?.[key];
    const subCache = new SingleProcessorSubCache(
      util.isObject(existing) ? existing : void 0
    );
    this.subCaches.set(key, subCache);
    return subCache;
  }
  collect() {
    let obj = this.newState ?? this.existingState;
    for (const [key, subCache] of this.subCaches) {
      const subCacheValue = subCache.collect();
      if (subCacheValue) {
        obj = { ...obj, [key]: subCacheValue };
      }
    }
    return obj;
  }
}
class ProcessorCacheManager {
  caches = /* @__PURE__ */ new Map();
  existingState;
  constructor(existingState) {
    this.existingState = existingState;
  }
  forProcessor(processor, key) {
    const name = processor.getProcessorName();
    const cache = this.caches.get(name);
    if (cache) {
      return key ? cache.withKey(key) : cache;
    }
    const existing = this.existingState[name];
    const newCache = new SingleProcessorCache(
      util.isObject(existing) ? existing : void 0
    );
    this.caches.set(name, newCache);
    return key ? newCache.withKey(key) : newCache;
  }
  collect() {
    const result = {};
    for (const [key, value] of this.caches.entries()) {
      result[key] = value.collect();
    }
    return result;
  }
}

exports.ProcessorCacheManager = ProcessorCacheManager;
//# sourceMappingURL=ProcessorCacheManager.cjs.js.map
