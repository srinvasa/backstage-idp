const orderForward = ({
  rootEntityRefs,
  nodes,
  edges
}) => {
  const entityEdges = /* @__PURE__ */ new Map();
  edges.forEach((edge) => {
    let fromEdges = entityEdges.get(edge.from);
    if (!fromEdges) {
      fromEdges = [];
      entityEdges.set(edge.from, fromEdges);
    }
    fromEdges.push(edge);
    let toEdges = entityEdges.get(edge.to);
    if (!toEdges) {
      toEdges = [];
      entityEdges.set(edge.to, toEdges);
    }
    toEdges.push(edge);
  });
  const visitedNodes = /* @__PURE__ */ new Set();
  for (const rootEntityRef of rootEntityRefs) {
    let currentNodes = [rootEntityRef].filter(
      (node) => !visitedNodes.has(node)
    );
    while (currentNodes.length > 0) {
      for (const currentNode of currentNodes) {
        visitedNodes.add(currentNode);
      }
      const nextNodes = [];
      currentNodes.forEach((node) => {
        entityEdges.get(node)?.forEach((edge) => {
          if (edge.to === node && !visitedNodes.has(edge.from)) {
            const { from, to } = edge;
            edge.from = to;
            edge.to = from;
            edge.relations.reverse();
          }
          nextNodes.push(edge.from, edge.to);
        });
      });
      currentNodes = Array.from(new Set(nextNodes)).filter(
        (node) => !visitedNodes.has(node)
      );
    }
  }
  const nodeOrder = Array.from(visitedNodes);
  nodes.sort((a, b) => {
    const aOrder = nodeOrder.findIndex((node) => node === a.id);
    const bOrder = nodeOrder.findIndex((node) => node === b.id);
    return aOrder - bOrder;
  });
};

export { orderForward };
//# sourceMappingURL=order-forward.esm.js.map
