function buildGraph({
  rootEntityRefs,
  entities,
  includeRelation,
  kinds,
  mergeRelations,
  relationPairs,
  unidirectional
}) {
  const edges = [];
  const visitedNodes = /* @__PURE__ */ new Set();
  const nodeQueue = [...rootEntityRefs];
  const hasEdge = (fromRef, toRef, relation) => {
    return edges.some(
      (edge) => fromRef === edge.from && toRef === edge.to && edge.relations.some(
        (rel) => rel[0] === relation[0] && rel[1] === relation[1]
      )
    );
  };
  while (nodeQueue.length > 0) {
    const entityRef = nodeQueue.pop();
    const entity = entities[entityRef];
    visitedNodes.add(entityRef);
    if (entity) {
      entity?.relations?.forEach((rel) => {
        if (!entities[rel.targetRef]) {
          return;
        }
        if (!includeRelation(rel.type)) {
          return;
        }
        if (kinds && !kinds.some(
          (kind) => rel.targetRef.startsWith(`${kind.toLocaleLowerCase("en-US")}:`)
        )) {
          return;
        }
        if (mergeRelations) {
          const pair = relationPairs.find(
            ([l, r]) => l === rel.type || r === rel.type
          ) ?? [rel.type];
          const [left] = pair;
          const from = left === rel.type ? entityRef : rel.targetRef;
          const to = left === rel.type ? rel.targetRef : entityRef;
          if (!unidirectional || !hasEdge(from, to, pair)) {
            edges.push({
              from,
              to,
              relations: pair,
              label: "visible"
            });
          }
        } else {
          if (!unidirectional || !hasEdge(entityRef, rel.targetRef, [rel.type])) {
            edges.push({
              from: entityRef,
              to: rel.targetRef,
              relations: [rel.type],
              label: "visible"
            });
          }
        }
        if (!visitedNodes.has(rel.targetRef)) {
          nodeQueue.push(rel.targetRef);
          visitedNodes.add(rel.targetRef);
        }
        if (unidirectional) {
          const findIndex = edges.findIndex(
            (edge) => entityRef === edge.from && rel.targetRef === edge.to && !edge.relations.includes(rel.type)
          );
          if (findIndex >= 0) {
            if (mergeRelations) {
              const pair = relationPairs.find(
                ([l, r]) => l === rel.type || r === rel.type
              ) ?? [rel.type];
              edges[findIndex].relations = [
                ...edges[findIndex].relations,
                ...pair
              ];
            } else {
              edges[findIndex].relations = [
                ...edges[findIndex].relations,
                rel.type
              ];
            }
          }
        }
      });
    }
  }
  return edges;
}

export { buildGraph };
//# sourceMappingURL=build-graph.esm.js.map
