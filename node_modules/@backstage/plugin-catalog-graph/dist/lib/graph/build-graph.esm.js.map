{"version":3,"file":"build-graph.esm.js","sources":["../../../src/lib/graph/build-graph.ts"],"sourcesContent":["/*\n * Copyright 2025 The Backstage Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Entity } from '@backstage/catalog-model';\n\nimport type { EntityEdge, RelationPairs } from '../types';\n\nexport interface BuildGraphOptions {\n  rootEntityRefs: readonly string[];\n  entities: {\n    [ref: string]: Entity;\n  };\n  includeRelation: (type: string) => boolean;\n  kinds: readonly string[] | undefined;\n  mergeRelations: boolean;\n  relationPairs: RelationPairs;\n  unidirectional: boolean;\n}\n\nexport function buildGraph({\n  rootEntityRefs,\n  entities,\n  includeRelation,\n  kinds,\n  mergeRelations,\n  relationPairs,\n  unidirectional,\n}: BuildGraphOptions): EntityEdge[] {\n  const edges: EntityEdge[] = [];\n  const visitedNodes = new Set<string>();\n  const nodeQueue = [...rootEntityRefs];\n\n  const hasEdge = (\n    fromRef: string,\n    toRef: string,\n    relation: [string, string?],\n  ): boolean => {\n    return edges.some(\n      edge =>\n        fromRef === edge.from &&\n        toRef === edge.to &&\n        edge.relations.some(\n          rel => rel[0] === relation[0] && rel[1] === relation[1],\n        ),\n    );\n  };\n\n  while (nodeQueue.length > 0) {\n    const entityRef = nodeQueue.pop()!;\n    const entity = entities[entityRef];\n    visitedNodes.add(entityRef);\n\n    if (entity) {\n      entity?.relations?.forEach(rel => {\n        // Check if the related entity should be displayed, if not, ignore\n        // the relation too\n        if (!entities[rel.targetRef]) {\n          return;\n        }\n\n        if (!includeRelation(rel.type)) {\n          return;\n        }\n\n        if (\n          kinds &&\n          !kinds.some(kind =>\n            rel.targetRef.startsWith(`${kind.toLocaleLowerCase('en-US')}:`),\n          )\n        ) {\n          return;\n        }\n\n        if (mergeRelations) {\n          const pair = relationPairs.find(\n            ([l, r]) => l === rel.type || r === rel.type,\n          ) ?? [rel.type];\n          const [left] = pair;\n          const from = left === rel.type ? entityRef : rel.targetRef;\n          const to = left === rel.type ? rel.targetRef : entityRef;\n          if (!unidirectional || !hasEdge(from, to, pair)) {\n            edges.push({\n              from,\n              to,\n              relations: pair,\n              label: 'visible',\n            });\n          }\n        } else {\n          if (\n            !unidirectional ||\n            !hasEdge(entityRef, rel.targetRef, [rel.type])\n          ) {\n            edges.push({\n              from: entityRef,\n              to: rel.targetRef,\n              relations: [rel.type],\n              label: 'visible',\n            });\n          }\n        }\n\n        if (!visitedNodes.has(rel.targetRef)) {\n          nodeQueue.push(rel.targetRef);\n          visitedNodes.add(rel.targetRef);\n        }\n\n        // if unidirectional add missing relations as entities are only visited once\n        if (unidirectional) {\n          const findIndex = edges.findIndex(\n            edge =>\n              entityRef === edge.from &&\n              rel.targetRef === edge.to &&\n              !edge.relations.includes(rel.type),\n          );\n          if (findIndex >= 0) {\n            if (mergeRelations) {\n              const pair = relationPairs.find(\n                ([l, r]) => l === rel.type || r === rel.type,\n              ) ?? [rel.type];\n              edges[findIndex].relations = [\n                ...edges[findIndex].relations,\n                ...pair,\n              ];\n            } else {\n              edges[findIndex].relations = [\n                ...edges[findIndex].relations,\n                rel.type,\n              ];\n            }\n          }\n        }\n      });\n    }\n  }\n\n  return edges;\n}\n"],"names":[],"mappings":"AAgCO,SAAS,UAAA,CAAW;AAAA,EACzB,cAAA;AAAA,EACA,QAAA;AAAA,EACA,eAAA;AAAA,EACA,KAAA;AAAA,EACA,cAAA;AAAA,EACA,aAAA;AAAA,EACA;AACF,CAAA,EAAoC;AAClC,EAAA,MAAM,QAAsB,EAAC;AAC7B,EAAA,MAAM,YAAA,uBAAmB,GAAA,EAAY;AACrC,EAAA,MAAM,SAAA,GAAY,CAAC,GAAG,cAAc,CAAA;AAEpC,EAAA,MAAM,OAAA,GAAU,CACd,OAAA,EACA,KAAA,EACA,QAAA,KACY;AACZ,IAAA,OAAO,KAAA,CAAM,IAAA;AAAA,MACX,CAAA,IAAA,KACE,YAAY,IAAA,CAAK,IAAA,IACjB,UAAU,IAAA,CAAK,EAAA,IACf,KAAK,SAAA,CAAU,IAAA;AAAA,QACb,CAAA,GAAA,KAAO,GAAA,CAAI,CAAC,CAAA,KAAM,QAAA,CAAS,CAAC,CAAA,IAAK,GAAA,CAAI,CAAC,CAAA,KAAM,QAAA,CAAS,CAAC;AAAA;AACxD,KACJ;AAAA,EACF,CAAA;AAEA,EAAA,OAAO,SAAA,CAAU,SAAS,CAAA,EAAG;AAC3B,IAAA,MAAM,SAAA,GAAY,UAAU,GAAA,EAAI;AAChC,IAAA,MAAM,MAAA,GAAS,SAAS,SAAS,CAAA;AACjC,IAAA,YAAA,CAAa,IAAI,SAAS,CAAA;AAE1B,IAAA,IAAI,MAAA,EAAQ;AACV,MAAA,MAAA,EAAQ,SAAA,EAAW,QAAQ,CAAA,GAAA,KAAO;AAGhC,QAAA,IAAI,CAAC,QAAA,CAAS,GAAA,CAAI,SAAS,CAAA,EAAG;AAC5B,UAAA;AAAA,QACF;AAEA,QAAA,IAAI,CAAC,eAAA,CAAgB,GAAA,CAAI,IAAI,CAAA,EAAG;AAC9B,UAAA;AAAA,QACF;AAEA,QAAA,IACE,KAAA,IACA,CAAC,KAAA,CAAM,IAAA;AAAA,UAAK,CAAA,IAAA,KACV,IAAI,SAAA,CAAU,UAAA,CAAW,GAAG,IAAA,CAAK,iBAAA,CAAkB,OAAO,CAAC,CAAA,CAAA,CAAG;AAAA,SAChE,EACA;AACA,UAAA;AAAA,QACF;AAEA,QAAA,IAAI,cAAA,EAAgB;AAClB,UAAA,MAAM,OAAO,aAAA,CAAc,IAAA;AAAA,YACzB,CAAC,CAAC,CAAA,EAAG,CAAC,MAAM,CAAA,KAAM,GAAA,CAAI,IAAA,IAAQ,CAAA,KAAM,GAAA,CAAI;AAAA,WAC1C,IAAK,CAAC,GAAA,CAAI,IAAI,CAAA;AACd,UAAA,MAAM,CAAC,IAAI,CAAA,GAAI,IAAA;AACf,UAAA,MAAM,IAAA,GAAO,IAAA,KAAS,GAAA,CAAI,IAAA,GAAO,YAAY,GAAA,CAAI,SAAA;AACjD,UAAA,MAAM,EAAA,GAAK,IAAA,KAAS,GAAA,CAAI,IAAA,GAAO,IAAI,SAAA,GAAY,SAAA;AAC/C,UAAA,IAAI,CAAC,cAAA,IAAkB,CAAC,QAAQ,IAAA,EAAM,EAAA,EAAI,IAAI,CAAA,EAAG;AAC/C,YAAA,KAAA,CAAM,IAAA,CAAK;AAAA,cACT,IAAA;AAAA,cACA,EAAA;AAAA,cACA,SAAA,EAAW,IAAA;AAAA,cACX,KAAA,EAAO;AAAA,aACR,CAAA;AAAA,UACH;AAAA,QACF,CAAA,MAAO;AACL,UAAA,IACE,CAAC,cAAA,IACD,CAAC,OAAA,CAAQ,SAAA,EAAW,GAAA,CAAI,SAAA,EAAW,CAAC,GAAA,CAAI,IAAI,CAAC,CAAA,EAC7C;AACA,YAAA,KAAA,CAAM,IAAA,CAAK;AAAA,cACT,IAAA,EAAM,SAAA;AAAA,cACN,IAAI,GAAA,CAAI,SAAA;AAAA,cACR,SAAA,EAAW,CAAC,GAAA,CAAI,IAAI,CAAA;AAAA,cACpB,KAAA,EAAO;AAAA,aACR,CAAA;AAAA,UACH;AAAA,QACF;AAEA,QAAA,IAAI,CAAC,YAAA,CAAa,GAAA,CAAI,GAAA,CAAI,SAAS,CAAA,EAAG;AACpC,UAAA,SAAA,CAAU,IAAA,CAAK,IAAI,SAAS,CAAA;AAC5B,UAAA,YAAA,CAAa,GAAA,CAAI,IAAI,SAAS,CAAA;AAAA,QAChC;AAGA,QAAA,IAAI,cAAA,EAAgB;AAClB,UAAA,MAAM,YAAY,KAAA,CAAM,SAAA;AAAA,YACtB,CAAA,IAAA,KACE,SAAA,KAAc,IAAA,CAAK,IAAA,IACnB,GAAA,CAAI,SAAA,KAAc,IAAA,CAAK,EAAA,IACvB,CAAC,IAAA,CAAK,SAAA,CAAU,QAAA,CAAS,IAAI,IAAI;AAAA,WACrC;AACA,UAAA,IAAI,aAAa,CAAA,EAAG;AAClB,YAAA,IAAI,cAAA,EAAgB;AAClB,cAAA,MAAM,OAAO,aAAA,CAAc,IAAA;AAAA,gBACzB,CAAC,CAAC,CAAA,EAAG,CAAC,MAAM,CAAA,KAAM,GAAA,CAAI,IAAA,IAAQ,CAAA,KAAM,GAAA,CAAI;AAAA,eAC1C,IAAK,CAAC,GAAA,CAAI,IAAI,CAAA;AACd,cAAA,KAAA,CAAM,SAAS,EAAE,SAAA,GAAY;AAAA,gBAC3B,GAAG,KAAA,CAAM,SAAS,CAAA,CAAE,SAAA;AAAA,gBACpB,GAAG;AAAA,eACL;AAAA,YACF,CAAA,MAAO;AACL,cAAA,KAAA,CAAM,SAAS,EAAE,SAAA,GAAY;AAAA,gBAC3B,GAAG,KAAA,CAAM,SAAS,CAAA,CAAE,SAAA;AAAA,gBACpB,GAAA,CAAI;AAAA,eACN;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF,CAAC,CAAA;AAAA,IACH;AAAA,EACF;AAEA,EAAA,OAAO,KAAA;AACT;;;;"}