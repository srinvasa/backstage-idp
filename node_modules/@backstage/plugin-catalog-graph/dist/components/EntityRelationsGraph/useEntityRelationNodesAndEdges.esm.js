import { useState } from 'react';
import useDebounce from 'react-use/esm/useDebounce';
import { useEntityRelationGraph } from './useEntityRelationGraph.esm.js';
import { DEFAULT_NAMESPACE } from '@backstage/catalog-model';
import { useRelations } from '../../hooks/useRelations.esm.js';
import { buildGraph } from '../../lib/graph/build-graph.esm.js';
import { builtInTransformations } from '../../lib/graph-transformations/index.esm.js';

function useEntityRelationNodesAndEdges({
  rootEntityRefs,
  maxDepth = Number.POSITIVE_INFINITY,
  unidirectional = true,
  mergeRelations = true,
  kinds,
  relations,
  entityFilter,
  onNodeClick,
  relationPairs: incomingRelationPairs
}) {
  const [nodesAndEdges, setNodesAndEdges] = useState({});
  const { entities, loading, error } = useEntityRelationGraph({
    rootEntityRefs,
    filter: {
      maxDepth,
      kinds,
      relations,
      entityFilter
    }
  });
  const { relationPairs, includeRelation } = useRelations({
    relations,
    relationPairs: incomingRelationPairs
  });
  useDebounce(
    () => {
      if (!entities || Object.keys(entities).length === 0) {
        setNodesAndEdges({});
        return;
      }
      const nodes = Object.entries(entities).map(([entityRef, entity]) => {
        const focused = rootEntityRefs.includes(entityRef);
        const node = {
          id: entityRef,
          entity,
          focused,
          color: focused ? "secondary" : "primary",
          // @deprecated
          kind: entity.kind,
          name: entity.metadata.name,
          namespace: entity.metadata.namespace || DEFAULT_NAMESPACE,
          title: entity.metadata.title,
          spec: entity.spec
        };
        if (onNodeClick) {
          node.onClick = (event) => onNodeClick(node, event);
        }
        return node;
      });
      const edges = buildGraph({
        rootEntityRefs,
        entities,
        includeRelation,
        kinds,
        mergeRelations,
        relationPairs,
        unidirectional
      });
      const transformationContext = {
        nodeDistances: /* @__PURE__ */ new Map(),
        edges,
        nodes,
        rootEntityRefs,
        unidirectional,
        maxDepth
      };
      const runTransformation = (transformation) => {
        if (typeof transformation === "function") {
          transformation(transformationContext);
        } else {
          builtInTransformations[transformation](transformationContext);
        }
      };
      runTransformation("reduce-edges");
      runTransformation("set-distances");
      if (unidirectional) {
        runTransformation("strip-distant-edges");
      }
      if (mergeRelations || unidirectional) {
        runTransformation("merge-relations");
      }
      if (unidirectional && !mergeRelations) {
        runTransformation("order-forward");
        runTransformation("remove-backward-edges");
      }
      setNodesAndEdges({
        nodes: transformationContext.nodes,
        edges: transformationContext.edges
      });
    },
    100,
    [
      maxDepth,
      entities,
      rootEntityRefs,
      kinds,
      includeRelation,
      unidirectional,
      mergeRelations,
      onNodeClick,
      relationPairs
    ]
  );
  return {
    loading,
    error,
    ...nodesAndEdges
  };
}

export { useEntityRelationNodesAndEdges };
//# sourceMappingURL=useEntityRelationNodesAndEdges.esm.js.map
