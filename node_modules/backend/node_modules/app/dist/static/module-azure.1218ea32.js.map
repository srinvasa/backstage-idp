{"version":3,"file":"static/module-azure.1218ea32.js","sources":["webpack://app/../../node_modules/@azure/logger/dist/browser/index.js","webpack://app/../../node_modules/@azure/identity/dist/browser/util/logging.js","webpack://app/../../node_modules/@azure/identity/dist/browser/constants.js","webpack://app/../../node_modules/@azure/core-tracing/dist/browser/tracingContext.js","webpack://app/../../node_modules/@azure/identity/dist/browser/util/tracing.js","webpack://app/../../node_modules/@azure/core-tracing/dist/browser/tracingClient.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/chainedTokenCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/defaultAzureCredential.js","webpack://app/../../node_modules/@azure/core-util/dist/browser/index.js","webpack://app/../../node_modules/@azure/identity/dist/browser/msal/utils.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/log.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/util/file.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/multipartPolicy.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/restError.js","webpack://app/../../node_modules/@azure/core-rest-pipeline/dist/browser/policies/retryPolicy.js","webpack://app/../../node_modules/@azure/core-client/dist/browser/state.js","webpack://app/../../node_modules/@azure/core-client/dist/browser/operationHelpers.js","webpack://app/../../node_modules/@azure/core-client/dist/browser/log.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/clientSecretCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/environmentCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/clientCertificateCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/clientAssertionCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/azureCliCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/azureDeveloperCliCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/msal/browserFlows/msalBrowserCommon.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/interactiveBrowserCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/managedIdentityCredential/index.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/deviceCodeCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/azurePipelinesCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/authorizationCodeCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/azurePowerShellCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/usernamePasswordCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/visualStudioCodeCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/onBehalfOfCredential.js","webpack://app/../../node_modules/@azure/identity/dist/browser/credentials/workloadIdentityCredential.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createLoggerContext } from \"@typespec/ts-http-runtime/internal/logger\";\nconst context = createLoggerContext({\n    logLevelEnvVarName: \"AZURE_LOG_LEVEL\",\n    namespace: \"azure\",\n});\n/**\n * The AzureLogger provides a mechanism for overriding where logs are output to.\n * By default, logs are sent to stderr.\n * Override the `log` method to redirect logs to another location.\n */\nexport const AzureLogger = context.logger;\n/**\n * Immediately enables logging at the specified log level. If no level is specified, logging is disabled.\n * @param level - The log level to enable for logging.\n * Options from most verbose to least verbose are:\n * - verbose\n * - info\n * - warning\n * - error\n */\nexport function setLogLevel(level) {\n    context.setLogLevel(level);\n}\n/**\n * Retrieves the currently specified log level.\n */\nexport function getLogLevel() {\n    return context.getLogLevel();\n}\n/**\n * Creates a logger for use by the Azure SDKs that inherits from `AzureLogger`.\n * @param namespace - The name of the SDK package.\n * @hidden\n */\nexport function createClientLogger(namespace) {\n    return context.createClientLogger(namespace);\n}\n//# sourceMappingURL=index.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createClientLogger } from \"@azure/logger\";\n/**\n * The AzureLogger used for all clients within the identity package\n */\nexport const logger = createClientLogger(\"identity\");\n/**\n * Separates a list of environment variable names into a plain object with two arrays: an array of missing environment variables and another array with assigned environment variables.\n * @param supportedEnvVars - List of environment variable names\n */\nexport function processEnvVars(supportedEnvVars) {\n    return supportedEnvVars.reduce((acc, envVariable) => {\n        if (process.env[envVariable]) {\n            acc.assigned.push(envVariable);\n        }\n        else {\n            acc.missing.push(envVariable);\n        }\n        return acc;\n    }, { missing: [], assigned: [] });\n}\n/**\n * Based on a given list of environment variable names,\n * logs the environment variables currently assigned during the usage of a credential that goes by the given name.\n * @param credentialName - Name of the credential in use\n * @param supportedEnvVars - List of environment variables supported by that credential\n */\nexport function logEnvVars(credentialName, supportedEnvVars) {\n    const { assigned } = processEnvVars(supportedEnvVars);\n    logger.info(`${credentialName} => Found the following environment variables: ${assigned.join(\", \")}`);\n}\n/**\n * Formatting the success event on the credentials\n */\nexport function formatSuccess(scope) {\n    return `SUCCESS. Scopes: ${Array.isArray(scope) ? scope.join(\", \") : scope}.`;\n}\n/**\n * Formatting the success event on the credentials\n */\nexport function formatError(scope, error) {\n    let message = \"ERROR.\";\n    if (scope?.length) {\n        message += ` Scopes: ${Array.isArray(scope) ? scope.join(\", \") : scope}.`;\n    }\n    return `${message} Error message: ${typeof error === \"string\" ? error : error.message}.`;\n}\n/**\n * Generates a CredentialLoggerInstance.\n *\n * It logs with the format:\n *\n *   `[title] => [message]`\n *\n */\nexport function credentialLoggerInstance(title, parent, log = logger) {\n    const fullTitle = parent ? `${parent.fullTitle} ${title}` : title;\n    function info(message) {\n        log.info(`${fullTitle} =>`, message);\n    }\n    function warning(message) {\n        log.warning(`${fullTitle} =>`, message);\n    }\n    function verbose(message) {\n        log.verbose(`${fullTitle} =>`, message);\n    }\n    function error(message) {\n        log.error(`${fullTitle} =>`, message);\n    }\n    return {\n        title,\n        fullTitle,\n        info,\n        warning,\n        verbose,\n        error,\n    };\n}\n/**\n * Generates a CredentialLogger, which is a logger declared at the credential's constructor, and used at any point in the credential.\n * It has all the properties of a CredentialLoggerInstance, plus other logger instances, one per method.\n *\n * It logs with the format:\n *\n *   `[title] => [message]`\n *   `[title] => getToken() => [message]`\n *\n */\nexport function credentialLogger(title, log = logger) {\n    const credLogger = credentialLoggerInstance(title, undefined, log);\n    return {\n        ...credLogger,\n        parent: log,\n        getToken: credentialLoggerInstance(\"=> getToken()\", credLogger, log),\n    };\n}\n//# sourceMappingURL=logging.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/**\n * Current version of the `@azure/identity` package.\n */\nexport const SDK_VERSION = `4.13.0`;\n/**\n * The default client ID for authentication\n * @internal\n */\n// TODO: temporary - this is the Azure CLI clientID - we'll replace it when\n// Developer Sign On application is available\n// https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/src/Constants.cs#L9\nexport const DeveloperSignOnClientId = \"04b07795-8ddb-461a-bbee-02f9e1bf7b46\";\n/**\n * The default tenant for authentication\n * @internal\n */\nexport const DefaultTenantId = \"common\";\n/**\n * A list of known Azure authority hosts\n */\nexport var AzureAuthorityHosts;\n(function (AzureAuthorityHosts) {\n    /**\n     * China-based Azure Authority Host\n     */\n    AzureAuthorityHosts[\"AzureChina\"] = \"https://login.chinacloudapi.cn\";\n    /**\n     * Germany-based Azure Authority Host\n     *\n     * @deprecated Microsoft Cloud Germany was closed on October 29th, 2021.\n     *\n     * */\n    AzureAuthorityHosts[\"AzureGermany\"] = \"https://login.microsoftonline.de\";\n    /**\n     * US Government Azure Authority Host\n     */\n    AzureAuthorityHosts[\"AzureGovernment\"] = \"https://login.microsoftonline.us\";\n    /**\n     * Public Cloud Azure Authority Host\n     */\n    AzureAuthorityHosts[\"AzurePublicCloud\"] = \"https://login.microsoftonline.com\";\n})(AzureAuthorityHosts || (AzureAuthorityHosts = {}));\n/**\n * @internal\n * The default authority host.\n */\nexport const DefaultAuthorityHost = AzureAuthorityHosts.AzurePublicCloud;\n/**\n * @internal\n * The default environment host for Azure Public Cloud\n */\nexport const DefaultAuthority = \"login.microsoftonline.com\";\n/**\n * @internal\n * Allow acquiring tokens for any tenant for multi-tentant auth.\n */\nexport const ALL_TENANTS = [\"*\"];\n/**\n * @internal\n */\nexport const CACHE_CAE_SUFFIX = \"cae\";\n/**\n * @internal\n */\nexport const CACHE_NON_CAE_SUFFIX = \"nocae\";\n/**\n * @internal\n *\n * The default name for the cache persistence plugin.\n * Matches the constant defined in the cache persistence package.\n */\nexport const DEFAULT_TOKEN_CACHE_NAME = \"msal.cache\";\n//# sourceMappingURL=constants.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/** @internal */\nexport const knownContextKeys = {\n    span: Symbol.for(\"@azure/core-tracing span\"),\n    namespace: Symbol.for(\"@azure/core-tracing namespace\"),\n};\n/**\n * Creates a new {@link TracingContext} with the given options.\n * @param options - A set of known keys that may be set on the context.\n * @returns A new {@link TracingContext} with the given options.\n *\n * @internal\n */\nexport function createTracingContext(options = {}) {\n    let context = new TracingContextImpl(options.parentContext);\n    if (options.span) {\n        context = context.setValue(knownContextKeys.span, options.span);\n    }\n    if (options.namespace) {\n        context = context.setValue(knownContextKeys.namespace, options.namespace);\n    }\n    return context;\n}\n/** @internal */\nexport class TracingContextImpl {\n    _contextMap;\n    constructor(initialContext) {\n        this._contextMap =\n            initialContext instanceof TracingContextImpl\n                ? new Map(initialContext._contextMap)\n                : new Map();\n    }\n    setValue(key, value) {\n        const newContext = new TracingContextImpl(this);\n        newContext._contextMap.set(key, value);\n        return newContext;\n    }\n    getValue(key) {\n        return this._contextMap.get(key);\n    }\n    deleteValue(key) {\n        const newContext = new TracingContextImpl(this);\n        newContext._contextMap.delete(key);\n        return newContext;\n    }\n}\n//# sourceMappingURL=tracingContext.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { SDK_VERSION } from \"../constants.js\";\nimport { createTracingClient } from \"@azure/core-tracing\";\n/**\n * Creates a span using the global tracer.\n * @internal\n */\nexport const tracingClient = createTracingClient({\n    namespace: \"Microsoft.AAD\",\n    packageName: \"@azure/identity\",\n    packageVersion: SDK_VERSION,\n});\n//# sourceMappingURL=tracing.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { getInstrumenter } from \"./instrumenter.js\";\nimport { knownContextKeys } from \"./tracingContext.js\";\n/**\n * Creates a new tracing client.\n *\n * @param options - Options used to configure the tracing client.\n * @returns - An instance of {@link TracingClient}.\n */\nexport function createTracingClient(options) {\n    const { namespace, packageName, packageVersion } = options;\n    function startSpan(name, operationOptions, spanOptions) {\n        const startSpanResult = getInstrumenter().startSpan(name, {\n            ...spanOptions,\n            packageName: packageName,\n            packageVersion: packageVersion,\n            tracingContext: operationOptions?.tracingOptions?.tracingContext,\n        });\n        let tracingContext = startSpanResult.tracingContext;\n        const span = startSpanResult.span;\n        if (!tracingContext.getValue(knownContextKeys.namespace)) {\n            tracingContext = tracingContext.setValue(knownContextKeys.namespace, namespace);\n        }\n        span.setAttribute(\"az.namespace\", tracingContext.getValue(knownContextKeys.namespace));\n        const updatedOptions = Object.assign({}, operationOptions, {\n            tracingOptions: { ...operationOptions?.tracingOptions, tracingContext },\n        });\n        return {\n            span,\n            updatedOptions,\n        };\n    }\n    async function withSpan(name, operationOptions, callback, spanOptions) {\n        const { span, updatedOptions } = startSpan(name, operationOptions, spanOptions);\n        try {\n            const result = await withContext(updatedOptions.tracingOptions.tracingContext, () => Promise.resolve(callback(updatedOptions, span)));\n            span.setStatus({ status: \"success\" });\n            return result;\n        }\n        catch (err) {\n            span.setStatus({ status: \"error\", error: err });\n            throw err;\n        }\n        finally {\n            span.end();\n        }\n    }\n    function withContext(context, callback, ...callbackArgs) {\n        return getInstrumenter().withContext(context, callback, ...callbackArgs);\n    }\n    /**\n     * Parses a traceparent header value into a span identifier.\n     *\n     * @param traceparentHeader - The traceparent header to parse.\n     * @returns An implementation-specific identifier for the span.\n     */\n    function parseTraceparentHeader(traceparentHeader) {\n        return getInstrumenter().parseTraceparentHeader(traceparentHeader);\n    }\n    /**\n     * Creates a set of request headers to propagate tracing information to a backend.\n     *\n     * @param tracingContext - The context containing the span to serialize.\n     * @returns The set of headers to add to a request.\n     */\n    function createRequestHeaders(tracingContext) {\n        return getInstrumenter().createRequestHeaders(tracingContext);\n    }\n    return {\n        startSpan,\n        withSpan,\n        withContext,\n        parseTraceparentHeader,\n        createRequestHeaders,\n    };\n}\n//# sourceMappingURL=tracingClient.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { AggregateAuthenticationError, CredentialUnavailableError } from \"../errors.js\";\nimport { credentialLogger, formatError, formatSuccess } from \"../util/logging.js\";\nimport { tracingClient } from \"../util/tracing.js\";\n/**\n * @internal\n */\nexport const logger = credentialLogger(\"ChainedTokenCredential\");\n/**\n * Enables multiple `TokenCredential` implementations to be tried in order until\n * one of the getToken methods returns an access token. For more information, see\n * [ChainedTokenCredential overview](https://aka.ms/azsdk/js/identity/credential-chains#use-chainedtokencredential-for-granularity).\n */\nexport class ChainedTokenCredential {\n    _sources = [];\n    /**\n     * Creates an instance of ChainedTokenCredential using the given credentials.\n     *\n     * @param sources - `TokenCredential` implementations to be tried in order.\n     *\n     * Example usage:\n     * ```ts snippet:chained_token_credential_example\n     * import { ClientSecretCredential, ChainedTokenCredential } from \"@azure/identity\";\n     *\n     * const tenantId = \"<tenant-id>\";\n     * const clientId = \"<client-id>\";\n     * const clientSecret = \"<client-secret>\";\n     * const anotherClientId = \"<another-client-id>\";\n     * const anotherSecret = \"<another-client-secret>\";\n     *\n     * const firstCredential = new ClientSecretCredential(tenantId, clientId, clientSecret);\n     * const secondCredential = new ClientSecretCredential(tenantId, anotherClientId, anotherSecret);\n     *\n     * const credentialChain = new ChainedTokenCredential(firstCredential, secondCredential);\n     * ```\n     */\n    constructor(...sources) {\n        this._sources = sources;\n    }\n    /**\n     * Returns the first access token returned by one of the chained\n     * `TokenCredential` implementations.  Throws an {@link AggregateAuthenticationError}\n     * when one or more credentials throws an {@link AuthenticationError} and\n     * no credentials have returned an access token.\n     *\n     * This method is called automatically by Azure SDK client libraries. You may call this method\n     * directly, but you must also handle token caching and token refreshing.\n     *\n     * @param scopes - The list of scopes for which the token will have access.\n     * @param options - The options used to configure any requests this\n     *                `TokenCredential` implementation might make.\n     */\n    async getToken(scopes, options = {}) {\n        const { token } = await this.getTokenInternal(scopes, options);\n        return token;\n    }\n    async getTokenInternal(scopes, options = {}) {\n        let token = null;\n        let successfulCredential;\n        const errors = [];\n        return tracingClient.withSpan(\"ChainedTokenCredential.getToken\", options, async (updatedOptions) => {\n            for (let i = 0; i < this._sources.length && token === null; i++) {\n                try {\n                    token = await this._sources[i].getToken(scopes, updatedOptions);\n                    successfulCredential = this._sources[i];\n                }\n                catch (err) {\n                    if (err.name === \"CredentialUnavailableError\" ||\n                        err.name === \"AuthenticationRequiredError\") {\n                        errors.push(err);\n                    }\n                    else {\n                        logger.getToken.info(formatError(scopes, err));\n                        throw err;\n                    }\n                }\n            }\n            if (!token && errors.length > 0) {\n                const err = new AggregateAuthenticationError(errors, \"ChainedTokenCredential authentication failed.\");\n                logger.getToken.info(formatError(scopes, err));\n                throw err;\n            }\n            logger.getToken.info(`Result for ${successfulCredential.constructor.name}: ${formatSuccess(scopes)}`);\n            if (token === null) {\n                throw new CredentialUnavailableError(\"Failed to retrieve a valid token\");\n            }\n            return { token, successfulCredential };\n        });\n    }\n}\n//# sourceMappingURL=chainedTokenCredential.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nimport { ChainedTokenCredential } from \"./chainedTokenCredential.js\";\nconst BrowserNotSupportedError = new Error(\"DefaultAzureCredential is not supported in the browser. Use InteractiveBrowserCredential instead.\");\nconst logger = credentialLogger(\"DefaultAzureCredential\");\n/**\n * Provides a default {@link ChainedTokenCredential} configuration for\n * applications that will be deployed to Azure.\n *\n * Only available in Node.js.\n */\nexport class DefaultAzureCredential extends ChainedTokenCredential {\n    /**\n     * Creates an instance of the DefaultAzureCredential class.\n     *\n     * @param options - Options for configuring the client which makes the authentication request.\n     */\n    constructor(_tokenCredentialOptions) {\n        super();\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=defaultAzureCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport * as tspRuntime from \"@typespec/ts-http-runtime/internal/util\";\nexport { cancelablePromiseRace, } from \"./aborterUtils.js\";\nexport { createAbortablePromise, } from \"./createAbortablePromise.js\";\nexport { delay } from \"./delay.js\";\nexport { getErrorMessage } from \"./error.js\";\nexport { isDefined, isObjectWithProperties, objectHasProperty } from \"./typeGuards.js\";\n/**\n * Calculates the delay interval for retry attempts using exponential delay with jitter.\n *\n * @param retryAttempt - The current retry attempt number.\n *\n * @param config - The exponential retry configuration.\n *\n * @returns An object containing the calculated retry delay.\n */\nexport function calculateRetryDelay(retryAttempt, config) {\n    return tspRuntime.calculateRetryDelay(retryAttempt, config);\n}\n/**\n * Generates a SHA-256 hash.\n *\n * @param content - The data to be included in the hash.\n *\n * @param encoding - The textual encoding to use for the returned hash.\n */\nexport function computeSha256Hash(content, encoding) {\n    return tspRuntime.computeSha256Hash(content, encoding);\n}\n/**\n * Generates a SHA-256 HMAC signature.\n *\n * @param key - The HMAC key represented as a base64 string, used to generate the cryptographic HMAC hash.\n *\n * @param stringToSign - The data to be signed.\n *\n * @param encoding - The textual encoding to use for the returned HMAC digest.\n */\nexport function computeSha256Hmac(key, stringToSign, encoding) {\n    return tspRuntime.computeSha256Hmac(key, stringToSign, encoding);\n}\n/**\n * Returns a random integer value between a lower and upper bound, inclusive of both bounds. Note that this uses Math.random and isn't secure. If you need to use this for any kind of security purpose, find a better source of random.\n *\n * @param min - The smallest integer value allowed.\n *\n * @param max - The largest integer value allowed.\n */\nexport function getRandomIntegerInclusive(min, max) {\n    return tspRuntime.getRandomIntegerInclusive(min, max);\n}\n/**\n * Typeguard for an error object shape (has name and message)\n *\n * @param e - Something caught by a catch clause.\n */\nexport function isError(e) {\n    return tspRuntime.isError(e);\n}\n/**\n * Helper to determine when an input is a generic JS object.\n *\n * @returns true when input is an object type that is not null, Array, RegExp, or Date.\n */\nexport function isObject(input) {\n    return tspRuntime.isObject(input);\n}\n/**\n * Generated Universally Unique Identifier\n *\n * @returns RFC4122 v4 UUID.\n */\nexport function randomUUID() {\n    return tspRuntime.randomUUID();\n}\n/**\n * A constant that indicates whether the environment the code is running is a Web Browser.\n */\nexport const isBrowser = tspRuntime.isBrowser;\n/**\n * A constant that indicates whether the environment the code is running is Bun.sh.\n */\nexport const isBun = tspRuntime.isBun;\n/**\n * A constant that indicates whether the environment the code is running is Deno.\n */\nexport const isDeno = tspRuntime.isDeno;\n/**\n * A constant that indicates whether the environment the code is running is a Node.js compatible environment.\n *\n * @deprecated\n *\n * Use `isNodeLike` instead.\n */\nexport const isNode = tspRuntime.isNodeLike;\n/**\n * A constant that indicates whether the environment the code is running is a Node.js compatible environment.\n */\nexport const isNodeLike = tspRuntime.isNodeLike;\n/**\n * A constant that indicates whether the environment the code is running is Node.JS.\n */\nexport const isNodeRuntime = tspRuntime.isNodeRuntime;\n/**\n * A constant that indicates whether the environment the code is running is in React-Native.\n */\nexport const isReactNative = tspRuntime.isReactNative;\n/**\n * A constant that indicates whether the environment the code is running is a Web Worker.\n */\nexport const isWebWorker = tspRuntime.isWebWorker;\n/**\n * The helper that transforms bytes with specific character encoding into string\n * @param bytes - the uint8array bytes\n * @param format - the format we use to encode the byte\n * @returns a string of the encoded string\n */\nexport function uint8ArrayToString(bytes, format) {\n    return tspRuntime.uint8ArrayToString(bytes, format);\n}\n/**\n * The helper that transforms string to specific character encoded bytes array.\n * @param value - the string to be converted\n * @param format - the format we use to decode the value\n * @returns a uint8array\n */\nexport function stringToUint8Array(value, format) {\n    return tspRuntime.stringToUint8Array(value, format);\n}\n//# sourceMappingURL=index.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { AuthenticationRequiredError, CredentialUnavailableError } from \"../errors.js\";\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nimport { DefaultAuthority, DefaultAuthorityHost, DefaultTenantId } from \"../constants.js\";\nimport { randomUUID as coreRandomUUID, isNode, isNodeLike } from \"@azure/core-util\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { msalCommon } from \"./msal.js\";\nconst logger = credentialLogger(\"IdentityUtils\");\n/**\n * Latest AuthenticationRecord version\n */\nconst LatestAuthenticationRecordVersion = \"1.0\";\n/**\n * Ensures the validity of the MSAL token\n * @internal\n */\nexport function ensureValidMsalToken(scopes, msalToken, getTokenOptions) {\n    const error = (message) => {\n        logger.getToken.info(message);\n        return new AuthenticationRequiredError({\n            scopes: Array.isArray(scopes) ? scopes : [scopes],\n            getTokenOptions,\n            message,\n        });\n    };\n    if (!msalToken) {\n        throw error(\"No response\");\n    }\n    if (!msalToken.expiresOn) {\n        throw error(`Response had no \"expiresOn\" property.`);\n    }\n    if (!msalToken.accessToken) {\n        throw error(`Response had no \"accessToken\" property.`);\n    }\n}\n/**\n * Returns the authority host from either the options bag or the AZURE_AUTHORITY_HOST environment variable.\n *\n * Defaults to {@link DefaultAuthorityHost}.\n * @internal\n */\nexport function getAuthorityHost(options) {\n    let authorityHost = options?.authorityHost;\n    if (!authorityHost && isNodeLike) {\n        authorityHost = process.env.AZURE_AUTHORITY_HOST;\n    }\n    return authorityHost ?? DefaultAuthorityHost;\n}\n/**\n * Generates a valid authority by combining a host with a tenantId.\n * @internal\n */\nexport function getAuthority(tenantId, host) {\n    if (!host) {\n        host = DefaultAuthorityHost;\n    }\n    if (new RegExp(`${tenantId}/?$`).test(host)) {\n        return host;\n    }\n    if (host.endsWith(\"/\")) {\n        return host + tenantId;\n    }\n    else {\n        return `${host}/${tenantId}`;\n    }\n}\n/**\n * Generates the known authorities.\n * If the Tenant Id is `adfs`, the authority can't be validated since the format won't match the expected one.\n * For that reason, we have to force MSAL to disable validating the authority\n * by sending it within the known authorities in the MSAL configuration.\n * @internal\n */\nexport function getKnownAuthorities(tenantId, authorityHost, disableInstanceDiscovery) {\n    if ((tenantId === \"adfs\" && authorityHost) || disableInstanceDiscovery) {\n        return [authorityHost];\n    }\n    return [];\n}\n/**\n * Generates a logger that can be passed to the MSAL clients.\n * @param credLogger - The logger of the credential.\n * @internal\n */\nexport const defaultLoggerCallback = (credLogger, platform = isNode ? \"Node\" : \"Browser\") => (level, message, containsPii) => {\n    if (containsPii) {\n        return;\n    }\n    switch (level) {\n        case msalCommon.LogLevel.Error:\n            credLogger.info(`MSAL ${platform} V2 error: ${message}`);\n            return;\n        case msalCommon.LogLevel.Info:\n            credLogger.info(`MSAL ${platform} V2 info message: ${message}`);\n            return;\n        case msalCommon.LogLevel.Verbose:\n            credLogger.info(`MSAL ${platform} V2 verbose message: ${message}`);\n            return;\n        case msalCommon.LogLevel.Warning:\n            credLogger.info(`MSAL ${platform} V2 warning: ${message}`);\n            return;\n    }\n};\n/**\n * @internal\n */\nexport function getMSALLogLevel(logLevel) {\n    switch (logLevel) {\n        case \"error\":\n            return msalCommon.LogLevel.Error;\n        case \"info\":\n            return msalCommon.LogLevel.Info;\n        case \"verbose\":\n            return msalCommon.LogLevel.Verbose;\n        case \"warning\":\n            return msalCommon.LogLevel.Warning;\n        default:\n            // default msal logging level should be Info\n            return msalCommon.LogLevel.Info;\n    }\n}\n/**\n * Wraps core-util's randomUUID in order to allow for mocking in tests.\n * This prepares the library for the upcoming core-util update to ESM.\n *\n * @internal\n * @returns A string containing a random UUID\n */\nexport function randomUUID() {\n    return coreRandomUUID();\n}\n/**\n * Handles MSAL errors.\n */\nexport function handleMsalError(scopes, error, getTokenOptions) {\n    if (error.name === \"AuthError\" ||\n        error.name === \"ClientAuthError\" ||\n        error.name === \"BrowserAuthError\") {\n        const msalError = error;\n        switch (msalError.errorCode) {\n            case \"endpoints_resolution_error\":\n                logger.info(formatError(scopes, error.message));\n                return new CredentialUnavailableError(error.message);\n            case \"device_code_polling_cancelled\":\n                return new AbortError(\"The authentication has been aborted by the caller.\");\n            case \"consent_required\":\n            case \"interaction_required\":\n            case \"login_required\":\n                logger.info(formatError(scopes, `Authentication returned errorCode ${msalError.errorCode}`));\n                break;\n            default:\n                logger.info(formatError(scopes, `Failed to acquire token: ${error.message}`));\n                break;\n        }\n    }\n    if (error.name === \"ClientConfigurationError\" ||\n        error.name === \"BrowserConfigurationAuthError\" ||\n        error.name === \"AbortError\" ||\n        error.name === \"AuthenticationError\") {\n        return error;\n    }\n    if (error.name === \"NativeAuthError\") {\n        logger.info(formatError(scopes, `Error from the native broker: ${error.message} with status code: ${error.statusCode}`));\n        return error;\n    }\n    return new AuthenticationRequiredError({ scopes, getTokenOptions, message: error.message });\n}\n// transformations\nexport function publicToMsal(account) {\n    return {\n        localAccountId: account.homeAccountId,\n        environment: account.authority,\n        username: account.username,\n        homeAccountId: account.homeAccountId,\n        tenantId: account.tenantId,\n    };\n}\nexport function msalToPublic(clientId, account) {\n    const record = {\n        authority: account.environment ?? DefaultAuthority,\n        homeAccountId: account.homeAccountId,\n        tenantId: account.tenantId || DefaultTenantId,\n        username: account.username,\n        clientId,\n        version: LatestAuthenticationRecordVersion,\n    };\n    return record;\n}\n/**\n * Serializes an `AuthenticationRecord` into a string.\n *\n * The output of a serialized authentication record will contain the following properties:\n *\n * - \"authority\"\n * - \"homeAccountId\"\n * - \"clientId\"\n * - \"tenantId\"\n * - \"username\"\n * - \"version\"\n *\n * To later convert this string to a serialized `AuthenticationRecord`, please use the exported function `deserializeAuthenticationRecord()`.\n */\nexport function serializeAuthenticationRecord(record) {\n    return JSON.stringify(record);\n}\n/**\n * Deserializes a previously serialized authentication record from a string into an object.\n *\n * The input string must contain the following properties:\n *\n * - \"authority\"\n * - \"homeAccountId\"\n * - \"clientId\"\n * - \"tenantId\"\n * - \"username\"\n * - \"version\"\n *\n * If the version we receive is unsupported, an error will be thrown.\n *\n * At the moment, the only available version is: \"1.0\", which is always set when the authentication record is serialized.\n *\n * @param serializedRecord - Authentication record previously serialized into string.\n * @returns AuthenticationRecord.\n */\nexport function deserializeAuthenticationRecord(serializedRecord) {\n    const parsed = JSON.parse(serializedRecord);\n    if (parsed.version && parsed.version !== LatestAuthenticationRecordVersion) {\n        throw Error(\"Unsupported AuthenticationRecord version\");\n    }\n    return parsed;\n}\n//# sourceMappingURL=utils.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createClientLogger } from \"@azure/logger\";\nexport const logger = createClientLogger(\"core-rest-pipeline\");\n//# sourceMappingURL=log.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { isNodeLike } from \"@azure/core-util\";\nfunction isNodeReadableStream(x) {\n    return Boolean(x && typeof x[\"pipe\"] === \"function\");\n}\nconst unimplementedMethods = {\n    arrayBuffer: () => {\n        throw new Error(\"Not implemented\");\n    },\n    bytes: () => {\n        throw new Error(\"Not implemented\");\n    },\n    slice: () => {\n        throw new Error(\"Not implemented\");\n    },\n    text: () => {\n        throw new Error(\"Not implemented\");\n    },\n};\n/**\n * Private symbol used as key on objects created using createFile containing the\n * original source of the file object.\n *\n * This is used in Node to access the original Node stream without using Blob#stream, which\n * returns a web stream. This is done to avoid a couple of bugs to do with Blob#stream and\n * Readable#to/fromWeb in Node versions we support:\n * - https://github.com/nodejs/node/issues/42694 (fixed in Node 18.14)\n * - https://github.com/nodejs/node/issues/48916 (fixed in Node 20.6)\n *\n * Once these versions are no longer supported, we may be able to stop doing this.\n *\n * @internal\n */\nconst rawContent = Symbol(\"rawContent\");\n/**\n * Type guard to check if a given object is a blob-like object with a raw content property.\n */\nexport function hasRawContent(x) {\n    return typeof x[rawContent] === \"function\";\n}\n/**\n * Extract the raw content from a given blob-like object. If the input was created using createFile\n * or createFileFromStream, the exact content passed into createFile/createFileFromStream will be used.\n * For true instances of Blob and File, returns the actual blob.\n *\n * @internal\n */\nexport function getRawContent(blob) {\n    if (hasRawContent(blob)) {\n        return blob[rawContent]();\n    }\n    else {\n        return blob;\n    }\n}\n/**\n * Create an object that implements the File interface. This object is intended to be\n * passed into RequestBodyType.formData, and is not guaranteed to work as expected in\n * other situations.\n *\n * Use this function to:\n * - Create a File object for use in RequestBodyType.formData in environments where the\n *   global File object is unavailable.\n * - Create a File-like object from a readable stream without reading the stream into memory.\n *\n * @param stream - the content of the file as a callback returning a stream. When a File object made using createFile is\n *                  passed in a request's form data map, the stream will not be read into memory\n *                  and instead will be streamed when the request is made. In the event of a retry, the\n *                  stream needs to be read again, so this callback SHOULD return a fresh stream if possible.\n * @param name - the name of the file.\n * @param options - optional metadata about the file, e.g. file name, file size, MIME type.\n */\nexport function createFileFromStream(stream, name, options = {}) {\n    return {\n        ...unimplementedMethods,\n        type: options.type ?? \"\",\n        lastModified: options.lastModified ?? new Date().getTime(),\n        webkitRelativePath: options.webkitRelativePath ?? \"\",\n        size: options.size ?? -1,\n        name,\n        stream: () => {\n            const s = stream();\n            if (isNodeReadableStream(s)) {\n                throw new Error(\"Not supported: a Node stream was provided as input to createFileFromStream.\");\n            }\n            return s;\n        },\n        [rawContent]: stream,\n    };\n}\n/**\n * Create an object that implements the File interface. This object is intended to be\n * passed into RequestBodyType.formData, and is not guaranteed to work as expected in\n * other situations.\n *\n * Use this function create a File object for use in RequestBodyType.formData in environments where the global File object is unavailable.\n *\n * @param content - the content of the file as a Uint8Array in memory.\n * @param name - the name of the file.\n * @param options - optional metadata about the file, e.g. file name, file size, MIME type.\n */\nexport function createFile(content, name, options = {}) {\n    if (isNodeLike) {\n        return {\n            ...unimplementedMethods,\n            type: options.type ?? \"\",\n            lastModified: options.lastModified ?? new Date().getTime(),\n            webkitRelativePath: options.webkitRelativePath ?? \"\",\n            size: content.byteLength,\n            name,\n            arrayBuffer: async () => content.buffer,\n            stream: () => new Blob([toArrayBuffer(content)]).stream(),\n            [rawContent]: () => content,\n        };\n    }\n    else {\n        return new File([toArrayBuffer(content)], name, options);\n    }\n}\nfunction toArrayBuffer(source) {\n    if (\"resize\" in source.buffer) {\n        // ArrayBuffer\n        return source;\n    }\n    // SharedArrayBuffer\n    return source.map((x) => x);\n}\n//# sourceMappingURL=file.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { multipartPolicyName as tspMultipartPolicyName, multipartPolicy as tspMultipartPolicy, } from \"@typespec/ts-http-runtime/internal/policies\";\nimport { getRawContent, hasRawContent } from \"../util/file.js\";\n/**\n * Name of multipart policy\n */\nexport const multipartPolicyName = tspMultipartPolicyName;\n/**\n * Pipeline policy for multipart requests\n */\nexport function multipartPolicy() {\n    const tspPolicy = tspMultipartPolicy();\n    return {\n        name: multipartPolicyName,\n        sendRequest: async (request, next) => {\n            if (request.multipartBody) {\n                for (const part of request.multipartBody.parts) {\n                    if (hasRawContent(part.body)) {\n                        part.body = getRawContent(part.body);\n                    }\n                }\n            }\n            return tspPolicy.sendRequest(request, next);\n        },\n    };\n}\n//# sourceMappingURL=multipartPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { RestError as TspRestError, isRestError as tspIsRestError, } from \"@typespec/ts-http-runtime\";\n/**\n * A custom error type for failed pipeline requests.\n */\n// eslint-disable-next-line @typescript-eslint/no-redeclare\nexport const RestError = TspRestError;\n/**\n * Typeguard for RestError\n * @param e - Something caught by a catch clause.\n */\nexport function isRestError(e) {\n    return tspIsRestError(e);\n}\n//# sourceMappingURL=restError.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createClientLogger } from \"@azure/logger\";\nimport { DEFAULT_RETRY_POLICY_COUNT } from \"../constants.js\";\nimport { retryPolicy as tspRetryPolicy, } from \"@typespec/ts-http-runtime/internal/policies\";\nconst retryPolicyLogger = createClientLogger(\"core-rest-pipeline retryPolicy\");\n/**\n * retryPolicy is a generic policy to enable retrying requests when certain conditions are met\n */\nexport function retryPolicy(strategies, options = { maxRetries: DEFAULT_RETRY_POLICY_COUNT }) {\n    // Cast is required since the TSP runtime retry strategy type is slightly different\n    // very deep down (using real AbortSignal vs. AbortSignalLike in RestError).\n    // In practice the difference doesn't actually matter.\n    return tspRetryPolicy(strategies, {\n        logger: retryPolicyLogger,\n        ...options,\n    });\n}\n//# sourceMappingURL=retryPolicy.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n/**\n * Browser-only implementation of the module's state. The browser esm variant will not load the commonjs state, so we do not need to share state between the two.\n */\nexport const state = {\n    operationRequestMap: new WeakMap(),\n};\n//# sourceMappingURL=state-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { state } from \"./state.js\";\n/**\n * @internal\n * Retrieves the value to use for a given operation argument\n * @param operationArguments - The arguments passed from the generated client\n * @param parameter - The parameter description\n * @param fallbackObject - If something isn't found in the arguments bag, look here.\n *  Generally used to look at the service client properties.\n */\nexport function getOperationArgumentValueFromParameter(operationArguments, parameter, fallbackObject) {\n    let parameterPath = parameter.parameterPath;\n    const parameterMapper = parameter.mapper;\n    let value;\n    if (typeof parameterPath === \"string\") {\n        parameterPath = [parameterPath];\n    }\n    if (Array.isArray(parameterPath)) {\n        if (parameterPath.length > 0) {\n            if (parameterMapper.isConstant) {\n                value = parameterMapper.defaultValue;\n            }\n            else {\n                let propertySearchResult = getPropertyFromParameterPath(operationArguments, parameterPath);\n                if (!propertySearchResult.propertyFound && fallbackObject) {\n                    propertySearchResult = getPropertyFromParameterPath(fallbackObject, parameterPath);\n                }\n                let useDefaultValue = false;\n                if (!propertySearchResult.propertyFound) {\n                    useDefaultValue =\n                        parameterMapper.required ||\n                            (parameterPath[0] === \"options\" && parameterPath.length === 2);\n                }\n                value = useDefaultValue ? parameterMapper.defaultValue : propertySearchResult.propertyValue;\n            }\n        }\n    }\n    else {\n        if (parameterMapper.required) {\n            value = {};\n        }\n        for (const propertyName in parameterPath) {\n            const propertyMapper = parameterMapper.type.modelProperties[propertyName];\n            const propertyPath = parameterPath[propertyName];\n            const propertyValue = getOperationArgumentValueFromParameter(operationArguments, {\n                parameterPath: propertyPath,\n                mapper: propertyMapper,\n            }, fallbackObject);\n            if (propertyValue !== undefined) {\n                if (!value) {\n                    value = {};\n                }\n                value[propertyName] = propertyValue;\n            }\n        }\n    }\n    return value;\n}\nfunction getPropertyFromParameterPath(parent, parameterPath) {\n    const result = { propertyFound: false };\n    let i = 0;\n    for (; i < parameterPath.length; ++i) {\n        const parameterPathPart = parameterPath[i];\n        // Make sure to check inherited properties too, so don't use hasOwnProperty().\n        if (parent && parameterPathPart in parent) {\n            parent = parent[parameterPathPart];\n        }\n        else {\n            break;\n        }\n    }\n    if (i === parameterPath.length) {\n        result.propertyValue = parent;\n        result.propertyFound = true;\n    }\n    return result;\n}\nconst originalRequestSymbol = Symbol.for(\"@azure/core-client original request\");\nfunction hasOriginalRequest(request) {\n    return originalRequestSymbol in request;\n}\nexport function getOperationRequestInfo(request) {\n    if (hasOriginalRequest(request)) {\n        return getOperationRequestInfo(request[originalRequestSymbol]);\n    }\n    let info = state.operationRequestMap.get(request);\n    if (!info) {\n        info = {};\n        state.operationRequestMap.set(request, info);\n    }\n    return info;\n}\n//# sourceMappingURL=operationHelpers.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createClientLogger } from \"@azure/logger\";\nexport const logger = createClientLogger(\"core-client\");\n//# sourceMappingURL=log.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { createHttpHeaders, createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { credentialLogger, formatError, formatSuccess } from \"../util/logging.js\";\nimport { processMultiTenantRequest, resolveAdditionallyAllowedTenantIds, } from \"../util/tenantIdUtils.js\";\nimport { IdentityClient } from \"../client/identityClient.js\";\nimport { getIdentityTokenEndpointSuffix } from \"../util/identityTokenEndpoint.js\";\nimport { tracingClient } from \"../util/tracing.js\";\nconst logger = credentialLogger(\"ClientSecretCredential\");\n// This credential is exported on browser bundles for development purposes.\n// For this credential to work in browsers, browsers would need to have security features disabled.\n// Please do not disable your browser security features.\n/**\n * Enables authentication to Microsoft Entra ID using a client secret\n * that was generated for an App Registration.  More information on how\n * to configure a client secret can be found here:\n *\n * https://learn.microsoft.com/en-us/azure/active-directory/develop/quickstart-configure-app-access-web-apis#add-credentials-to-your-web-application\n *\n */\nexport class ClientSecretCredential {\n    identityClient;\n    tenantId;\n    additionallyAllowedTenantIds;\n    clientId;\n    clientSecret;\n    /**\n     * Creates an instance of the ClientSecretCredential with the details\n     * needed to authenticate against Microsoft Entra ID with a client\n     * secret.\n     *\n     * @param tenantId - The Microsoft Entra tenant (directory) ID.\n     * @param clientId - The client (application) ID of an App Registration in the tenant.\n     * @param clientSecret - A client secret that was generated for the App Registration.\n     * @param options - Options for configuring the client which makes the authentication request.\n     */\n    constructor(tenantId, clientId, clientSecret, options) {\n        this.identityClient = new IdentityClient(options);\n        this.tenantId = tenantId;\n        this.additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds(options?.additionallyAllowedTenants);\n        this.clientId = clientId;\n        this.clientSecret = clientSecret;\n    }\n    /**\n     * Authenticates with Microsoft Entra ID and returns an access token if\n     * successful.  If authentication cannot be performed at this time, this method may\n     * return null.  If an error occurs during authentication, an {@link AuthenticationError}\n     * containing failure details will be thrown.\n     *\n     * @param scopes - The list of scopes for which the token will have access.\n     * @param options - The options used to configure any requests this\n     *                TokenCredential implementation might make.\n     */\n    async getToken(scopes, options = {}) {\n        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {\n            const tenantId = processMultiTenantRequest(this.tenantId, newOptions, this.additionallyAllowedTenantIds);\n            const query = new URLSearchParams({\n                response_type: \"token\",\n                grant_type: \"client_credentials\",\n                client_id: this.clientId,\n                client_secret: this.clientSecret,\n                scope: typeof scopes === \"string\" ? scopes : scopes.join(\" \"),\n            });\n            try {\n                const urlSuffix = getIdentityTokenEndpointSuffix(tenantId);\n                const request = createPipelineRequest({\n                    url: `${this.identityClient.authorityHost}/${tenantId}/${urlSuffix}`,\n                    method: \"POST\",\n                    body: query.toString(),\n                    headers: createHttpHeaders({\n                        Accept: \"application/json\",\n                        \"Content-Type\": \"application/x-www-form-urlencoded\",\n                    }),\n                    abortSignal: options && options.abortSignal,\n                    tracingOptions: newOptions?.tracingOptions,\n                });\n                const tokenResponse = await this.identityClient.sendTokenRequest(request);\n                logger.getToken.info(formatSuccess(scopes));\n                return (tokenResponse && tokenResponse.accessToken) || null;\n            }\n            catch (err) {\n                logger.getToken.info(formatError(scopes, err));\n                throw err;\n            }\n        });\n    }\n}\n//# sourceMappingURL=clientSecretCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"EnvironmentCredential is not supported in the browser.\");\nconst logger = credentialLogger(\"EnvironmentCredential\");\n/**\n * Enables authentication to Microsoft Entra ID using client secret\n * details configured in environment variables\n */\nexport class EnvironmentCredential {\n    /**\n     * Only available in Node.js\n     */\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=environmentCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"ClientCertificateCredential is not supported in the browser.\");\nconst logger = credentialLogger(\"ClientCertificateCredential\");\n/**\n * Enables authentication to Microsoft Entra ID using a PEM-encoded\n * certificate that is assigned to an App Registration.\n */\nexport class ClientCertificateCredential {\n    /**\n     * Only available in Node.js\n     */\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=clientCertificateCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"ClientAssertionCredential is not supported in the browser.\");\nconst logger = credentialLogger(\"ClientAssertionCredential\");\n/**\n * Authenticates a service principal with a JWT assertion.\n */\nexport class ClientAssertionCredential {\n    /**\n     * Only available in Node.js\n     */\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=clientAssertionCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"AzureCliCredential is not supported in the browser.\");\nconst logger = credentialLogger(\"AzureCliCredential\");\n/**\n * This credential will use the currently logged-in user login information\n * via the Azure CLI ('az') commandline tool.\n */\nexport class AzureCliCredential {\n    /**\n     * Only available in Node.js\n     */\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=azureCliCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"AzureDeveloperCliCredential is not supported in the browser.\");\nconst logger = credentialLogger(\"AzureDeveloperCliCredential\");\n/**\n * This credential will use the currently logged-in user login information\n * via the Azure Developer CLI ('azd') commandline tool.\n */\nexport class AzureDeveloperCliCredential {\n    /**\n     * Only available in Node.js\n     */\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=azureDeveloperCliCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport * as msalBrowser from \"@azure/msal-browser\";\nimport { defaultLoggerCallback, ensureValidMsalToken, getAuthority, getKnownAuthorities, getMSALLogLevel, handleMsalError, msalToPublic, publicToMsal, } from \"../utils.js\";\nimport { AuthenticationRequiredError, CredentialUnavailableError } from \"../../errors.js\";\nimport { getLogLevel } from \"@azure/logger\";\nimport { formatSuccess } from \"../../util/logging.js\";\nimport { processMultiTenantRequest, resolveAdditionallyAllowedTenantIds, resolveTenantId, } from \"../../util/tenantIdUtils.js\";\nimport { DefaultTenantId } from \"../../constants.js\";\n// We keep a copy of the redirect hash.\n// Check if self and location object is defined.\nconst isLocationDefined = typeof self !== \"undefined\" && self.location !== undefined;\n/**\n * Generates a MSAL configuration that generally works for browsers\n */\nfunction generateMsalBrowserConfiguration(options) {\n    const tenantId = options.tenantId || DefaultTenantId;\n    const authority = getAuthority(tenantId, options.authorityHost);\n    return {\n        auth: {\n            clientId: options.clientId,\n            authority,\n            knownAuthorities: getKnownAuthorities(tenantId, authority, options.disableInstanceDiscovery),\n            // If the users picked redirect as their login style,\n            // but they didn't provide a redirectUri,\n            // we can try to use the current page we're in as a default value.\n            redirectUri: options.redirectUri || (isLocationDefined ? self.location.origin : undefined),\n        },\n        cache: {\n            cacheLocation: \"sessionStorage\",\n            storeAuthStateInCookie: true, // Set to true to improve the experience on IE11 and Edge.\n        },\n        system: {\n            loggerOptions: {\n                loggerCallback: defaultLoggerCallback(options.logger, \"Browser\"),\n                logLevel: getMSALLogLevel(getLogLevel()),\n                piiLoggingEnabled: options.loggingOptions?.enableUnsafeSupportLogging,\n            },\n        },\n    };\n}\n// We keep a copy of the redirect hash.\nconst redirectHash = isLocationDefined ? self.location.hash : undefined;\n/**\n * Uses MSAL Browser 2.X for browser authentication,\n * which uses the [Auth Code Flow](https://learn.microsoft.com/azure/active-directory/develop/v2-oauth2-auth-code-flow).\n * @internal\n */\nexport function createMsalBrowserClient(options) {\n    const loginStyle = options.loginStyle;\n    if (!options.clientId) {\n        throw new CredentialUnavailableError(\"A client ID is required in browsers\");\n    }\n    const clientId = options.clientId;\n    const logger = options.logger;\n    const tenantId = resolveTenantId(logger, options.tenantId, options.clientId);\n    const additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds(options?.tokenCredentialOptions?.additionallyAllowedTenants);\n    const authorityHost = options.authorityHost;\n    const msalConfig = generateMsalBrowserConfiguration(options);\n    const disableAutomaticAuthentication = options.disableAutomaticAuthentication;\n    const loginHint = options.loginHint;\n    let account;\n    if (options.authenticationRecord) {\n        account = {\n            ...options.authenticationRecord,\n            tenantId,\n        };\n    }\n    // This variable should only be used through calling `getApp` function\n    let app;\n    /**\n     * Return the MSAL account if not set yet\n     * @returns MSAL application\n     */\n    async function getApp() {\n        if (!app) {\n            // Prepare the MSAL application\n            app = await msalBrowser.PublicClientApplication.createPublicClientApplication(msalConfig);\n            // setting the account right after the app is created.\n            if (account) {\n                app.setActiveAccount(publicToMsal(account));\n            }\n        }\n        return app;\n    }\n    /**\n     * Loads the account based on the result of the authentication.\n     * If no result was received, tries to load the account from the cache.\n     * @param result - Result object received from MSAL.\n     */\n    async function handleBrowserResult(result) {\n        try {\n            const msalApp = await getApp();\n            if (result && result.account) {\n                logger.info(`MSAL Browser V2 authentication successful.`);\n                msalApp.setActiveAccount(result.account);\n                return msalToPublic(clientId, result.account);\n            }\n        }\n        catch (e) {\n            logger.info(`Failed to acquire token through MSAL. ${e.message}`);\n        }\n        return;\n    }\n    /**\n     * Handles the MSAL authentication result.\n     * If the result has an account, we update the local account reference.\n     * If the token received is invalid, an error will be thrown depending on what's missing.\n     */\n    function handleResult(scopes, result, getTokenOptions) {\n        if (result?.account) {\n            account = msalToPublic(clientId, result.account);\n        }\n        ensureValidMsalToken(scopes, result, getTokenOptions);\n        logger.getToken.info(formatSuccess(scopes));\n        return {\n            token: result.accessToken,\n            expiresOnTimestamp: result.expiresOn.getTime(),\n            refreshAfterTimestamp: result.refreshOn?.getTime(),\n            tokenType: \"Bearer\",\n        };\n    }\n    /**\n     * Uses MSAL to handle the redirect.\n     */\n    async function handleRedirect() {\n        const msalApp = await getApp();\n        return handleBrowserResult((await msalApp.handleRedirectPromise(redirectHash)) || undefined);\n    }\n    /**\n     * Uses MSAL to retrieve the active account.\n     */\n    async function getActiveAccount() {\n        const msalApp = await getApp();\n        const activeAccount = msalApp.getActiveAccount();\n        if (!activeAccount) {\n            return;\n        }\n        return msalToPublic(clientId, activeAccount);\n    }\n    /**\n     * Uses MSAL to trigger a redirect or a popup login.\n     */\n    async function login(scopes = []) {\n        const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];\n        const loginRequest = {\n            scopes: arrayScopes,\n            loginHint: loginHint,\n        };\n        const msalApp = await getApp();\n        switch (loginStyle) {\n            case \"redirect\": {\n                await app.loginRedirect(loginRequest);\n                return;\n            }\n            case \"popup\":\n                return handleBrowserResult(await msalApp.loginPopup(loginRequest));\n        }\n    }\n    /**\n     * Tries to retrieve the token silently using MSAL.\n     */\n    async function getTokenSilent(scopes, getTokenOptions) {\n        const activeAccount = await getActiveAccount();\n        if (!activeAccount) {\n            throw new AuthenticationRequiredError({\n                scopes,\n                getTokenOptions,\n                message: \"Silent authentication failed. We couldn't retrieve an active account from the cache.\",\n            });\n        }\n        const parameters = {\n            authority: getTokenOptions?.authority || msalConfig.auth.authority,\n            correlationId: getTokenOptions?.correlationId,\n            claims: getTokenOptions?.claims,\n            account: publicToMsal(activeAccount),\n            forceRefresh: false,\n            scopes,\n        };\n        try {\n            logger.info(\"Attempting to acquire token silently\");\n            const msalApp = await getApp();\n            const response = await msalApp.acquireTokenSilent(parameters);\n            return handleResult(scopes, response);\n        }\n        catch (err) {\n            throw handleMsalError(scopes, err, options);\n        }\n    }\n    /**\n     * Attempts to retrieve the token in the browser through interactive methods.\n     */\n    async function getTokenInteractive(scopes, getTokenOptions) {\n        const activeAccount = await getActiveAccount();\n        if (!activeAccount) {\n            throw new AuthenticationRequiredError({\n                scopes,\n                getTokenOptions,\n                message: \"Silent authentication failed. We couldn't retrieve an active account from the cache.\",\n            });\n        }\n        const parameters = {\n            authority: getTokenOptions?.authority || msalConfig.auth.authority,\n            correlationId: getTokenOptions?.correlationId,\n            claims: getTokenOptions?.claims,\n            account: publicToMsal(activeAccount),\n            loginHint: loginHint,\n            scopes,\n        };\n        const msalApp = await getApp();\n        switch (loginStyle) {\n            case \"redirect\":\n                // This will go out of the page.\n                // Once the InteractiveBrowserCredential is initialized again,\n                // we'll load the MSAL account in the constructor.\n                await msalApp.acquireTokenRedirect(parameters);\n                return { token: \"\", expiresOnTimestamp: 0, tokenType: \"Bearer\" };\n            case \"popup\":\n                return handleResult(scopes, await app.acquireTokenPopup(parameters));\n        }\n    }\n    /**\n     * Attempts to get token through the silent flow.\n     * If failed, get token through interactive method with `doGetToken` method.\n     */\n    async function getToken(scopes, getTokenOptions = {}) {\n        const getTokenTenantId = processMultiTenantRequest(tenantId, getTokenOptions, additionallyAllowedTenantIds) ||\n            tenantId;\n        if (!getTokenOptions.authority) {\n            getTokenOptions.authority = getAuthority(getTokenTenantId, authorityHost);\n        }\n        // We ensure that redirection is handled at this point.\n        await handleRedirect();\n        if (!(await getActiveAccount()) && !disableAutomaticAuthentication) {\n            await login(scopes);\n        }\n        // Attempts to get the token silently; else, falls back to interactive method.\n        try {\n            return await getTokenSilent(scopes, getTokenOptions);\n        }\n        catch (err) {\n            if (err.name !== \"AuthenticationRequiredError\") {\n                throw err;\n            }\n            if (getTokenOptions?.disableAutomaticAuthentication) {\n                throw new AuthenticationRequiredError({\n                    scopes,\n                    getTokenOptions,\n                    message: \"Automatic authentication has been disabled. You may call the authenticate() method.\",\n                });\n            }\n            logger.info(`Silent authentication failed, falling back to interactive method ${loginStyle}`);\n            return getTokenInteractive(scopes, getTokenOptions);\n        }\n    }\n    return {\n        getActiveAccount,\n        getToken,\n    };\n}\n//# sourceMappingURL=msalBrowserCommon.js.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nimport { processMultiTenantRequest, resolveAdditionallyAllowedTenantIds, } from \"../util/tenantIdUtils.js\";\nimport { ensureScopes } from \"../util/scopeUtils.js\";\nimport { tracingClient } from \"../util/tracing.js\";\nimport { createMsalBrowserClient } from \"../msal/browserFlows/msalBrowserCommon.js\";\nconst logger = credentialLogger(\"InteractiveBrowserCredential\");\n/**\n * Enables authentication to Microsoft Entra ID inside of the web browser\n * using the interactive login flow.\n */\nexport class InteractiveBrowserCredential {\n    tenantId;\n    additionallyAllowedTenantIds;\n    msalClient;\n    disableAutomaticAuthentication;\n    /**\n     * Creates an instance of the InteractiveBrowserCredential with the\n     * details needed to authenticate against Microsoft Entra ID with\n     * a user identity.\n     *\n     * This credential uses the [Authorization Code Flow](https://learn.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow).\n     * On Node.js, it will open a browser window while it listens for a redirect response from the authentication service.\n     * On browsers, it authenticates via popups. The `loginStyle` optional parameter can be set to `redirect` to authenticate by redirecting the user to an Azure secure login page, which then will redirect the user back to the web application where the authentication started.\n     *\n     * It's recommended that the Microsoft Entra Applications used are configured to authenticate using Single Page Applications.\n     * More information here: [link](https://learn.microsoft.com/en-us/azure/active-directory/develop/scenario-spa-app-registration#redirect-uri-msaljs-20-with-auth-code-flow).\n     *\n     * @param options - Options for configuring the client which makes the authentication request.\n     */\n    constructor(options) {\n        if (!options?.clientId) {\n            const error = new Error(\"The parameter `clientId` cannot be left undefined for the `InteractiveBrowserCredential`\");\n            logger.info(formatError(\"\", error));\n            throw error;\n        }\n        this.tenantId = options?.tenantId;\n        this.additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds(options?.additionallyAllowedTenants);\n        const browserOptions = options;\n        const loginStyle = browserOptions.loginStyle || \"popup\";\n        const loginStyles = [\"redirect\", \"popup\"];\n        if (loginStyles.indexOf(loginStyle) === -1) {\n            const error = new Error(`Invalid loginStyle: ${browserOptions.loginStyle}. Should be any of the following: ${loginStyles.join(\", \")}.`);\n            logger.info(formatError(\"\", error));\n            throw error;\n        }\n        const msalOptions = {\n            ...options,\n            tokenCredentialOptions: options,\n            logger,\n            loginStyle: loginStyle,\n            redirectUri: typeof options.redirectUri === \"function\" ? options.redirectUri() : options.redirectUri,\n        };\n        this.msalClient = createMsalBrowserClient(msalOptions);\n        this.disableAutomaticAuthentication = options?.disableAutomaticAuthentication;\n    }\n    /**\n     * Authenticates with Microsoft Entra ID and returns an access token if successful.\n     * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.\n     *\n     * If the user provided the option `disableAutomaticAuthentication`,\n     * once the token can't be retrieved silently,\n     * this method won't attempt to request user interaction to retrieve the token.\n     *\n     * @param scopes - The list of scopes for which the token will have access.\n     * @param options - The options used to configure any requests this\n     *                TokenCredential implementation might make.\n     */\n    async getToken(scopes, options = {}) {\n        return tracingClient.withSpan(`${this.constructor.name}.getToken`, options, async (newOptions) => {\n            const tenantId = processMultiTenantRequest(this.tenantId, newOptions, this.additionallyAllowedTenantIds);\n            newOptions.tenantId = tenantId;\n            const arrayScopes = ensureScopes(scopes);\n            return this.msalClient.getToken(arrayScopes, {\n                ...newOptions,\n                disableAutomaticAuthentication: this.disableAutomaticAuthentication,\n            });\n        });\n    }\n    /**\n     * Authenticates with Microsoft Entra ID and returns an access token if successful.\n     * If authentication fails, a {@link CredentialUnavailableError} will be thrown with the details of the failure.\n     *\n     * If the token can't be retrieved silently, this method will require user interaction to retrieve the token.\n     *\n     * @param scopes - The list of scopes for which the token will have access.\n     * @param options - The options used to configure any requests this\n     *                  TokenCredential implementation might make.\n     */\n    async authenticate(scopes, options = {}) {\n        return tracingClient.withSpan(`${this.constructor.name}.authenticate`, options, async (newOptions) => {\n            const arrayScopes = Array.isArray(scopes) ? scopes : [scopes];\n            await this.msalClient.getToken(arrayScopes, newOptions);\n            return this.msalClient.getActiveAccount();\n        });\n    }\n}\n//# sourceMappingURL=interactiveBrowserCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"ManagedIdentityCredential is not supported in the browser.\");\nconst logger = credentialLogger(\"ManagedIdentityCredential\");\nexport class ManagedIdentityCredential {\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    async getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=index-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"DeviceCodeCredential is not supported in the browser.\");\nconst logger = credentialLogger(\"DeviceCodeCredential\");\n/**\n * Enables authentication to Microsoft Entra ID using a device code\n * that the user can enter into https://microsoft.com/devicelogin.\n */\nexport class DeviceCodeCredential {\n    /**\n     * Only available in Node.js\n     */\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=deviceCodeCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"AzurePipelinesCredential is not supported in the browser.\");\nconst logger = credentialLogger(\"AzurePipelinesCredential\");\n/**\n * Enables authentication to Microsoft Entra ID using a PEM-encoded\n * certificate that is assigned to an App Registration.\n */\nexport class AzurePipelinesCredential {\n    /**\n     * Only available in Node.js\n     */\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=azurePipelinesCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"AuthorizationCodeCredential is not supported in the browser. InteractiveBrowserCredential is more appropriate for this use case.\");\nconst logger = credentialLogger(\"AuthorizationCodeCredential\");\nexport class AuthorizationCodeCredential {\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=authorizationCodeCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"AzurePowerShellCredential is not supported in the browser.\");\nconst logger = credentialLogger(\"AzurePowerShellCredential\");\n/**\n * This credential will use the currently-logged-in user's login information via the Azure Power Shell command line tool.\n */\nexport class AzurePowerShellCredential {\n    /**\n     * Only available in Node.js\n     */\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=azurePowerShellCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { checkTenantId, processMultiTenantRequest, resolveAdditionallyAllowedTenantIds, } from \"../util/tenantIdUtils.js\";\nimport { createHttpHeaders, createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { credentialLogger, formatSuccess } from \"../util/logging.js\";\nimport { IdentityClient } from \"../client/identityClient.js\";\nimport { getIdentityTokenEndpointSuffix } from \"../util/identityTokenEndpoint.js\";\nimport { tracingClient } from \"../util/tracing.js\";\nconst logger = credentialLogger(\"UsernamePasswordCredential\");\n/**\n * Enables authentication to Microsoft Entra ID with a user's\n * username and password. This credential requires a high degree of\n * trust so you should only use it when other, more secure credential\n * types can't be used.\n *\n * @deprecated UsernamePasswordCredential is deprecated. Use a more secure credential. See https://aka.ms/azsdk/identity/mfa for details.\n */\nexport class UsernamePasswordCredential {\n    identityClient;\n    tenantId;\n    additionallyAllowedTenantIds;\n    clientId;\n    username;\n    password;\n    /**\n     * Creates an instance of the UsernamePasswordCredential with the details\n     * needed to authenticate against Microsoft Entra ID with a username\n     * and password.\n     *\n     * @param tenantIdOrName - The Microsoft Entra tenant (directory) ID or name.\n     * @param clientId - The client (application) ID of an App Registration in the tenant.\n     * @param username - The user account's e-mail address (user name).\n     * @param password - The user account's account password\n     * @param options - Options for configuring the client which makes the authentication request.\n     *\n     */\n    constructor(tenantIdOrName, clientId, username, password, options) {\n        checkTenantId(logger, tenantIdOrName);\n        this.identityClient = new IdentityClient(options);\n        this.tenantId = tenantIdOrName;\n        this.additionallyAllowedTenantIds = resolveAdditionallyAllowedTenantIds(options?.additionallyAllowedTenants);\n        this.clientId = clientId;\n        this.username = username;\n        this.password = password;\n    }\n    /**\n     * Authenticates with Microsoft Entra ID and returns an access token if\n     * successful.  If authentication cannot be performed at this time, this method may\n     * return null.  If an error occurs during authentication, an {@link AuthenticationError}\n     * containing failure details will be thrown.\n     *\n     * @param scopes - The list of scopes for which the token will have access.\n     * @param options - The options used to configure any requests this\n     *                TokenCredential implementation might make.\n     */\n    async getToken(scopes, options = {}) {\n        return tracingClient.withSpan(\"UsernamePasswordCredential.getToken\", options, async (newOptions) => {\n            const tenantId = processMultiTenantRequest(this.tenantId, newOptions, this.additionallyAllowedTenantIds);\n            newOptions.tenantId = tenantId;\n            const urlSuffix = getIdentityTokenEndpointSuffix(this.tenantId);\n            const params = new URLSearchParams({\n                response_type: \"token\",\n                grant_type: \"password\",\n                client_id: this.clientId,\n                username: this.username,\n                password: this.password,\n                scope: typeof scopes === \"string\" ? scopes : scopes.join(\" \"),\n            });\n            const webResource = createPipelineRequest({\n                url: `${this.identityClient.authorityHost}/${this.tenantId}/${urlSuffix}`,\n                method: \"POST\",\n                body: params.toString(),\n                headers: createHttpHeaders({\n                    Accept: \"application/json\",\n                    \"Content-Type\": \"application/x-www-form-urlencoded\",\n                }),\n                abortSignal: options && options.abortSignal,\n                tracingOptions: newOptions.tracingOptions,\n            });\n            const tokenResponse = await this.identityClient.sendTokenRequest(webResource);\n            logger.getToken.info(formatSuccess(scopes));\n            return (tokenResponse && tokenResponse.accessToken) || null;\n        });\n    }\n}\n//# sourceMappingURL=usernamePasswordCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"VisualStudioCodeCredential is not supported in the browser.\");\nconst logger = credentialLogger(\"VisualStudioCodeCredential\");\nexport const vsCodeCredentialControl = {\n    set vsCodeCredentialFinder(_finder) {\n        throw new Error(\"Attempted to register a VisualStudioCodeCredential provider plugin in the browser. This environment is not supported by VisualStudioCodeCredential.\");\n    },\n};\n/**\n * Connects to Azure using the credential provided by the VSCode extension 'Azure Account'.\n *\n * @deprecated This credential is deprecated because the VS Code Azure Account extension on which this credential\n * relies has been deprecated. Users should use other dev-time credentials, such as {@link AzureCliCredential},\n * {@link AzureDeveloperCliCredential}, or {@link AzurePowerShellCredential} for their\n * local development needs. See Azure account extension deprecation notice [here](https://github.com/microsoft/vscode-azure-account/issues/964).\n */\nexport class VisualStudioCodeCredential {\n    /**\n     * Only available in Node.js\n     */\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=visualStudioCodeCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst credentialName = \"OnBehalfOfCredential\";\nconst BrowserNotSupportedError = new Error(`${credentialName}: Not supported in the browser.`);\nconst logger = credentialLogger(credentialName);\n/**\n * Enables authentication to Microsoft Entra ID using the [On Behalf Of flow](https://learn.microsoft.com/entra/identity-platform/v2-oauth2-on-behalf-of-flow).\n */\nexport class OnBehalfOfCredential {\n    /**\n     * Only available in Node.js\n     */\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=onBehalfOfCredential-browser.mjs.map","// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\nimport { credentialLogger, formatError } from \"../util/logging.js\";\nconst BrowserNotSupportedError = new Error(\"WorkloadIdentityCredential is not supported in the browser.\");\nconst logger = credentialLogger(\"WorkloadIdentityCredential\");\n/**\n * WorkloadIdentityCredential supports Microsoft Entra Workload ID authentication on Kubernetes.\n * Refer to <a href=\"https://learn.microsoft.com/azure/aks/workload-identity-overview\">Microsoft Entra Workload ID</a>\n * for more information.\n */\nexport class WorkloadIdentityCredential {\n    /**\n     * Only available in Node.js\n     */\n    constructor() {\n        logger.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n    /**\n     * Only available in Node.js\n     */\n    getToken() {\n        logger.getToken.info(formatError(\"\", BrowserNotSupportedError));\n        throw BrowserNotSupportedError;\n    }\n}\n//# sourceMappingURL=workloadIdentityCredential-browser.mjs.map"],"names":["Symbol","Error","WeakMap","self","c"],"mappings":"mGAGA,IAAM,EAAU,G,QAAA,GAAoB,CAChC,mBAAoB,kBACpB,UAAW,OACf,GA8BO,SAAS,EAAmB,CAAS,EACxC,OAAO,EAAQ,kBAAkB,CAAC,EACtC,CA1B2B,EAAQ,MAAM,C,SCNlC,IAAM,EAAS,EAAmB,YAkDlC,SAAS,EAAyB,CAAK,CAAE,CAAM,CAAE,EAAM,CAAM,EAChE,IAAM,EAAY,EAAS,CAAC,EAAE,EAAO,SAAS,CAAC,CAAC,EAAE,EAAM,CAAC,CAAG,EAa5D,MAAO,CACH,QACA,YACA,KAfJ,SAAc,CAAO,EACjB,EAAI,IAAI,CAAC,CAAC,EAAE,EAAU,GAAG,CAAC,CAAE,EAChC,EAcI,QAbJ,SAAiB,CAAO,EACpB,EAAI,OAAO,CAAC,CAAC,EAAE,EAAU,GAAG,CAAC,CAAE,EACnC,EAYI,QAXJ,SAAiB,CAAO,EACpB,EAAI,OAAO,CAAC,CAAC,EAAE,EAAU,GAAG,CAAC,CAAE,EACnC,EAUI,MATJ,SAAe,CAAO,EAClB,EAAI,KAAK,CAAC,CAAC,EAAE,EAAU,GAAG,CAAC,CAAE,EACjC,CAQA,CACJ,CAWO,SAAS,EAAiB,CAAK,CAAE,EAAM,CAAM,EAChD,IAAM,EAAa,EAAyB,EAAO,OAAW,GAC9D,MAAO,CACH,GAAG,CAAU,CACb,OAAQ,EACR,SAAU,EAAyB,gBAAiB,EAAY,EACpE,CACJ,CCrEI,CAJO,EAoBR,GAAwB,GAAsB,CAAC,IAhB1B,UAAa,CAAG,iCAOpC,EAAoB,YAAe,CAAG,mCAItC,EAAoB,eAAkB,CAAG,mCAIzC,EAAoB,gBAAmB,CAAG,oCAMV,EAAoB,gBAAgB,CC5C9DA,OAAO,GAAG,CAAC,4BACNA,OAAO,GAAG,CAAC,kCCGG,ACEtB,SAA6B,CAAO,EACvC,GAAM,CAAE,WAAS,CAAE,aAAW,CAAE,gBAAc,CAAE,CAAG,CAiEvD,EDpEiD,CAC7C,UAAW,gBACX,YAAa,kBACb,eFNuB,QEO3B,GEJsB,EAAiB,0BCJN,AAAIC,MAAM,qGAC5B,EAAiB,0B,ILiBrB,EACA,E,UMwDc,KAAoB,CAIxB,IAAgB,CAIf,IAAiB,CAQjB,IAAqB,CAIjB,IAAqB,CAIlB,IAAwB,CAIxB,IAAwB,CAI1B,IAAsB,C,SCvGlC,EAAiB,iB,eCLV,EAAmB,sB,eC+BtBD,OAAO,cC3BS,IAAsB,CCAhC,IAAY,CCFX,EAAmB,kCCAxB,IACQE,QCwECF,OAAO,GAAG,CAAC,uCC3EnB,EAAmB,e,wBCK1B,EAAiB,0BCLC,AAAIC,MAAM,0DAC5B,EAAiB,yBCDC,AAAIA,MAAM,gEAC5B,EAAiB,+BCDC,AAAIA,MAAM,8DAC5B,EAAiB,6BCDC,AAAIA,MAAM,uDAC5B,EAAiB,sBCDC,AAAIA,MAAM,gEAC5B,EAAiB,+BCsCX,AA/BqB,aAAhB,OAAOE,MAAwBA,AAAkB,SAAlBA,KAAK,QAAQ,EA+B7BA,KAAK,QAAQ,CAAC,IAAI,CCnC5C,EAAiB,gCCJC,AAAIF,MAAM,8DAC5B,EAAiB,6BCDC,AAAIA,MAAM,yDAC5B,EAAiB,wBCDC,AAAIA,MAAM,6DAC5B,EAAiB,4BCDC,AAAIA,MAAM,oIAC5B,EAAiB,+BCDC,AAAIA,MAAM,8DAC5B,EAAiB,6BCIjB,EAAiB,8BCLC,AAAIA,MAAM,+DAC5B,EAAiB,8BCDhC,IAAMG,EAAiB,uBACU,AAAIH,MAAM,CAAC,EAAEG,EAAe,+BAA+B,CAAC,EAC9E,EAAiBA,GCFC,AAAIH,MAAM,+DAC5B,EAAiB,6B"}