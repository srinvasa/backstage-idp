import { useAsync } from 'react-use';
import { Octokit } from '@octokit/rest';
import { useApi } from '@backstage/core-plugin-api';
import { useProjectEntity } from './useProjectEntity.esm.js';
import { useEntityGithubScmIntegration } from './useEntityGithubScmIntegration.esm.js';
import { useStore } from '../components/store.esm.js';
import { scmAuthApiRef } from '@backstage/integration-react';

const useRequest = (entity, requestName, perPage = 0, maxResults = 0) => {
  const auth = useApi(scmAuthApiRef);
  const { hostname, baseUrl } = useEntityGithubScmIntegration(entity);
  const { owner, repo } = useProjectEntity(entity);
  const { state: requestState, setState: setRequestState } = useStore(
    (state) => state.request
  );
  const { value, loading, error } = useAsync(async () => {
    let result;
    try {
      const { token } = await auth.getCredentials({
        url: `https://${hostname}/`,
        additionalScope: {
          customScopes: {
            github: ["repo"]
          }
        }
      });
      const octokit = new Octokit({ auth: token });
      const response = await octokit.request(
        `GET /repos/{owner}/{repo}/${requestName}`,
        {
          headers: { "if-none-match": requestState[requestName].etag },
          baseUrl,
          owner,
          repo,
          ...perPage && { per_page: perPage }
        }
      );
      const data = response.data;
      result = {
        data: maxResults ? data.slice(0, maxResults) : data,
        etag: response.headers.etag ?? ""
      };
    } catch (e) {
      if (e.status === 304) {
        result = requestState[requestName];
      }
    }
    return result;
  }, [baseUrl, requestName]);
  if (value?.data) {
    setRequestState(requestName, value);
  }
  return {
    value: value ? value.data : void 0,
    loading,
    error
  };
};

export { useRequest };
//# sourceMappingURL=useRequest.esm.js.map
