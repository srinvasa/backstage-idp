import { readGithubIntegrationConfigs } from '@backstage/integration';
import { Octokit } from '@octokit/rest';
import { DateTime } from 'luxon';
import { SecondaryRateLimitHandler } from './SecondaryRateLimitHandler.esm.js';

class GithubPullRequestsClient {
  configApi;
  scmAuthApi;
  rateLimitHandler = SecondaryRateLimitHandler.getInstance();
  constructor(options) {
    this.configApi = options.configApi;
    this.scmAuthApi = options.scmAuthApi;
  }
  async getOctokit(hostname = "github.com") {
    const { token } = await this.scmAuthApi.getCredentials({
      url: `https://${hostname}/`,
      additionalScope: {
        customScopes: {
          github: ["repo"]
        }
      }
    });
    const configs = readGithubIntegrationConfigs(
      this.configApi.getOptionalConfigArray("integrations.github") ?? []
    );
    const githubIntegrationConfig = configs.find((v) => v.host === hostname);
    const baseUrl = githubIntegrationConfig?.apiBaseUrl;
    return new Octokit({ auth: token, baseUrl });
  }
  async listPullRequests({
    search = "",
    owner,
    repo,
    pageSize = 5,
    page,
    hostname
  }) {
    return this.rateLimitHandler.executeWithBackoff(async () => {
      const octokit = await this.getOctokit(hostname);
      const pullRequestResponse = await octokit.search.issuesAndPullRequests({
        q: `${search} in:title type:pr repo:${owner}/${repo}`,
        per_page: pageSize,
        page
      });
      return {
        pullRequestsData: pullRequestResponse.data
      };
    });
  }
  async getRepositoryData({
    hostname,
    url
  }) {
    return this.rateLimitHandler.executeWithBackoff(async () => {
      const octokit = await this.getOctokit(hostname);
      const response = await octokit.request({ url });
      return {
        htmlUrl: response.data.html_url,
        fullName: response.data.full_name,
        additions: response.data.additions,
        deletions: response.data.deletions,
        changedFiles: response.data.changed_files
      };
    });
  }
  async getCommitDetailsData({
    hostname,
    owner,
    repo,
    number
  }) {
    return this.rateLimitHandler.executeWithBackoff(async () => {
      const octokit = await this.getOctokit(hostname);
      const { data: commits } = await octokit.pulls.listCommits({
        owner,
        repo,
        pull_number: number
      });
      if (commits.length === 0) {
        return {
          firstCommitDate: null
        };
      }
      const firstCommit = commits[0];
      return {
        firstCommitDate: new Date(firstCommit.commit.author.date)
      };
    });
  }
  async searchPullRequest({
    query,
    hostname
  }) {
    return this.rateLimitHandler.executeWithBackoff(async () => {
      const octokit = await this.getOctokit(hostname);
      const pullRequestResponse = await octokit.search.issuesAndPullRequests({
        q: query,
        per_page: 100,
        page: 1
      });
      return pullRequestResponse.data.items.map((pr) => ({
        id: pr.id,
        state: pr.state,
        draft: pr.draft ?? false,
        merged: pr.pull_request?.merged_at ?? void 0,
        repositoryUrl: pr.repository_url,
        pullRequest: {
          htmlUrl: pr.pull_request?.html_url || void 0,
          created_at: DateTime.fromISO(pr.created_at).toRelative() || void 0
        },
        title: pr.title,
        number: pr.number,
        user: {
          login: pr.user?.login,
          htmlUrl: pr.user?.html_url
        },
        comments: pr.comments,
        htmlUrl: pr.html_url
      }));
    });
  }
}

export { GithubPullRequestsClient };
//# sourceMappingURL=GithubPullRequestsClient.esm.js.map
